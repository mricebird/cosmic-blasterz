<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Blasterz</title>

    <!-- PWA Meta Tags -->
    <meta name="author" content="Martin Schaldemose">
    <meta name="date" content="2026-01-17">
    <meta property="article:published_time" content="2026-01-17">
    <meta name="description" content="Defend Earth from the alien invasion in this epic retro arcade shooter!">
    <meta name="theme-color" content="#00ffff">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Cosmic Blasterz">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="logo.png">
    <link rel="icon" type="image/png" href="logo.png">

    <!-- Open Graph Meta Tags (LinkedIn, Facebook) -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Cosmic Blasterz - Retro Arcade Space Shooter">
    <meta property="og:description" content="I built this retro arcade game using AI as my co-pilot! Classic space shooter with boss battles, achievements, upgradeable ships, and global leaderboards. Try to beat my highscore!">
    <meta property="og:image" content="https://mricebird.github.io/cosmic-blasterz/logo.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:url" content="https://mricebird.github.io/cosmic-blasterz/">
    <meta property="og:site_name" content="Cosmic Blasterz">
    <meta property="og:locale" content="en_US">

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Cosmic Blasterz - Retro Arcade Space Shooter">
    <meta name="twitter:description" content="I built this retro arcade game using AI as my co-pilot! Classic space shooter with boss battles, achievements, and global leaderboards.">
    <meta name="twitter:image" content="https://mricebird.github.io/cosmic-blasterz/logo.png">
    <meta name="twitter:creator" content="@mricebird">

    <!-- Canonical URL -->
    <link rel="canonical" href="https://mricebird.github.io/cosmic-blasterz/">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Inter font added to fix 'i' glyph rendering issue (Rajdhani has unusual lowercase i) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&family=Press+Start+2P&family=Share+Tech+Mono&family=VT323&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: radial-gradient(ellipse at center, #0a0a1a 0%, #000 70%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow-x: hidden;
        }

        /* Splash Screen */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center, #0a0a2a 0%, #000 70%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            cursor: pointer;
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }

        .splash-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .splash-logo {
            max-width: 90%;
            max-height: 60vh;
            width: auto;
            height: auto;
            animation: logoFloat 3s ease-in-out infinite, logoGlow 2s ease-in-out infinite alternate;
            filter: drop-shadow(0 0 30px rgba(0, 150, 255, 0.5));
        }

        @keyframes logoFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }

        @keyframes logoGlow {
            0% { filter: drop-shadow(0 0 20px rgba(0, 150, 255, 0.4)); }
            100% { filter: drop-shadow(0 0 40px rgba(0, 200, 255, 0.7)); }
        }

        .splash-prompt {
            position: absolute;
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 6px;
            text-shadow:
                0 0 10px rgba(0, 200, 255, 0.8),
                0 0 20px rgba(0, 200, 255, 0.6),
                0 0 30px rgba(0, 200, 255, 0.4),
                0 0 40px rgba(0, 150, 255, 0.3);
            animation: promptGlow 2s ease-in-out infinite;
            padding: 15px 30px;
            border: 1px solid rgba(0, 200, 255, 0.3);
            border-radius: 8px;
            background: linear-gradient(180deg, rgba(0, 50, 100, 0.3) 0%, rgba(0, 20, 50, 0.5) 100%);
            backdrop-filter: blur(5px);
            z-index: 10;
        }

        @keyframes promptGlow {
            0%, 100% {
                opacity: 0.7;
                text-shadow:
                    0 0 10px rgba(0, 200, 255, 0.8),
                    0 0 20px rgba(0, 200, 255, 0.6),
                    0 0 30px rgba(0, 200, 255, 0.4);
                border-color: rgba(0, 200, 255, 0.3);
                transform: translateX(-50%) scale(1);
            }
            50% {
                opacity: 1;
                text-shadow:
                    0 0 15px rgba(0, 255, 255, 1),
                    0 0 30px rgba(0, 255, 255, 0.8),
                    0 0 45px rgba(0, 200, 255, 0.6),
                    0 0 60px rgba(0, 150, 255, 0.4);
                border-color: rgba(0, 255, 255, 0.6);
                transform: translateX(-50%) scale(1.02);
            }
        }

        .splash-stars {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            pointer-events: none;
        }

        .splash-star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s ease-in-out infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Amiga Sine Wave Scroller */
        .splash-scroller {
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 0;
            height: 80px;
            overflow: hidden;
        }

        .splash-scroller canvas {
            width: 100%;
            height: 100%;
        }

        /* Copyright */
        .splash-copyright {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            text-align: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 2px;
        }

        /* Mobile splash adjustments */
        @media (max-width: 600px) {
            .splash-logo {
                max-width: 95%;
                max-height: 40vh;
            }
            .splash-prompt {
                font-size: 11px;
                letter-spacing: 2px;
                padding: 10px 16px;
                bottom: 140px;
            }
            .splash-scroller {
                bottom: 60px;
                height: 60px;
            }
            .splash-copyright {
                font-size: 10px;
                bottom: 15px;
            }
        }

        .game-container {
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow:
                0 0 40px rgba(0, 0, 0, 0.5),
                0 0 80px rgba(0, 20, 40, 0.3);
            border-radius: 8px;
            overflow: hidden;
        }

        canvas {
            display: block;
            background: linear-gradient(180deg, #000008 0%, #000510 50%, #000815 100%);
        }

        /* CRT Retro Effect Overlay */
        .crt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
            overflow: hidden;
            border-radius: 8px;
        }

        .crt-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
        }

        .crt-overlay::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(
                ellipse at center,
                transparent 0%,
                rgba(0, 0, 0, 0.2) 90%,
                rgba(0, 0, 0, 0.4) 100%
            );
            pointer-events: none;
        }

        /* Subtle screen flicker animation */
        @keyframes crtFlicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.9; }
            94% { opacity: 1; }
        }

        .crt-overlay.flicker {
            animation: crtFlicker 4s infinite;
        }

        /* Screen glow effect */
        .game-container::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: radial-gradient(
                ellipse at center,
                rgba(0, 150, 255, 0.1) 0%,
                transparent 70%
            );
            pointer-events: none;
            z-index: -1;
            border-radius: 10px;
        }

        /* Chromatic aberration effect (activated on damage) */
        .chromatic-aberration {
            animation: chromaticShift 0.1s ease-out;
        }

        @keyframes chromaticShift {
            0% {
                filter: none;
                transform: translate(0, 0);
            }
            25% {
                filter: drop-shadow(-2px 0 0 rgba(255, 0, 0, 0.5)) drop-shadow(2px 0 0 rgba(0, 255, 255, 0.5));
                transform: translate(1px, 0);
            }
            50% {
                filter: drop-shadow(-3px 0 0 rgba(255, 0, 0, 0.7)) drop-shadow(3px 0 0 rgba(0, 255, 255, 0.7));
                transform: translate(-1px, 0);
            }
            75% {
                filter: drop-shadow(-1px 0 0 rgba(255, 0, 0, 0.3)) drop-shadow(1px 0 0 rgba(0, 255, 255, 0.3));
                transform: translate(0, 0);
            }
            100% {
                filter: none;
                transform: translate(0, 0);
            }
        }

        /* Screen flash effect */
        .screen-flash {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 99;
            opacity: 0;
            border-radius: 8px;
        }

        .screen-flash.active {
            animation: flashPulse 0.15s ease-out;
        }

        @keyframes flashPulse {
            0% { opacity: 0.8; }
            100% { opacity: 0; }
        }

        .ui-overlay {
            position: absolute;
            top: 12px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 8px;
            padding: 0 15px;
            pointer-events: none;
            font-family: 'Orbitron', monospace;
        }

        .score, .lives, .level {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.5px;
            min-width: 80px;
            text-align: center;
        }

        .score::before, .lives::before, .level::before {
            display: none;
        }

        .score {
            color: #4fd1ff;
            border-color: rgba(79, 209, 255, 0.3);
            text-shadow: 0 0 8px rgba(79, 209, 255, 0.5);
        }

        .lives {
            color: #ff6b6b;
            border-color: rgba(255, 107, 107, 0.3);
            text-shadow: 0 0 8px rgba(255, 107, 107, 0.5);
        }

        .player2-lives {
            color: #f0f;
            border-color: rgba(255, 0, 255, 0.3);
            text-shadow: 0 0 8px rgba(255, 0, 255, 0.5);
        }

        .level {
            color: #ffd93d;
            border-color: rgba(255, 217, 61, 0.3);
            text-shadow: 0 0 8px rgba(255, 217, 61, 0.5);
        }

        .game-over-screen, .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            background: rgba(0, 5, 15, 0.92);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            color: #0ff;
            text-align: center;
            border-radius: 10px;
            padding-top: 20px;
            padding-bottom: 60px;
            overflow-y: auto;
        }

        /* Epic 3D game title */
        .game-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 42px;
            font-weight: 900;
            margin: 10px 0;
            letter-spacing: 4px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            perspective: 500px;
        }

        .game-title .letter {
            display: inline-block;
            animation: letterJump3D 1.5s ease-in-out infinite;
            color: #fff;
            text-shadow:
                /* 3D extrusion effect */
                0 1px 0 #0cc,
                0 2px 0 #0bb,
                0 3px 0 #0aa,
                0 4px 0 #099,
                0 5px 0 #088,
                /* Glow */
                0 0 10px #0ff,
                0 0 20px #0ff,
                0 0 40px #0ff,
                0 0 80px #f0f;
        }

        .game-title .space {
            width: 0.4em;
        }

        @keyframes letterJump3D {
            0%, 100% {
                transform: translateY(0) rotateX(0deg) scale(1);
                color: #0ff;
                text-shadow:
                    0 1px 0 #0cc,
                    0 2px 0 #0bb,
                    0 3px 0 #0aa,
                    0 4px 0 #099,
                    0 5px 0 #088,
                    0 0 10px #0ff,
                    0 0 20px #0ff,
                    0 0 40px #0ff,
                    0 0 80px #f0f;
            }
            25% {
                color: #ff0;
            }
            50% {
                transform: translateY(-15px) rotateX(10deg) scale(1.1);
                color: #f0f;
                text-shadow:
                    0 1px 0 #c0c,
                    0 2px 0 #b0b,
                    0 3px 0 #a0a,
                    0 4px 0 #909,
                    0 5px 0 #808,
                    0 6px 0 #707,
                    0 7px 0 #606,
                    0 8px 15px rgba(0,0,0,0.5),
                    0 0 20px #f0f,
                    0 0 40px #f0f,
                    0 0 80px #0ff,
                    0 0 120px #f0f;
            }
            75% {
                color: #0f0;
            }
        }

        /* Settings bar */
        .menu-settings-bar {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            width: 100%;
            max-width: 500px;
            margin: 15px 0;
            padding: 10px 20px;
            background: rgba(0, 20, 40, 0.5);
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 255, 0.2);
        }

        /* Name input */
        .menu-name-input input {
            background: rgba(0, 10, 20, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            padding: 10px 16px;
            color: #0ff;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            width: 200px;
            outline: none;
            transition: all 0.2s;
        }

        .menu-name-input input:focus {
            border-color: #0ff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .menu-name-input input::placeholder {
            color: rgba(0, 255, 255, 0.4);
        }

        /* Quick settings buttons */
        .menu-quick-settings {
            display: flex;
            gap: 8px;
        }

        .menu-quick-btn {
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            color: #0ff;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-width: 60px;
        }

        .menu-quick-btn .btn-icon {
            font-size: 18px;
        }

        .menu-quick-btn .btn-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .menu-quick-btn:hover {
            background: rgba(0, 255, 255, 0.15);
            border-color: #0ff;
            transform: scale(1.05);
        }

        .menu-quick-btn.active {
            background: rgba(0, 255, 255, 0.2);
        }

        /* Menu footer buttons */
        .menu-footer {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .menu-footer-btn {
            background: rgba(0, 20, 40, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            padding: 10px 18px;
            color: rgba(0, 255, 255, 0.8);
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .menu-footer-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: #0ff;
            color: #0ff;
        }

        /* Creator link */
        .creator-link {
            display: block;
            margin-top: 20px;
            margin-bottom: 10px;
            padding: 10px 20px;
            color: rgba(0, 255, 255, 0.7);
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            text-decoration: none;
            transition: all 0.2s;
            background: rgba(0, 20, 40, 0.5);
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.2);
        }

        .creator-link:hover {
            color: #0ff;
            border-color: #0ff;
            background: rgba(0, 255, 255, 0.1);
        }

        .credits-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .credits-row .creator-link {
            margin: 0;
        }

        .ai-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 10px 16px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.3), rgba(75, 0, 130, 0.4));
            border: 1px solid rgba(138, 43, 226, 0.5);
            border-radius: 8px;
            color: #da70d6;
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 1px;
            cursor: default;
            transition: all 0.3s;
            animation: aiBadgePulse 3s ease-in-out infinite;
        }

        .ai-badge:hover {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.5), rgba(75, 0, 130, 0.6));
            border-color: #da70d6;
            transform: scale(1.05);
        }

        @keyframes aiBadgePulse {
            0%, 100% { box-shadow: 0 0 5px rgba(138, 43, 226, 0.3); }
            50% { box-shadow: 0 0 15px rgba(138, 43, 226, 0.6), 0 0 25px rgba(218, 112, 214, 0.3); }
        }

        .game-over-screen h1, .start-screen h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 42px;
            font-weight: 800;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.6), 0 0 60px rgba(255, 0, 255, 0.3);
            margin-bottom: 15px;
            letter-spacing: 3px;
            animation: titleGlow 2s ease-in-out infinite;
        }

        .game-over-screen h1 {
            font-size: 56px;
            color: #ff3333;
            text-shadow:
                0 0 20px rgba(255, 0, 0, 0.8),
                0 0 40px rgba(255, 0, 0, 0.6),
                0 0 60px rgba(255, 0, 0, 0.4),
                0 0 80px rgba(255, 0, 0, 0.2);
            animation: gameOverPulse 1.5s ease-in-out infinite, gameOverEntry 0.5s ease-out;
            letter-spacing: 8px;
            margin-bottom: 8px;
        }

        .game-over-subtitle {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 18px;
            color: rgba(255, 100, 100, 0.8);
            margin-bottom: 20px;
            letter-spacing: 2px;
            animation: fadeInUp 0.6s ease-out 0.2s both;
        }

        @keyframes gameOverPulse {
            0%, 100% {
                text-shadow:
                    0 0 20px rgba(255, 0, 0, 0.8),
                    0 0 40px rgba(255, 0, 0, 0.6),
                    0 0 60px rgba(255, 0, 0, 0.4);
                transform: scale(1);
            }
            50% {
                text-shadow:
                    0 0 30px rgba(255, 50, 50, 1),
                    0 0 60px rgba(255, 0, 0, 0.8),
                    0 0 90px rgba(255, 0, 0, 0.5);
                transform: scale(1.02);
            }
        }

        @keyframes gameOverEntry {
            0% {
                opacity: 0;
                transform: scale(1.5);
                filter: blur(10px);
            }
            100% {
                opacity: 1;
                transform: scale(1);
                filter: blur(0);
            }
        }

        @keyframes fadeInUp {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .start-screen h1 {
            font-size: 24px;
            background: linear-gradient(135deg, #0ff 0%, #f0f 50%, #0ff 100%);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease infinite;
            margin-bottom: 5px;
        }

        @keyframes titleGlow {
            0%, 100% {
                text-shadow: 0 0 30px rgba(0, 255, 255, 0.6), 0 0 60px rgba(255, 0, 255, 0.3);
                transform: scale(1);
            }
            50% {
                text-shadow: 0 0 40px rgba(0, 255, 255, 0.8), 0 0 80px rgba(255, 0, 255, 0.5);
                transform: scale(1.02);
            }
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .final-score {
            font-family: 'Orbitron', sans-serif;
            font-size: 22px;
            font-weight: 500;
            margin-bottom: 15px;
            color: rgba(255, 255, 255, 0.9);
        }

        .game-stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 255, 0.15);
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            background: rgba(0, 20, 40, 0.5);
            border-radius: 8px;
            transition: transform 0.2s ease;
        }

        .stat-item:hover {
            transform: scale(1.05);
        }

        .stat-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 700;
            color: #0ff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .stat-label {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        @media (max-width: 500px) {
            .game-stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .restart-btn, .start-btn {
            padding: 14px 36px;
            font-size: 16px;
            font-weight: 600;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1) 0%, rgba(0, 255, 255, 0.05) 100%);
            color: #0ff;
            border: 2px solid rgba(0, 255, 255, 0.6);
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }

        .restart-btn::before, .start-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .restart-btn:hover::before, .start-btn:hover::before {
            left: 100%;
        }

        .restart-btn:hover, .start-btn:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.9) 0%, rgba(0, 200, 255, 0.8) 100%);
            color: #000;
            border-color: #0ff;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.5), 0 8px 25px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }

        .restart-btn:active, .start-btn:active {
            transform: translateY(0);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }

        .mode-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .mode-card {
            background: rgba(0, 20, 40, 0.85);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 16px;
            padding: 25px 35px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .mode-card:hover {
            background: rgba(0, 50, 100, 0.85);
            border-color: rgba(0, 255, 255, 0.6);
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.4), 0 0 20px rgba(0, 255, 255, 0.2);
        }

        .mode-card.normal:hover {
            border-color: rgba(0, 255, 255, 0.6);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }

        .mode-card.endless:hover {
            border-color: rgba(255, 136, 0, 0.6);
            box-shadow: 0 0 20px rgba(255, 136, 0, 0.2);
        }

        .mode-card.tutorial:hover {
            border-color: rgba(0, 255, 0, 0.6);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }

        .mode-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .mode-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 4px;
            color: #0ff;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.4);
        }

        .mode-desc {
            font-family: 'Inter', system-ui, sans-serif;
            font-size: 11px;
            color: rgba(0, 255, 255, 0.6);
            line-height: 1.3;
            margin-top: 5px;
        }

        .mode-card.endless .mode-title {
            color: #f80;
        }

        .mode-card.tutorial .mode-title {
            color: #0f0;
        }

        .mode-card.twoplayer:hover {
            border-color: rgba(255, 0, 255, 0.6);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.2);
        }

        .mode-card.twoplayer .mode-title {
            color: #f0f;
        }

        .mode-card.aidemo:hover {
            border-color: rgba(0, 255, 136, 0.6);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
        }

        .mode-card.aidemo .mode-title {
            color: #0f8;
        }

        .mode-card.aidemo .mode-icon {
            animation: robotPulse 1.5s ease-in-out infinite;
        }

        @keyframes robotPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .mode-card.bossrush:hover {
            border-color: rgba(255, 50, 50, 0.6);
            box-shadow: 0 0 20px rgba(255, 50, 50, 0.3);
        }

        .mode-card.bossrush .mode-title {
            color: #f33;
        }

        .mode-card.bossrush .mode-icon {
            animation: bossShake 0.5s ease-in-out infinite;
        }

        @keyframes bossShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px) rotate(-5deg); }
            75% { transform: translateX(3px) rotate(5deg); }
        }

        .mode-card.roguelike:hover {
            border-color: rgba(255, 200, 0, 0.6);
            box-shadow: 0 0 20px rgba(255, 200, 0, 0.3);
        }

        .mode-card.roguelike .mode-title {
            color: #fc0;
        }

        .mode-card.roguelike .mode-icon {
            animation: diceRoll 1.5s ease-in-out infinite;
        }

        @keyframes diceRoll {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(15deg); }
            75% { transform: rotate(-15deg); }
        }

        /* Roguelike Upgrade Modal */
        .roguelike-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            animation: fadeIn 0.3s ease;
        }

        .roguelike-modal.hidden {
            display: none;
            pointer-events: none;
        }

        .roguelike-title {
            font-family: 'Orbitron', monospace;
            font-size: 28px;
            color: #fc0;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 200, 0, 0.7);
        }

        .upgrade-cards {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .upgrade-card {
            position: relative;
            background: linear-gradient(180deg, rgba(30, 30, 50, 0.9) 0%, rgba(20, 20, 40, 0.95) 100%);
            border: 2px solid rgba(255, 200, 0, 0.3);
            border-radius: 15px;
            padding: 25px 20px;
            width: 180px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upgrade-card:hover {
            transform: translateY(-10px) scale(1.05);
            border-color: #fc0;
            box-shadow: 0 10px 30px rgba(255, 200, 0, 0.3);
        }

        .upgrade-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .upgrade-name {
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            color: #fc0;
            margin-bottom: 10px;
        }

        .upgrade-desc {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.4;
        }

        .upgrade-key-hint {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(255, 200, 0, 0.2);
            border: 1px solid rgba(255, 200, 0, 0.5);
            border-radius: 4px;
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            font-weight: bold;
            color: #fc0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .upgrade-rarity-common {
            border-color: rgba(150, 150, 150, 0.5);
        }
        .upgrade-rarity-common .upgrade-name {
            color: #aaa;
        }

        .upgrade-rarity-rare {
            border-color: rgba(0, 150, 255, 0.5);
        }
        .upgrade-rarity-rare .upgrade-name {
            color: #0af;
        }

        .upgrade-rarity-epic {
            border-color: rgba(200, 0, 255, 0.5);
        }
        .upgrade-rarity-epic .upgrade-name {
            color: #c0f;
        }

        .upgrade-rarity-legendary {
            border-color: rgba(255, 200, 0, 0.5);
            animation: legendaryGlow 2s ease-in-out infinite;
        }
        .upgrade-rarity-legendary .upgrade-name {
            color: #fc0;
        }

        @keyframes legendaryGlow {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 200, 0, 0.3); }
            50% { box-shadow: 0 0 30px rgba(255, 200, 0, 0.6); }
        }

        /* Custom Confirm Modal */
        .confirm-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10002;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .confirm-modal.active {
            opacity: 1;
            visibility: visible;
        }

        .confirm-dialog {
            background: linear-gradient(180deg, rgba(30, 30, 50, 0.95) 0%, rgba(20, 20, 40, 0.98) 100%);
            border: 2px solid rgba(255, 100, 100, 0.5);
            border-radius: 20px;
            padding: 30px 40px;
            max-width: 400px;
            text-align: center;
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .confirm-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .confirm-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            color: #f55;
            margin-bottom: 15px;
            text-shadow: 0 0 15px rgba(255, 100, 100, 0.5);
        }

        .confirm-message {
            font-family: 'Inter', system-ui, sans-serif;
            font-size: 15px;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .confirm-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .confirm-btn {
            padding: 12px 30px;
            border-radius: 10px;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid;
        }

        .confirm-btn-cancel {
            background: rgba(100, 100, 100, 0.3);
            border-color: rgba(150, 150, 150, 0.5);
            color: #aaa;
        }

        .confirm-btn-cancel:hover {
            background: rgba(100, 100, 100, 0.5);
            color: #fff;
        }

        .confirm-btn-confirm {
            background: linear-gradient(180deg, rgba(255, 80, 80, 0.4) 0%, rgba(200, 50, 50, 0.5) 100%);
            border-color: rgba(255, 100, 100, 0.6);
            color: #f88;
        }

        .confirm-btn-confirm:hover {
            background: linear-gradient(180deg, rgba(255, 80, 80, 0.7) 0%, rgba(200, 50, 50, 0.8) 100%);
            color: #fff;
            box-shadow: 0 0 20px rgba(255, 100, 100, 0.4);
        }

        .endless-btn {
            border-color: rgba(255, 136, 0, 0.6) !important;
            color: #f80 !important;
            background: linear-gradient(135deg, rgba(255, 136, 0, 0.1) 0%, rgba(255, 136, 0, 0.05) 100%) !important;
        }

        .endless-btn:hover {
            background: linear-gradient(135deg, rgba(255, 136, 0, 0.9) 0%, rgba(255, 100, 0, 0.8) 100%) !important;
            color: #000 !important;
            border-color: #f80 !important;
            box-shadow: 0 0 25px rgba(255, 136, 0, 0.5), 0 8px 25px rgba(0, 0, 0, 0.3) !important;
        }

        .tutorial-btn {
            border-color: rgba(0, 255, 0, 0.6) !important;
            color: #0f0 !important;
            background: linear-gradient(135deg, rgba(0, 255, 0, 0.1) 0%, rgba(0, 255, 0, 0.05) 100%) !important;
        }

        .tutorial-btn:hover {
            background: linear-gradient(135deg, rgba(0, 255, 0, 0.9) 0%, rgba(0, 200, 0, 0.8) 100%) !important;
            color: #000 !important;
            border-color: #0f0 !important;
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.5), 0 8px 25px rgba(0, 0, 0, 0.3) !important;
        }

        .tutorial-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 5, 15, 0.85);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .tutorial-box {
            background: linear-gradient(135deg, rgba(0, 30, 60, 0.95) 0%, rgba(0, 15, 35, 0.98) 100%);
            border: 2px solid rgba(0, 255, 255, 0.4);
            border-radius: 16px;
            padding: 28px 38px;
            max-width: 420px;
            text-align: center;
            box-shadow:
                0 0 30px rgba(0, 255, 255, 0.2),
                0 20px 40px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: panelFloat 3s ease-in-out infinite;
        }

        @keyframes panelFloat {
            0%, 100% {
                transform: translateY(0);
                box-shadow: 0 0 30px rgba(0, 255, 255, 0.2), 0 20px 40px rgba(0, 0, 0, 0.4);
            }
            50% {
                transform: translateY(-5px);
                box-shadow: 0 0 40px rgba(0, 255, 255, 0.3), 0 25px 50px rgba(0, 0, 0, 0.5);
            }
        }

        .tutorial-title {
            font-family: 'Orbitron', sans-serif;
            color: #0ff;
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 15px;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        .tutorial-text {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: rgba(255, 255, 255, 0.9);
            font-size: 17px;
            font-weight: 500;
            line-height: 1.7;
            margin-bottom: 22px;
        }

        .tutorial-highlight {
            color: #ff0;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 255, 0, 0.4);
        }

        .tutorial-progress {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 18px;
        }

        .tutorial-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(50, 50, 70, 0.8);
            border: 2px solid rgba(0, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .tutorial-dot.active {
            background: #0ff;
            border-color: #0ff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
        }

        .tutorial-dot.completed {
            background: #0f0;
            border-color: #0f0;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
        }

        .tutorial-btn-next {
            padding: 12px 32px;
            background: linear-gradient(135deg, #0ff 0%, #0cc 100%);
            border: none;
            border-radius: 8px;
            color: #000;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
        }

        .tutorial-btn-next:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.5);
        }

        .tutorial-btn-skip {
            padding: 10px 22px;
            background: transparent;
            border: 1px solid rgba(100, 100, 120, 0.5);
            border-radius: 8px;
            color: rgba(150, 150, 170, 0.8);
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-weight: 500;
            cursor: pointer;
            font-size: 13px;
            margin-left: 12px;
            transition: all 0.3s ease;
        }

        .tutorial-btn-skip:hover {
            border-color: rgba(150, 150, 170, 0.7);
            color: rgba(200, 200, 220, 0.9);
            background: rgba(100, 100, 120, 0.1);
        }

        /* Game over buttons */
        .game-over-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }

        .game-over-buttons .share-btn {
            padding: 10px 20px;
            font-size: 12px;
            font-weight: 500;
            background: transparent;
            color: #6bcf6b;
            border: 1px solid rgba(107, 207, 107, 0.4);
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            transition: all 0.2s ease;
            width: auto;
            height: auto;
            display: inline-block;
        }

        .game-over-buttons .share-btn:hover {
            background: rgba(107, 207, 107, 0.15);
            border-color: rgba(107, 207, 107, 0.6);
        }

        .game-over-buttons .menu-btn {
            padding: 10px 20px;
            font-size: 12px;
            font-weight: 500;
            background: transparent;
            color: #f0a030;
            border: 1px solid rgba(240, 160, 48, 0.4);
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            transition: all 0.2s ease;
        }

        .game-over-buttons .menu-btn:hover {
            background: rgba(240, 160, 48, 0.15);
            border-color: rgba(240, 160, 48, 0.6);
        }

        .share-options {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .share-option-btn {
            padding: 10px 18px;
            font-size: 13px;
            font-weight: 500;
            background: rgba(20, 30, 50, 0.8);
            border: 1px solid rgba(100, 100, 130, 0.4);
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.8);
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .share-option-btn:hover {
            background: rgba(40, 50, 80, 0.9);
            border-color: rgba(0, 255, 255, 0.5);
            color: #fff;
            transform: translateY(-1px);
        }

        .share-copied {
            margin-top: 12px;
            color: #0f0;
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 15px;
            font-weight: 600;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.4);
        }

        .endless-timer {
            position: absolute;
            top: 10px;
            left: 12px;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            font-weight: 600;
            color: #f80;
            text-shadow: 0 0 15px rgba(255, 136, 0, 0.6);
            background: rgba(0, 20, 40, 0.7);
            padding: 6px 14px;
            border-radius: 6px;
            border: 1px solid rgba(255, 136, 0, 0.3);
        }

        .endless-wave {
            position: absolute;
            top: 42px;
            left: 12px;
            font-family: 'Orbitron', sans-serif;
            font-size: 13px;
            font-weight: 500;
            color: #ff0;
            text-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
        }

        .endless-survival {
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            font-weight: 500;
            color: #f80;
            margin: 12px 0;
        }

        .boss-rush-display {
            position: fixed;
            top: 60px;
            right: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: linear-gradient(135deg, rgba(255, 50, 50, 0.2) 0%, rgba(150, 0, 0, 0.3) 100%);
            border: 2px solid rgba(255, 50, 50, 0.5);
            border-radius: 8px;
            font-family: 'Orbitron', sans-serif;
            z-index: 50;
            animation: bossRushPulse 1s ease-in-out infinite;
        }

        @keyframes bossRushPulse {
            0%, 100% { border-color: rgba(255, 50, 50, 0.5); }
            50% { border-color: rgba(255, 100, 100, 0.8); }
        }

        .boss-rush-icon {
            font-size: 20px;
            animation: bossIconShake 0.3s ease-in-out infinite;
        }

        @keyframes bossIconShake {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-5deg); }
            75% { transform: rotate(5deg); }
        }

        .boss-rush-text {
            font-size: 14px;
            font-weight: 700;
            color: #f55;
            text-shadow: 0 0 10px rgba(255, 50, 50, 0.5);
        }

        .game-subtitle {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 12px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 15px;
        }

        /* Difficulty Selector */
        .difficulty-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            padding: 10px 15px;
            background: rgba(0, 20, 40, 0.6);
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            width: min(420px, 92vw);
        }

        .difficulty-option {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .difficulty-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.9);
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 8px currentColor;
        }

        .difficulty-option.easy .difficulty-label { color: #0f0; text-shadow: 0 0 10px rgba(0, 255, 0, 0.6); }
        .difficulty-option.normal .difficulty-label { color: #0ff; text-shadow: 0 0 10px rgba(0, 255, 255, 0.6); }
        .difficulty-option.hard .difficulty-label { color: #f55; text-shadow: 0 0 10px rgba(255, 85, 85, 0.6); }
        .difficulty-option.nightmare .difficulty-label { color: #f0f; text-shadow: 0 0 10px rgba(255, 0, 255, 0.6); }

        .difficulty-btn {
            width: 100%;
            padding: 12px 8px;
            font-size: 24px;
            border: 1px solid rgba(100, 100, 100, 0.4);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .difficulty-btn:hover {
            background: rgba(0, 50, 80, 0.5);
            border-color: rgba(0, 255, 255, 0.4);
            color: #fff;
        }

        .difficulty-btn.active {
            border-color: #0ff;
            background: rgba(0, 255, 255, 0.15);
            color: #0ff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .difficulty-btn.easy {
            border-color: rgba(0, 255, 100, 0.4);
        }
        .difficulty-btn.easy.active {
            border-color: #0f0;
            background: rgba(0, 255, 0, 0.15);
            color: #0f0;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        }

        .difficulty-btn.normal {
            border-color: rgba(0, 200, 255, 0.4);
        }
        .difficulty-btn.normal.active {
            border-color: #0ff;
            background: rgba(0, 255, 255, 0.15);
            color: #0ff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .difficulty-btn.hard {
            border-color: rgba(255, 100, 100, 0.4);
        }
        .difficulty-btn.hard.active {
            border-color: #f55;
            background: rgba(255, 50, 50, 0.15);
            color: #f55;
            box-shadow: 0 0 15px rgba(255, 50, 50, 0.3);
        }

        .difficulty-btn.nightmare {
            border-color: rgba(255, 0, 255, 0.4);
        }
        .difficulty-btn.nightmare.active {
            border-color: #f0f;
            background: rgba(255, 0, 255, 0.15);
            color: #f0f;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.3);
        }

        .difficulty-desc {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 8px;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 3px;
        }

        .select-mode-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            font-weight: 600;
            color: rgba(0, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .controls-info {
            margin-top: 15px;
            padding: 10px 15px;
            background: rgba(0, 20, 40, 0.4);
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.15);
            width: min(420px, 92vw);
        }

        .controls-info p {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 11px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.5);
            margin: 3px 0;
        }

        .controls-info .controls-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            font-weight: 600;
            color: rgba(0, 255, 255, 0.6);
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.15);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 8px 0;
        }

        .control-player {
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            text-align: center;
        }

        .control-player p {
            margin: 3px 0 !important;
            font-size: 10px !important;
        }

        .player-label {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        .player-label.p1 {
            background: linear-gradient(135deg, #0ff, #0aa);
            color: #000;
        }

        .player-label.p2 {
            background: linear-gradient(135deg, #f0f, #a0a);
            color: #000;
        }

        .controls-extra {
            margin-top: 6px !important;
            font-size: 9px !important;
            color: rgba(255, 255, 255, 0.4) !important;
            text-align: center;
        }

        .controls-gamepad {
            margin-top: 4px !important;
            font-size: 9px !important;
            color: rgba(0, 255, 255, 0.4) !important;
            text-align: center;
        }

        /* Invite Friend Button */
        .invite-friend-container {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 8px;
            width: min(420px, 92vw);
        }

        .invite-friend-btn {
            padding: 8px 16px;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            font-weight: 600;
            color: #fff;
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 50%, #ff6b35 100%);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(255, 107, 53, 0.3);
            position: relative;
            overflow: hidden;
        }

        .invite-friend-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: inviteShine 3s ease-in-out infinite;
        }

        .invite-friend-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.5);
        }

        .invite-friend-btn:active {
            transform: translateY(0);
        }

        @keyframes inviteShine {
            0% { left: -100%; }
            50%, 100% { left: 100%; }
        }

        .creator-btn {
            padding: 8px 16px;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            font-weight: 600;
            color: #fff;
            background: linear-gradient(135deg, #0077b5 0%, #00a0dc 50%, #0077b5 100%);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 119, 181, 0.3);
            text-decoration: none;
            display: inline-block;
        }

        .creator-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 119, 181, 0.5);
            color: #fff;
            text-decoration: none;
        }

        .creator-btn:active {
            transform: translateY(0);
        }

        .garage-btn {
            padding: 8px 16px;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            font-weight: 700;
            color: #fff;
            background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 50%, #8b5cf6 100%);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(139, 92, 246, 0.3);
        }

        .garage-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.5);
        }

        /* Garage Screen */
        .garage-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a2a 100%);
            z-index: 900;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .garage-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            background: rgba(0, 0, 0, 0.9);
            border-bottom: 2px solid rgba(139, 92, 246, 0.3);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .garage-header h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            color: #8b5cf6;
            text-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
            margin: 0;
        }

        .garage-back-btn {
            padding: 10px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: #fff;
            background: rgba(100, 100, 100, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .garage-back-btn:hover {
            background: rgba(100, 100, 100, 0.5);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .garage-coins {
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .garage-content {
            display: flex;
            flex: 1;
            padding: 30px;
            gap: 30px;
            overflow: hidden;
            min-height: 0;
        }

        .garage-ship-display {
            flex: 0 0 450px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(139, 92, 246, 0.3);
            border-radius: 20px;
            padding: 30px;
        }

        #garageCanvas {
            background: radial-gradient(ellipse at center, rgba(30, 30, 60, 1) 0%, rgba(10, 10, 30, 1) 100%);
            border-radius: 15px;
            border: 1px solid rgba(139, 92, 246, 0.2);
        }

        .garage-ship-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            color: #0ff;
            margin-top: 20px;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        .garage-ship-stats {
            width: 100%;
            margin-top: 20px;
        }

        .garage-ship-stats .stat-item {
            display: flex;
            flex-direction: row !important;
            align-items: center;
            margin-bottom: 12px;
            padding: 8px 12px;
            background: rgba(0, 30, 50, 0.6);
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.2);
        }

        .garage-ship-stats .stat-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: 600;
            color: rgba(0, 255, 255, 0.8);
            width: 90px;
            text-transform: uppercase;
        }

        .garage-ship-stats .stat-bar {
            flex: 1;
            height: 14px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 7px;
            overflow: hidden;
            border: 1px solid rgba(0, 255, 255, 0.3);
            margin-left: 10px;
        }

        .garage-ship-stats .stat-fill {
            height: 100%;
            background: linear-gradient(90deg, #0ff, #f0f);
            border-radius: 7px;
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
        }

        .garage-ship-stats .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: 700;
            color: #fff;
            margin-left: 10px;
            min-width: 35px;
            text-align: right;
        }

        .garage-customization {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(139, 92, 246, 0.3);
            border-radius: 20px;
            overflow: hidden;
            min-height: 0;
        }

        .garage-tabs {
            display: flex;
            background: rgba(0, 0, 0, 0.5);
            border-bottom: 1px solid rgba(139, 92, 246, 0.3);
        }

        .garage-tab {
            flex: 1;
            padding: 15px;
            font-family: 'Orbitron', sans-serif;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.6);
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }

        .garage-tab:hover {
            color: #fff;
            background: rgba(139, 92, 246, 0.2);
        }

        .garage-tab.active {
            color: #8b5cf6;
            background: rgba(139, 92, 246, 0.2);
            border-bottom: 2px solid #8b5cf6;
        }

        .garage-items {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
            align-content: start;
            min-height: 0;
            max-height: calc(100vh - 200px);
            -webkit-overflow-scrolling: touch;
        }

        .garage-items::-webkit-scrollbar {
            width: 8px;
        }

        .garage-items::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .garage-items::-webkit-scrollbar-thumb {
            background: rgba(139, 92, 246, 0.5);
            border-radius: 4px;
        }

        .garage-items::-webkit-scrollbar-thumb:hover {
            background: rgba(139, 92, 246, 0.7);
        }

        .garage-item {
            background: rgba(20, 20, 40, 0.8);
            border: 2px solid rgba(100, 100, 150, 0.3);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .garage-item:hover {
            border-color: rgba(139, 92, 246, 0.5);
            transform: translateY(-3px);
        }

        .garage-item.selected {
            border-color: #0ff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .garage-item.locked {
            opacity: 0.5;
        }

        .garage-item-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }

        .garage-item-name {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 5px;
        }

        .garage-item-price {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: #ffd700;
        }

        .garage-item-price.owned {
            color: #0f8;
        }

        .garage-upgrade-btn {
            margin-top: 10px;
            padding: 6px 12px;
            background: linear-gradient(180deg, rgba(255, 200, 0, 0.3) 0%, rgba(255, 150, 0, 0.4) 100%);
            border: 1px solid rgba(255, 200, 0, 0.5);
            border-radius: 6px;
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            color: #fc0;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .garage-upgrade-btn:hover:not(.disabled):not(.maxed) {
            background: linear-gradient(180deg, rgba(255, 200, 0, 0.5) 0%, rgba(255, 150, 0, 0.6) 100%);
            transform: scale(1.05);
        }

        .garage-upgrade-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .garage-upgrade-btn.maxed {
            background: linear-gradient(180deg, rgba(0, 255, 100, 0.2) 0%, rgba(0, 200, 80, 0.3) 100%);
            border-color: rgba(0, 255, 100, 0.5);
            color: #0f8;
            cursor: default;
        }

        .garage-equipped {
            padding: 15px 30px;
            background: rgba(0, 0, 0, 0.5);
            border-top: 2px solid rgba(139, 92, 246, 0.3);
        }

        .garage-equipped h3 {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: #8b5cf6;
            margin: 0 0 10px 0;
        }

        .equipped-items {
            display: flex;
            gap: 30px;
        }

        .equipped-item {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .equipped-label {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
        }

        .equipped-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: #0ff;
        }

        @media (max-width: 900px) {
            .garage-content {
                flex-direction: column;
            }
            .garage-ship-display {
                flex: none;
            }
        }

        .invite-friend-text {
            display: none; /* Hide the text to reduce clutter */
        }

        .invite-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .invite-modal-content {
            background: linear-gradient(145deg, #0a1628 0%, #162447 100%);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 20px;
            padding: 30px 40px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.2),
                        inset 0 0 30px rgba(0, 255, 255, 0.05);
        }

        .invite-modal h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            color: #0ff;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .invite-modal p {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 20px;
        }

        .invite-share-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .invite-share-btn {
            padding: 12px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        .invite-share-btn.twitter {
            background: #1da1f2;
            color: white;
        }

        .invite-share-btn.facebook {
            background: #4267b2;
            color: white;
        }

        .invite-share-btn.whatsapp {
            background: #25d366;
            color: white;
        }

        .invite-share-btn.copy {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .invite-share-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .invite-link-box {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 20px;
            word-break: break-all;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #0ff;
        }

        .invite-close-btn {
            padding: 10px 30px;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .invite-close-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
            color: white;
        }

        /* Install PWA Button */
        .install-pwa-btn {
            padding: 8px 16px;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            font-weight: 600;
            color: #fff;
            background: linear-gradient(135deg, #00d4aa 0%, #00b894 50%, #00d4aa 100%);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 212, 170, 0.3);
        }

        .install-pwa-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 212, 170, 0.5);
        }

        .install-pwa-btn:active {
            transform: translateY(0);
        }

        /* Fullscreen Button */
        .fullscreen-btn {
            padding: 8px 16px;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            font-weight: 600;
            color: #fff;
            background: linear-gradient(135deg, #6c5ce7 0%, #a29bfe 50%, #6c5ce7 100%);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(108, 92, 231, 0.3);
        }

        .fullscreen-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(108, 92, 231, 0.5);
        }

        .fullscreen-btn:active {
            transform: translateY(0);
        }

        .hidden {
            display: none !important;
        }

        /* ========================================
           UI STATE MANAGEMENT - Z-INDEX LAYERS
           ========================================
           Layer 0:    Game canvas (base)
           Layer 10:   HUD (score, lives, level)
           Layer 50:   In-game overlays (powerups, boss health)
           Layer 100:  Screen overlays (start, gameover, pause)
           Layer 200:  Modals (invite, confirm)
           Layer 500:  Garage, Stats screens
           Layer 1000: Tutorial overlay
           Layer 5000: FTUE overlay
           Layer 9000: Screen transitions
           Layer 9999: Splash/Loading screens
        */

        /* HUD should only be visible during gameplay */
        .ui-overlay {
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        body.state-playing .ui-overlay,
        body.state-paused .ui-overlay {
            opacity: 1;
        }

        /* Screen base styles with proper z-index */
        .start-screen {
            z-index: 100;
        }

        /* 3D Starfield effect */
        .starfield-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        .start-screen > *:not(.starfield-canvas):not(.scanlines) {
            position: relative;
            z-index: 1;
        }

        .game-over-screen {
            z-index: 100;
        }

        .pause-screen {
            z-index: 100;
        }

        .tutorial-overlay {
            z-index: 1000;
        }

        .garage-screen {
            z-index: 500 !important;
        }

        .stats-screen {
            z-index: 500 !important;
        }

        .invite-modal {
            z-index: 200 !important;
        }

        .confirm-modal {
            z-index: 250 !important;
        }

        .roguelike-modal {
            z-index: 150 !important;
        }

        .ftue-overlay {
            z-index: 5000 !important;
        }

        .screen-transition-overlay {
            z-index: 9000 !important;
        }

        .splash-screen {
            z-index: 9999 !important;
        }

        .loading-screen {
            z-index: 10000 !important;
        }

        /* Ensure hidden screens don't capture clicks */
        .start-screen.hidden,
        .game-over-screen.hidden,
        .pause-screen.hidden,
        .garage-screen.hidden,
        .stats-screen.hidden,
        .invite-modal.hidden,
        .confirm-modal:not(.active),
        .roguelike-modal.hidden,
        .tutorial-overlay.hidden,
        .demo-overlay.hidden {
            pointer-events: none !important;
            visibility: hidden !important;
        }

        /* Hide in-game elements when on menu */
        body.state-menu .boss-health,
        body.state-menu .powerup-indicator,
        body.state-menu .endless-timer,
        body.state-menu .endless-wave,
        body.state-menu .combo-display,
        body.state-menu .boss-rush-display,
        body.state-menu .mobile-controls {
            display: none !important;
        }

        /* Pilot Profile Card */
        .pilot-profile {
            box-sizing: border-box;
            background: linear-gradient(135deg, rgba(0, 30, 60, 0.98) 0%, rgba(0, 15, 35, 1) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 16px;
            padding: 20px 25px;
            margin-bottom: 15px;
            width: min(420px, 92vw);
            height: auto;
            box-shadow:
                0 8px 30px rgba(0, 0, 0, 0.5),
                0 0 40px rgba(0, 255, 255, 0.15);
            position: relative;
            z-index: 10;
            overflow: hidden;
            line-height: 1.25;
        }

        .pilot-profile::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, transparent, #0ff, #f0f, #0ff, transparent);
            opacity: 0.8;
        }

        .pilot-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .pilot-avatar {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, rgba(0, 200, 255, 0.3) 0%, rgba(255, 0, 255, 0.3) 100%);
            border: 3px solid rgba(0, 255, 255, 0.7);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            flex-shrink: 0;
        }

        @keyframes avatarPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 255, 0.5), 0 0 40px rgba(255, 0, 255, 0.2); }
        }

        .pilot-info {
            flex: 1;
            text-align: left;
        }

        .pilot-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            font-weight: 700;
            color: #0ff;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 6px;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }

        .pilot-rank {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 14px;
            font-weight: 500;
            color: #f0f;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .pilot-rank-badge {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.5) 0%, rgba(255, 100, 200, 0.4) 100%);
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 700;
            border: 1px solid rgba(255, 0, 255, 0.6);
            white-space: nowrap;
        }

        .pilot-input-container {
            position: relative;
        }

        .pilot-input-label {
            display: block;
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 11px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .name-input {
            width: 100%;
            padding: 12px 16px;
            font-size: 18px;
            font-weight: 600;
            background: rgba(0, 0, 0, 0.4);
            color: #fff;
            border: 2px solid rgba(0, 255, 255, 0.4);
            border-radius: 8px;
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            outline: none;
            transition: all 0.3s ease;
            box-sizing: border-box;
        }

        .name-input::placeholder {
            color: rgba(0, 255, 255, 0.3);
            font-weight: 400;
            font-size: 14px;
        }

        .name-input:focus {
            border-color: #0ff;
            background: rgba(0, 20, 40, 0.5);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }

        .pilot-hint {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 8px;
            text-align: center;
        }

        .pilot-stats-mini {
            display: flex;
            justify-content: space-around;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 255, 255, 0.2);
        }

        .pilot-stat-mini {
            text-align: center;
        }

        .pilot-stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 700;
            color: #0ff;
            display: block;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
        }

        .pilot-stat-label {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 10px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .highscore-list {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95) 0%, rgba(0, 10, 25, 0.98) 100%);
            padding: 15px 20px;
            border-radius: 12px;
            border: 2px solid rgba(0, 255, 255, 0.4);
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2), inset 0 2px 15px rgba(0, 0, 0, 0.4);
            width: min(500px, 94vw);
            min-height: 150px;
        }

        .highscore-scroll-wrapper {
            height: 220px;
            overflow: hidden;
            position: relative;
            margin-top: 10px;
            mask-image: linear-gradient(to bottom, transparent 0%, black 10%, black 90%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 10%, black 90%, transparent 100%);
        }

        .highscore-entries {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px 0;
        }

        .highscore-list::-webkit-scrollbar {
            width: 4px;
        }

        .highscore-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 2px;
        }

        .highscore-list::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 255, 0.4);
            border-radius: 3px;
        }

        .highscore-list h3 {
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            margin-bottom: 12px;
            color: #fff;
            font-size: 16px;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8), 0 0 20px rgba(255, 0, 255, 0.5);
            letter-spacing: 2px;
            text-transform: uppercase;
            background: linear-gradient(90deg, rgba(0, 255, 255, 0.2), rgba(255, 0, 255, 0.2));
            padding: 8px 15px;
            border-radius: 6px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .highscore-tabs {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
            justify-content: center;
        }

        .highscore-tab {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #0ff;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-size: 9px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .highscore-tab:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        .highscore-tab.active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(255, 0, 255, 0.3));
            border-color: #f0f;
            color: #fff;
        }

        .highscore-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(0, 50, 80, 0.3);
            border-radius: 6px;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: #fff;
        }

        .highscore-entry:first-child {
            background: rgba(255, 200, 0, 0.15);
            border-left: 3px solid #fc0;
        }

        .highscore-entry:nth-child(2) {
            border-left: 3px solid #c0c0c0;
        }

        .highscore-entry:nth-child(3) {
            border-left: 3px solid #cd7f32;
        }

        .highscore-entry:hover {
            background: rgba(0, 255, 255, 0.1);
        }

        .highscore-entry.current {
            color: #f0f;
            font-weight: 700;
            background: rgba(255, 0, 255, 0.2);
            margin: 0 -10px;
            padding: 12px 14px;
            border-radius: 8px;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }

        .highscore-rank {
            color: #ff0;
            width: 50px;
            font-weight: 700;
            font-size: 28px;
            text-shadow: 0 0 12px rgba(255, 255, 0, 0.7), 0 0 20px rgba(255, 255, 0, 0.4);
        }

        .highscore-name {
            flex: 1;
            margin: 0 20px;
            color: #fff;
            font-size: 26px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5), 0 0 20px rgba(255, 255, 255, 0.2);
        }

        .highscore-score {
            color: #0f0;
            font-weight: 700;
            font-size: 28px;
            text-shadow: 0 0 12px rgba(0, 255, 0, 0.7), 0 0 20px rgba(0, 255, 0, 0.4);
        }

        .new-highscore {
            font-family: 'Orbitron', sans-serif;
            color: #f0f;
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 12px;
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
            animation: newHighscorePulse 1s ease-in-out infinite;
        }

        @keyframes newHighscorePulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        /* Pause screen */
        .pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 5, 15, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: #0ff;
            border-radius: 10px;
            z-index: 100;
        }

        .pause-container {
            background: linear-gradient(180deg, rgba(0, 30, 60, 0.8) 0%, rgba(0, 15, 30, 0.9) 100%);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 20px;
            padding: 40px 50px;
            min-width: 350px;
            max-width: 450px;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.2), inset 0 0 30px rgba(0, 0, 0, 0.5);
        }

        .pause-screen h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 36px;
            font-weight: 800;
            margin-bottom: 30px;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
            letter-spacing: 6px;
            text-align: center;
        }

        .pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 25px;
        }

        .pause-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            font-weight: 600;
            padding: 14px 20px;
            border: 2px solid rgba(0, 255, 255, 0.4);
            border-radius: 10px;
            background: linear-gradient(180deg, rgba(0, 100, 150, 0.3) 0%, rgba(0, 50, 100, 0.4) 100%);
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .pause-btn:hover {
            background: linear-gradient(180deg, rgba(0, 150, 200, 0.5) 0%, rgba(0, 100, 150, 0.6) 100%);
            border-color: #0ff;
            transform: scale(1.02);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .pause-btn.primary {
            background: linear-gradient(180deg, rgba(0, 200, 100, 0.4) 0%, rgba(0, 150, 80, 0.5) 100%);
            border-color: rgba(0, 255, 150, 0.5);
        }

        .pause-btn.primary:hover {
            background: linear-gradient(180deg, rgba(0, 255, 100, 0.5) 0%, rgba(0, 200, 100, 0.6) 100%);
            border-color: #0f8;
            box-shadow: 0 0 20px rgba(0, 255, 150, 0.3);
        }

        .pause-btn.danger {
            background: linear-gradient(180deg, rgba(150, 50, 50, 0.4) 0%, rgba(100, 30, 30, 0.5) 100%);
            border-color: rgba(255, 100, 100, 0.4);
        }

        .pause-btn.danger:hover {
            background: linear-gradient(180deg, rgba(200, 50, 50, 0.5) 0%, rgba(150, 30, 30, 0.6) 100%);
            border-color: #f66;
            box-shadow: 0 0 20px rgba(255, 100, 100, 0.3);
        }

        .pause-settings {
            border-top: 1px solid rgba(0, 255, 255, 0.2);
            padding-top: 20px;
            margin-bottom: 20px;
        }

        .pause-settings h3 {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: rgba(0, 255, 255, 0.7);
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .volume-label {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            min-width: 70px;
        }

        .volume-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            border-radius: 4px;
            background: rgba(0, 50, 100, 0.5);
            outline: none;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(180deg, #0ff, #08f);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transition: transform 0.1s ease;
        }

        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .volume-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(180deg, #0ff, #08f);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .volume-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: #0ff;
            min-width: 35px;
            text-align: right;
        }

        .pause-controls-ref {
            border-top: 1px solid rgba(0, 255, 255, 0.2);
            padding-top: 15px;
        }

        .pause-controls-ref h3 {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: rgba(0, 255, 255, 0.6);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px 15px;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 12px;
        }

        .control-key {
            color: #0ff;
            font-weight: 600;
        }

        .control-action {
            color: rgba(255, 255, 255, 0.5);
        }

        @media (max-width: 600px) {
            .pause-container {
                padding: 25px 20px;
                min-width: 280px;
                margin: 0 15px;
            }
            .pause-screen h2 {
                font-size: 24px;
            }
            .pause-btn {
                font-size: 14px;
                padding: 12px 15px;
            }
            .controls-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Screen Transitions */
        .screen-transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center, #0a0a2a 0%, #000 70%);
            z-index: 9998;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .screen-transition-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .screen-transition-overlay .transition-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .screen-transition-overlay .transition-icon {
            font-size: 60px;
            animation: transitionPulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes transitionPulse {
            0% { transform: scale(1); opacity: 0.7; }
            100% { transform: scale(1.1); opacity: 1; }
        }

        .screen-transition-overlay .transition-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            color: #0ff;
            margin-top: 15px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        /* Fade transition classes for screens */
        .fade-transition {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .fade-out {
            opacity: 0;
            transform: scale(0.98);
        }

        .fade-in {
            opacity: 1;
            transform: scale(1);
        }

        .slide-up {
            animation: slideUpIn 0.4s ease forwards;
        }

        .slide-down {
            animation: slideDownOut 0.3s ease forwards;
        }

        @keyframes slideUpIn {
            0% {
                opacity: 0;
                transform: translateY(30px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideDownOut {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(30px);
            }
        }

        /* UI Particles System */
        .ui-particles-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            pointer-events: none;
            z-index: 1;
        }

        .ui-particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            animation: floatParticle 8s ease-in-out infinite;
        }

        @keyframes floatParticle {
            0%, 100% {
                transform: translateY(0) translateX(0) scale(1);
                opacity: 0.3;
            }
            25% {
                transform: translateY(-20px) translateX(10px) scale(1.2);
                opacity: 0.6;
            }
            50% {
                transform: translateY(-10px) translateX(-10px) scale(0.8);
                opacity: 0.4;
            }
            75% {
                transform: translateY(-30px) translateX(5px) scale(1.1);
                opacity: 0.5;
            }
        }

        /* Button sparkle effect */
        .sparkle-btn {
            position: relative;
            overflow: hidden;
        }

        .sparkle-btn::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent 40%,
                rgba(255, 255, 255, 0.1) 45%,
                rgba(255, 255, 255, 0.3) 50%,
                rgba(255, 255, 255, 0.1) 55%,
                transparent 60%
            );
            transform: translateX(-100%) rotate(45deg);
            transition: none;
            pointer-events: none;
        }

        .sparkle-btn:hover::after {
            animation: sparkleShine 0.6s ease forwards;
        }

        @keyframes sparkleShine {
            0% {
                transform: translateX(-100%) rotate(45deg);
            }
            100% {
                transform: translateX(100%) rotate(45deg);
            }
        }

        /* Glowing border effect */
        .glow-border {
            position: relative;
        }

        .glow-border::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #0ff, #f0f, #ff0, #0f0, #0ff);
            background-size: 400% 400%;
            border-radius: inherit;
            z-index: -1;
            opacity: 0;
            animation: glowRotate 3s linear infinite;
            transition: opacity 0.3s ease;
        }

        .glow-border:hover::before {
            opacity: 0.7;
        }

        @keyframes glowRotate {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Floating dots background */
        .floating-dots {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            pointer-events: none;
        }

        .floating-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(0, 255, 255, 0.3);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        /* Achievement unlock particles */
        .achievement-particle {
            position: fixed;
            font-size: 20px;
            pointer-events: none;
            z-index: 10000;
            animation: achievementBurst 1s ease-out forwards;
        }

        @keyframes achievementBurst {
            0% {
                opacity: 1;
                transform: scale(1) translate(0, 0);
            }
            100% {
                opacity: 0;
                transform: scale(0.5) translate(var(--tx), var(--ty));
            }
        }

        /* Cosmic dust effect for screens */
        .cosmic-dust {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            overflow: hidden;
        }

        .dust-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            opacity: 0;
            animation: dustFloat 10s linear infinite;
        }

        @keyframes dustFloat {
            0% {
                opacity: 0;
                transform: translateY(100%) translateX(0);
            }
            10% {
                opacity: 0.5;
            }
            90% {
                opacity: 0.5;
            }
            100% {
                opacity: 0;
                transform: translateY(-100%) translateX(50px);
            }
        }

        /* Level Up Screen Flash */
        .level-up-flash {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 9999;
            animation: levelFlash 0.6s ease-out forwards;
        }

        @keyframes levelFlash {
            0% {
                background: radial-gradient(circle at center, rgba(255, 255, 255, 0.9), rgba(0, 255, 255, 0.7), transparent 70%);
            }
            20% {
                background: radial-gradient(circle at center, rgba(0, 255, 255, 0.8), rgba(255, 0, 255, 0.5), transparent 80%);
            }
            40% {
                background: radial-gradient(circle at center, rgba(255, 0, 255, 0.6), rgba(0, 200, 255, 0.4), transparent 85%);
            }
            100% {
                background: transparent;
            }
        }

        /* AI Demo overlay */
        .demo-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            pointer-events: none;
        }

        .demo-banner {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 12px 30px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.15) 0%, rgba(0, 200, 100, 0.1) 100%);
            border-bottom: 2px solid rgba(0, 255, 136, 0.5);
            backdrop-filter: blur(10px);
            animation: demoPulse 2s ease-in-out infinite;
        }

        @keyframes demoPulse {
            0%, 100% { border-bottom-color: rgba(0, 255, 136, 0.5); }
            50% { border-bottom-color: rgba(0, 255, 136, 0.9); }
        }

        .demo-icon {
            font-size: 24px;
            animation: robotBounce 1s ease-in-out infinite;
        }

        @keyframes robotBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .demo-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 700;
            color: #0f8;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            letter-spacing: 3px;
        }

        .demo-hint {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            animation: hintBlink 1.5s ease-in-out infinite;
        }

        @keyframes hintBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Game controls overlay */
        .game-controls {
            display: flex;
            gap: 3px;
        }

        .control-btn {
            width: 26px;
            height: 26px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .control-btn.muted {
            opacity: 0.4;
        }

        /* Mobile controls */
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: none;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 20px;
            z-index: 50;
            pointer-events: none;
        }

        .mobile-controls > * {
            pointer-events: auto;
        }

        /* Virtual Joystick */
        .joystick-container {
            position: relative;
            width: 130px;
            height: 130px;
        }

        .joystick-base {
            position: absolute;
            width: 130px;
            height: 130px;
            background: radial-gradient(circle at 30% 30%, rgba(0, 40, 60, 0.9) 0%, rgba(0, 20, 40, 0.85) 100%);
            border: 3px solid rgba(0, 255, 255, 0.4);
            border-radius: 50%;
            box-shadow:
                0 0 20px rgba(0, 255, 255, 0.2),
                inset 0 0 30px rgba(0, 0, 0, 0.5),
                inset 0 -5px 15px rgba(0, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .joystick-base::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            border: 2px dashed rgba(0, 255, 255, 0.2);
            border-radius: 50%;
        }

        .joystick-base::after {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border: 1px solid rgba(0, 255, 255, 0.15);
            border-radius: 50%;
        }

        .joystick-stick {
            position: absolute;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at 35% 35%, rgba(0, 255, 255, 0.9) 0%, rgba(0, 180, 200, 0.8) 50%, rgba(0, 100, 120, 0.9) 100%);
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow:
                0 4px 15px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(0, 255, 255, 0.4),
                inset 0 -3px 10px rgba(0, 0, 0, 0.3),
                inset 0 3px 10px rgba(255, 255, 255, 0.2);
            transition: box-shadow 0.1s ease;
            z-index: 2;
        }

        .joystick-stick.active {
            box-shadow:
                0 2px 10px rgba(0, 0, 0, 0.5),
                0 0 30px rgba(0, 255, 255, 0.6),
                inset 0 -3px 10px rgba(0, 0, 0, 0.3),
                inset 0 3px 10px rgba(255, 255, 255, 0.3);
        }

        .joystick-directions {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .joystick-arrow {
            position: absolute;
            font-size: 14px;
            color: rgba(0, 255, 255, 0.3);
            transition: color 0.1s ease, transform 0.1s ease;
        }

        .joystick-arrow.up { top: 8px; left: 50%; transform: translateX(-50%); }
        .joystick-arrow.down { bottom: 8px; left: 50%; transform: translateX(-50%); }
        .joystick-arrow.left { left: 8px; top: 50%; transform: translateY(-50%); }
        .joystick-arrow.right { right: 8px; top: 50%; transform: translateY(-50%); }

        .joystick-arrow.active {
            color: rgba(0, 255, 255, 0.9);
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        /* Fire buttons container */
        .fire-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
        }

        .mobile-btn {
            width: 75px;
            height: 75px;
            background: radial-gradient(circle at 30% 30%, rgba(0, 40, 60, 0.9) 0%, rgba(0, 20, 40, 0.85) 100%);
            border: 3px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            color: #0ff;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: all 0.1s ease;
            box-shadow:
                0 4px 15px rgba(0, 0, 0, 0.4),
                0 0 20px rgba(0, 255, 255, 0.15),
                inset 0 -4px 10px rgba(0, 0, 0, 0.3),
                inset 0 2px 10px rgba(255, 255, 255, 0.05);
            position: relative;
            overflow: hidden;
        }

        .mobile-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.15) 0%, transparent 100%);
            border-radius: 50% 50% 0 0;
            pointer-events: none;
        }

        .mobile-btn:active, .mobile-btn.active {
            background: radial-gradient(circle at 50% 50%, rgba(0, 255, 255, 0.5) 0%, rgba(0, 100, 120, 0.7) 100%);
            transform: scale(0.92);
            border-color: #0ff;
            box-shadow:
                0 2px 10px rgba(0, 0, 0, 0.4),
                0 0 30px rgba(0, 255, 255, 0.5),
                inset 0 0 20px rgba(0, 255, 255, 0.3);
        }

        /* Fire button specific */
        #fireBtn {
            width: 90px;
            height: 90px;
            font-size: 32px;
            border-color: rgba(255, 100, 50, 0.6);
            background: radial-gradient(circle at 30% 30%, rgba(60, 30, 20, 0.9) 0%, rgba(40, 15, 10, 0.85) 100%);
            box-shadow:
                0 4px 15px rgba(0, 0, 0, 0.4),
                0 0 20px rgba(255, 100, 50, 0.2),
                inset 0 -4px 10px rgba(0, 0, 0, 0.3);
        }

        #fireBtn:active, #fireBtn.active {
            background: radial-gradient(circle at 50% 50%, rgba(255, 100, 50, 0.6) 0%, rgba(150, 50, 30, 0.8) 100%);
            border-color: #f84;
            box-shadow:
                0 2px 10px rgba(0, 0, 0, 0.4),
                0 0 35px rgba(255, 100, 50, 0.6),
                inset 0 0 25px rgba(255, 100, 50, 0.3);
        }

        /* Auto-fire toggle */
        #autoFireBtn {
            width: 50px;
            height: 50px;
            font-size: 16px;
            border-color: rgba(0, 255, 100, 0.5);
        }

        #autoFireBtn.active {
            background: radial-gradient(circle at 50% 50%, rgba(0, 255, 100, 0.5) 0%, rgba(0, 150, 60, 0.7) 100%);
            border-color: #0f8;
            box-shadow:
                0 0 25px rgba(0, 255, 100, 0.5),
                inset 0 0 15px rgba(0, 255, 100, 0.3);
            animation: autoFirePulse 1s ease-in-out infinite;
        }

        @keyframes autoFirePulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 100, 0.4); }
            50% { box-shadow: 0 0 35px rgba(0, 255, 100, 0.7); }
        }

        /* Touch hint overlay */
        .touch-hint {
            position: absolute;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            padding: 8px 16px;
            color: rgba(0, 255, 255, 0.8);
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 12px;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 51;
        }

        .touch-hint.visible {
            opacity: 1;
        }

        .mobile-move-btns {
            display: flex;
            gap: 12px;
        }

        /* Power-up indicator - positioned at top-right */
        .powerup-indicator {
            position: absolute;
            top: 10px;
            right: 12px;
            background: linear-gradient(135deg, rgba(0, 40, 20, 0.92) 0%, rgba(0, 20, 40, 0.92) 100%);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 8px 14px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 0, 0.5);
            color: #0f0;
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 13px;
            font-weight: 600;
            z-index: 45;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.2), 0 4px 15px rgba(0, 0, 0, 0.3);
            max-width: 160px;
            text-align: center;
        }

        .powerup-indicator::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 8px;
            background: linear-gradient(180deg, rgba(0, 255, 0, 0.1) 0%, transparent 50%);
            pointer-events: none;
        }

        /* Boss health bar - compact, professional */
        .boss-health {
            position: absolute;
            top: 48px;
            left: 50%;
            transform: translateX(-50%);
            width: 280px;
            max-width: 70%;
            z-index: 50;
            text-align: center;
            animation: bossHealthSlideIn 0.3s ease-out;
        }

        @keyframes bossHealthSlideIn {
            from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        .boss-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            font-weight: 600;
            color: #ff4444;
            text-shadow: 0 0 8px rgba(255, 68, 68, 0.6);
            margin-bottom: 4px;
            letter-spacing: 2px;
        }

        .boss-health-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 68, 68, 0.4);
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(255, 68, 68, 0.2);
            position: relative;
        }

        .boss-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000 0%, #ff4400 50%, #ff8800 100%);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 100, 0, 0.5);
            position: relative;
        }

        .boss-health-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.3) 0%, transparent 100%);
        }

        .boss-health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            font-weight: 700;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
            letter-spacing: 2px;
        }

        /* Combo indicator - positioned below boss bar area */
        .combo-display {
            position: absolute;
            top: 95px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0;
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            font-weight: 700;
            text-shadow:
                0 0 10px rgba(255, 255, 0, 0.8),
                0 0 20px rgba(255, 200, 0, 0.6),
                0 0 30px rgba(255, 136, 0, 0.4);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            z-index: 45;
            background: rgba(0, 0, 0, 0.5);
            padding: 6px 16px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 0, 0.4);
        }

        .combo-display.active {
            opacity: 1;
            animation: comboPulse 0.3s ease-out;
        }

        @keyframes comboPulse {
            0% { transform: translateX(-50%) scale(1.4); }
            100% { transform: translateX(-50%) scale(1); }
        }

        /* Achievement popup - compact notification style */
        .achievement-popup {
            position: absolute;
            top: -80px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 280px;
            width: calc(100% - 40px);
            background: linear-gradient(135deg, rgba(20, 25, 35, 0.95) 0%, rgba(35, 40, 25, 0.95) 100%);
            border: 1px solid rgba(255, 215, 0, 0.5);
            border-radius: 10px;
            padding: 10px 14px;
            color: #fff;
            z-index: 200;
            transition: top 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow:
                0 0 20px rgba(255, 215, 0, 0.3),
                0 8px 20px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .achievement-popup.show {
            top: 55px;
        }

        .achievement-popup h4 {
            display: none;
        }

        .achievement-popup .achievement-name {
            font-family: 'Orbitron', sans-serif;
            color: #ffd700;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.5px;
            margin-bottom: 2px;
        }

        .achievement-popup .achievement-desc {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            font-weight: 500;
            line-height: 1.3;
        }

        .achievement-popup .achievement-icon {
            font-size: 28px;
            filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.4));
            flex-shrink: 0;
        }

        /* Achievement detail modal */
        .achievement-detail-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }

        .achievement-detail-modal {
            background: linear-gradient(135deg, rgba(10, 20, 40, 0.98) 0%, rgba(5, 10, 25, 0.98) 100%);
            border: 3px solid rgba(255, 215, 0, 0.5);
            border-radius: 20px;
            padding: 30px 40px;
            max-width: 450px;
            width: 90%;
            text-align: center;
            position: relative;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.3), inset 0 0 30px rgba(0, 0, 0, 0.5);
            animation: modalAppear 0.3s ease-out;
        }

        @keyframes modalAppear {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .achievement-detail-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            transition: color 0.2s;
        }

        .achievement-detail-close:hover {
            color: #fff;
        }

        .achievement-detail-icon {
            font-size: 64px;
            margin-bottom: 15px;
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.6));
        }

        .achievement-detail-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            color: #ffd700;
            margin-bottom: 8px;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .achievement-detail-rarity {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 12px;
            font-weight: 700;
            padding: 4px 15px;
            border-radius: 12px;
            display: inline-block;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .achievement-detail-rarity.common { background: rgba(150, 150, 150, 0.3); color: #aaa; }
        .achievement-detail-rarity.rare { background: rgba(0, 150, 255, 0.3); color: #0af; }
        .achievement-detail-rarity.epic { background: rgba(150, 0, 255, 0.3); color: #a0f; }
        .achievement-detail-rarity.legendary { background: rgba(255, 150, 0, 0.3); color: #fa0; }

        .achievement-detail-desc {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 18px;
            color: #0ff;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .achievement-detail-long {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .achievement-detail-tip {
            background: rgba(0, 100, 150, 0.2);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 12px 15px;
            margin-bottom: 15px;
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.9);
        }

        .achievement-detail-tip .tip-label {
            color: #0ff;
            font-weight: 700;
            margin-right: 5px;
        }

        .achievement-detail-reward {
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            color: #fc0;
            margin-bottom: 15px;
        }

        .achievement-detail-status {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            padding: 8px 20px;
            border-radius: 20px;
            display: inline-block;
        }

        .achievement-detail-status.unlocked {
            background: rgba(0, 255, 100, 0.2);
            color: #0f8;
            border: 1px solid rgba(0, 255, 100, 0.4);
        }

        .achievement-detail-status.locked {
            background: rgba(100, 100, 100, 0.2);
            color: #888;
            border: 1px solid rgba(100, 100, 100, 0.4);
        }

        /* Daily Challenges */
        .daily-challenge-panel {
            background: linear-gradient(180deg, rgba(50, 20, 80, 0.95) 0%, rgba(30, 10, 50, 0.98) 100%);
            border: 2px solid rgba(200, 100, 255, 0.4);
            border-radius: 12px;
            padding: 12px 16px;
            margin: 10px 0;
            width: min(420px, 92vw);
            position: relative;
            z-index: 5;
        }

        .daily-challenge-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .daily-challenge-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            color: #f0f;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .daily-challenge-timer {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
        }

        .daily-challenge-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .daily-challenge-icon {
            font-size: 28px;
            flex-shrink: 0;
        }

        .daily-challenge-info {
            flex: 1;
        }

        .daily-challenge-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: #fff;
            margin-bottom: 3px;
        }

        .daily-challenge-desc {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 6px;
        }

        .daily-challenge-progress {
            height: 6px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .daily-challenge-bar {
            height: 100%;
            background: linear-gradient(90deg, #a0f, #f0f);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .daily-challenge-progress-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: #f0f;
            margin-top: 4px;
            text-align: right;
        }

        .daily-challenge-reward {
            display: flex;
            align-items: center;
            gap: 4px;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: #fc0;
            margin-top: 6px;
        }

        .daily-challenge-complete {
            background: linear-gradient(180deg, rgba(0, 150, 80, 0.8) 0%, rgba(0, 100, 50, 0.9) 100%);
            border-color: rgba(0, 255, 100, 0.5);
        }

        .daily-challenge-complete .daily-challenge-title {
            color: #0f8;
        }

        .daily-challenge-complete .daily-challenge-bar {
            background: linear-gradient(90deg, #0f8, #0ff);
        }

        /* Statistics Screen */
        .stats-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center, #0a0a2a 0%, #000 70%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1500;
            padding: 20px;
            overflow-y: auto;
        }

        .stats-container {
            background: linear-gradient(180deg, rgba(0, 40, 80, 0.8) 0%, rgba(0, 20, 50, 0.9) 100%);
            border: 2px solid rgba(0, 200, 255, 0.4);
            border-radius: 20px;
            padding: 30px 40px;
            max-width: 500px;
            width: 95%;
            max-height: 85vh;
            overflow-y: auto;
        }

        .stats-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
        }

        .stats-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            color: #0ff;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .stats-close-btn {
            background: rgba(255, 100, 100, 0.2);
            border: 2px solid rgba(255, 100, 100, 0.4);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
            color: #f88;
            transition: all 0.2s ease;
        }

        .stats-close-btn:hover {
            background: rgba(255, 100, 100, 0.4);
            transform: scale(1.1);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .stat-card {
            background: rgba(0, 50, 100, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .stat-card:hover {
            background: rgba(0, 80, 150, 0.4);
            border-color: rgba(0, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        .stat-card.highlight {
            background: linear-gradient(180deg, rgba(255, 200, 0, 0.2) 0%, rgba(200, 150, 0, 0.15) 100%);
            border-color: rgba(255, 200, 0, 0.4);
        }

        .stat-icon {
            font-size: 28px;
            margin-bottom: 8px;
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 22px;
            color: #fff;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .stat-label {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stats-section-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: rgba(0, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 20px 0 15px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
        }

        .stats-footer {
            margin-top: 20px;
            text-align: center;
        }

        .stats-reset-btn {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 12px;
            color: rgba(255, 100, 100, 0.7);
            background: none;
            border: 1px solid rgba(255, 100, 100, 0.3);
            border-radius: 5px;
            padding: 8px 15px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .stats-reset-btn:hover {
            color: #f88;
            border-color: rgba(255, 100, 100, 0.6);
            background: rgba(255, 100, 100, 0.1);
        }

        /* Utility buttons - now in a toolbar at the top of start-screen */
        .menu-utility-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 10px 15px;
            position: sticky;
            top: 0;
            background: rgba(0, 5, 15, 0.95);
            z-index: 20;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            margin-bottom: 10px;
        }

        .menu-utility-left,
        .menu-utility-right {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .menu-music-btn {
            background: rgba(0, 50, 80, 0.5);
            border: 1px solid rgba(0, 200, 255, 0.4);
            border-radius: 6px;
            padding: 6px 10px;
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            color: #0ff;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .menu-music-btn:hover {
            background: rgba(0, 80, 120, 0.6);
            border-color: #0ff;
        }

        .menu-music-btn.muted {
            color: rgba(255, 100, 100, 0.8);
            border-color: rgba(255, 100, 100, 0.4);
        }

        .ghost-race-btn {
            background: rgba(60, 60, 100, 0.5);
            border: 1px solid rgba(150, 150, 255, 0.4);
            border-radius: 6px;
            padding: 6px 10px;
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            color: #aaf;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: center;
        }

        .ghost-race-btn:hover {
            background: rgba(100, 100, 150, 0.6);
            border-color: #aaf;
        }

        .ghost-race-btn.active {
            background: rgba(0, 100, 60, 0.5);
            border-color: rgba(0, 255, 150, 0.6);
            color: #0f0;
        }

        .ghost-race-btn small {
            display: none;
        }

        .stats-btn {
            background: rgba(0, 50, 80, 0.5);
            border: 1px solid rgba(0, 200, 255, 0.4);
            border-radius: 6px;
            padding: 6px 10px;
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            color: #0ff;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stats-btn:hover {
            background: rgba(0, 80, 120, 0.6);
            border-color: #0ff;
        }

        @media (max-width: 500px) {
            .stats-container {
                padding: 20px 15px;
            }
            .stats-grid {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            .stat-card {
                padding: 10px;
            }
            .stat-value {
                font-size: 18px;
            }
            .stat-icon {
                font-size: 22px;
            }
        }

        /* Achievement list on game over */
        .achievements-section {
            margin-top: 18px;
            text-align: center;
            width: 280px;
            max-width: 90%;
        }

        .achievements-section h4 {
            font-family: 'Orbitron', sans-serif;
            color: #ff0;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 12px;
            text-shadow: 0 0 10px rgba(255, 255, 0, 0.4);
        }

        .achievement-badges {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin: 0 auto;
        }

        .achievement-badge {
            width: 42px;
            height: 42px;
            background: rgba(20, 25, 40, 0.8);
            border: 2px solid rgba(80, 80, 100, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            opacity: 0.3;
            cursor: help;
            transition: all 0.2s ease;
        }

        .achievement-badge.unlocked {
            opacity: 1;
            border-color: rgba(255, 255, 0, 0.6);
            background: rgba(50, 50, 20, 0.6);
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.3);
        }

        .achievement-badge:hover {
            transform: scale(1.1);
        }

        /* Weapon selector */
        .weapon-selector {
            display: flex;
            gap: 4px;
        }

        .weapon-btn {
            width: 36px;
            height: 36px;
            background: rgba(0, 15, 30, 0.85);
            border: 1px solid rgba(100, 100, 120, 0.3);
            border-radius: 8px;
            color: rgba(150, 150, 170, 0.7);
            font-size: 10px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .weapon-btn:hover {
            background: rgba(0, 30, 60, 0.9);
            border-color: rgba(0, 255, 255, 0.3);
        }

        .weapon-btn.active {
            border-color: rgba(0, 255, 255, 0.6);
            color: #0ff;
            background: rgba(0, 40, 60, 0.9);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .weapon-btn .weapon-icon {
            font-size: 14px;
            line-height: 1;
        }

        .weapon-btn .weapon-key {
            font-family: 'Orbitron', sans-serif;
            font-size: 8px;
            font-weight: 600;
            opacity: 0.6;
        }

        /* Bottom toolbar */
        .bottom-toolbar {
            position: absolute;
            bottom: 12px;
            left: 12px;
            right: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 60;
            pointer-events: none;
        }

        .toolbar-center {
            display: flex;
            align-items: center;
            gap: 4px;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.4);
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .toolbar-divider {
            width: 1px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            margin: 0 2px;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 2px;
        }

        /* Toolbar buttons - minimal style */
        .toolbar-btn {
            padding: 4px 10px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            color: rgba(255, 255, 255, 0.7);
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            white-space: nowrap;
        }

        .toolbar-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .toolbar-btn.shop {
            color: #ffd93d;
            border-color: rgba(255, 217, 61, 0.25);
        }

        .toolbar-btn.shop:hover {
            background: rgba(255, 217, 61, 0.15);
            border-color: rgba(255, 217, 61, 0.4);
        }

        .toolbar-btn.share {
            color: #6bcf6b;
            border-color: rgba(107, 207, 107, 0.25);
        }

        .toolbar-btn.share:hover {
            background: rgba(107, 207, 107, 0.15);
            border-color: rgba(107, 207, 107, 0.4);
        }

        .coins-display {
            color: #ffd93d;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            font-weight: 500;
            padding: 4px 8px;
            white-space: nowrap;
        }

        /* Icon buttons */
        .icon-btn {
            width: 26px;
            height: 26px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .icon-btn.muted {
            opacity: 0.4;
        }

        /* Shop button */
        .shop-btn {
            padding: 4px 10px;
            background: transparent;
            border: 1px solid rgba(255, 217, 61, 0.25);
            border-radius: 4px;
            color: #ffd93d;
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .shop-btn:hover {
            background: rgba(255, 255, 0, 0.15);
            border-color: rgba(255, 255, 0, 0.6);
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.2);
        }

        .shop-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            background: linear-gradient(135deg, rgba(10, 20, 40, 0.98) 0%, rgba(5, 10, 25, 0.99) 100%);
            border: 1px solid rgba(255, 255, 0, 0.3);
            border-radius: 16px;
            padding: 24px;
            color: #fff;
            z-index: 200;
            min-width: 360px;
            max-width: 450px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow:
                0 0 40px rgba(255, 255, 0, 0.15),
                0 25px 50px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        .shop-panel h2 {
            font-family: 'Orbitron', sans-serif;
            color: #ff0;
            text-align: center;
            margin-bottom: 15px;
            font-size: 20px;
            font-weight: 700;
            text-shadow: 0 0 15px rgba(255, 255, 0, 0.4);
            flex-shrink: 0;
        }

        .shop-close {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 10;
        }

        #shopItems {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
            max-height: calc(85vh - 100px);
            padding-right: 10px;
        }

        #shopItems::-webkit-scrollbar {
            width: 6px;
        }

        #shopItems::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }

        #shopItems::-webkit-scrollbar-thumb {
            background: rgba(255, 217, 61, 0.5);
            border-radius: 3px;
        }

        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 16px;
            margin: 8px 0;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            transition: all 0.2s ease;
        }

        .shop-item:hover {
            background: rgba(255, 255, 0, 0.05);
            border-color: rgba(255, 255, 0, 0.2);
        }

        .shop-item.owned {
            border-color: rgba(0, 255, 0, 0.4);
            background: rgba(0, 255, 0, 0.05);
            opacity: 0.75;
        }

        .shop-item-info {
            flex: 1;
        }

        .shop-item-name {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: #0ff;
            font-weight: 700;
            font-size: 15px;
        }

        .shop-item-desc {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 13px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 2px;
        }

        .shop-item-btn {
            padding: 8px 18px;
            background: linear-gradient(135deg, #ff0 0%, #cc0 100%);
            border: none;
            border-radius: 6px;
            color: #000;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .shop-item-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.4);
        }

        .shop-item-btn:disabled {
            background: rgba(80, 80, 100, 0.6);
            color: rgba(150, 150, 170, 0.7);
            cursor: not-allowed;
        }

        /* Shop tabs */
        .shop-tabs {
            display: flex;
            gap: 6px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .shop-tab {
            padding: 8px 20px;
            background: rgba(40, 50, 80, 0.5);
            border: 1px solid rgba(100, 100, 150, 0.3);
            border-radius: 8px;
            color: rgba(200, 200, 220, 0.7);
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .shop-tab:hover {
            background: rgba(60, 70, 100, 0.6);
            color: rgba(220, 220, 240, 0.9);
        }

        .shop-tab.active {
            background: linear-gradient(135deg, rgba(255, 255, 0, 0.2) 0%, rgba(255, 200, 0, 0.15) 100%);
            border-color: rgba(255, 255, 0, 0.5);
            color: #ff0;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.2);
        }

        /* Skin cards */
        .skins-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            max-height: 280px;
            overflow-y: auto;
            padding-right: 5px;
        }

        .skins-grid::-webkit-scrollbar {
            width: 5px;
        }

        .skins-grid::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }

        .skins-grid::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 0, 0.4);
            border-radius: 3px;
        }

        .skin-card {
            background: rgba(20, 30, 50, 0.8);
            border: 2px solid rgba(80, 80, 120, 0.3);
            border-radius: 12px;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .skin-card:hover {
            background: rgba(30, 45, 70, 0.9);
            border-color: rgba(0, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        .skin-card.selected {
            border-color: rgba(0, 255, 0, 0.8);
            background: rgba(0, 255, 0, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .skin-card.locked {
            opacity: 0.6;
        }

        .skin-preview {
            width: 60px;
            height: 50px;
            margin: 0 auto 8px;
            position: relative;
        }

        .skin-preview canvas {
            width: 100%;
            height: 100%;
        }

        .trail-preview {
            width: 50px;
            height: 50px;
            margin: 0 auto 8px;
            border-radius: 50%;
            box-shadow: 0 0 15px currentColor;
            animation: trailPulse 1.5s ease-in-out infinite;
        }

        @keyframes trailPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        .trail-desc {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 4px;
        }

        .skin-name {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 13px;
            font-weight: 700;
            color: #0ff;
            margin-bottom: 4px;
        }

        .skin-price {
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            font-weight: 600;
            color: #ff0;
        }

        .skin-price.owned {
            color: #0f0;
        }

        .skin-rarity {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 10px;
            font-weight: 600;
            margin-top: 4px;
            padding: 2px 8px;
            border-radius: 4px;
            display: inline-block;
        }

        .skin-rarity.common {
            background: rgba(100, 100, 100, 0.3);
            color: #aaa;
        }

        .skin-rarity.rare {
            background: rgba(0, 150, 255, 0.2);
            color: #0af;
        }

        .skin-rarity.epic {
            background: rgba(150, 0, 255, 0.2);
            color: #a0f;
        }

        .skin-rarity.legendary {
            background: rgba(255, 200, 0, 0.2);
            color: #fc0;
        }

        /* Weapon upgrade cards */
        .weapon-upgrade-card {
            background: rgba(20, 30, 50, 0.9);
            border: 2px solid rgba(80, 80, 120, 0.4);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            transition: all 0.2s ease;
        }

        .weapon-upgrade-card:hover {
            border-color: rgba(0, 255, 255, 0.5);
            background: rgba(25, 40, 65, 0.95);
        }

        .weapon-preview-container {
            display: flex;
            justify-content: center;
            margin-bottom: 12px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 8px;
            border: 1px solid rgba(0, 255, 255, 0.2);
        }

        .weapon-preview-container canvas {
            border-radius: 4px;
        }

        .weapon-desc {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            margin-bottom: 6px;
        }

        .weapon-stats {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 11px;
            color: #0ff;
            text-align: center;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }

        .weapon-upgrade-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .weapon-icon {
            font-size: 24px;
        }

        .weapon-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            flex-grow: 1;
        }

        .weapon-level {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: 600;
            color: #0ff;
            background: rgba(0, 255, 255, 0.1);
            padding: 4px 10px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .weapon-progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .weapon-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #0ff 0%, #0af 50%, #0ff 100%);
            border-radius: 4px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .weapon-upgrade-info {
            text-align: center;
            margin-bottom: 10px;
            min-height: 20px;
        }

        .weapon-next-upgrade {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
        }

        .weapon-maxed {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: 600;
            color: #fc0;
            text-shadow: 0 0 10px rgba(255, 200, 0, 0.5);
        }

        .weapon-upgrade-btn {
            width: 100%;
            padding: 10px;
            font-family: 'Orbitron', sans-serif;
            font-size: 13px;
            font-weight: 600;
            color: #000;
            background: linear-gradient(135deg, #0ff 0%, #0af 100%);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .weapon-upgrade-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #5ff 0%, #0cf 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.4);
        }

        .weapon-upgrade-btn:disabled {
            background: rgba(100, 100, 100, 0.4);
            color: rgba(255, 255, 255, 0.4);
            cursor: not-allowed;
        }

        .shop-close, .settings-close {
            position: absolute;
            top: 14px;
            right: 14px;
            width: 30px;
            height: 30px;
            background: rgba(255, 50, 50, 0.1);
            border: 1px solid rgba(255, 50, 50, 0.3);
            border-radius: 6px;
            color: #f55;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .shop-close:hover, .settings-close:hover {
            background: rgba(255, 50, 50, 0.2);
            border-color: rgba(255, 50, 50, 0.6);
            transform: scale(1.1);
        }

        /* Settings button */
        .settings-btn {
            width: 26px;
            height: 26px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .settings-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        /* Share button */
        .share-btn {
            width: 26px;
            height: 26px;
            background: transparent;
            border: 1px solid rgba(107, 207, 107, 0.25);
            border-radius: 4px;
            color: #6bcf6b;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .share-btn:hover {
            background: rgba(107, 207, 107, 0.15);
            color: #8be08b;
        }

        .share-toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 40, 20, 0.95);
            border: 1px solid rgba(0, 255, 128, 0.6);
            border-radius: 10px;
            padding: 12px 24px;
            color: #0f8;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            font-weight: 600;
            z-index: 1000;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 255, 128, 0.3);
            animation: toastSlide 0.3s ease;
        }

        @keyframes toastSlide {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .settings-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 20, 40, 0.98) 0%, rgba(5, 10, 25, 0.99) 100%);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 16px;
            padding: 24px;
            color: #fff;
            z-index: 200;
            min-width: 340px;
            box-shadow:
                0 0 40px rgba(0, 255, 255, 0.15),
                0 25px 50px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        .settings-panel h2 {
            font-family: 'Orbitron', sans-serif;
            color: #0ff;
            text-align: center;
            margin-bottom: 24px;
            font-size: 20px;
            font-weight: 700;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }

        .settings-item {
            margin: 18px 0;
        }

        .settings-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }

        .settings-value {
            font-family: 'Orbitron', sans-serif;
            color: #0ff;
            font-weight: 600;
            font-size: 12px;
        }

        .settings-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(50, 60, 80, 0.8);
            border-radius: 3px;
            outline: none;
            transition: background 0.2s ease;
        }

        .settings-slider:hover {
            background: rgba(60, 70, 100, 0.9);
        }

        .settings-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #0ff 0%, #0aa 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.4), 0 2px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }

        .settings-slider::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
        }

        .settings-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #0ff 0%, #0aa 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
        }

        .size-buttons {
            display: flex;
            gap: 8px;
        }

        .size-btn {
            flex: 1;
            padding: 10px 0;
            background: rgba(30, 40, 60, 0.8);
            border: 1px solid rgba(100, 100, 120, 0.4);
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.7);
            font-family: 'Orbitron', sans-serif;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .size-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.4);
            color: #0ff;
        }

        .size-btn.active {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.6);
            color: #0ff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        /* Daily Challenge - HIDDEN */
        .daily-challenge-container {
            display: none !important;
        }

        .daily-challenge-header {
            font-family: 'Orbitron', sans-serif;
            color: #f80;
            font-weight: 700;
            font-size: 10px;
            margin-bottom: 6px;
            text-shadow: 0 0 10px rgba(255, 136, 0, 0.4);
            letter-spacing: 0.5px;
        }

        .daily-challenge-name {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: #fff;
            font-weight: 700;
            font-size: 12px;
            line-height: 1.2;
        }

        .daily-challenge-desc {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: rgba(255, 255, 255, 0.6);
            font-size: 10px;
            font-weight: 500;
            margin: 3px 0;
            line-height: 1.3;
        }

        .daily-challenge-progress {
            font-family: 'Orbitron', sans-serif;
            color: #0f0;
            font-weight: 600;
            font-size: 10px;
            margin-top: 6px;
            text-shadow: 0 0 8px rgba(0, 255, 0, 0.4);
        }

        .daily-challenge-reward {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: #ff0;
            font-size: 10px;
            font-weight: 600;
        }

        .daily-challenge-complete {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(255, 136, 0, 0.95) 0%, rgba(255, 200, 0, 0.95) 100%);
            border-radius: 16px;
            padding: 35px 55px;
            text-align: center;
            z-index: 1000;
            animation: dailyPopIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 0 50px rgba(255, 136, 0, 0.5), 0 20px 40px rgba(0, 0, 0, 0.4);
        }

        @keyframes dailyPopIn {
            from {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .daily-challenge-complete.fade-out {
            opacity: 0;
            transition: opacity 0.5s;
        }

        .daily-complete-icon {
            font-size: 50px;
        }

        .daily-complete-title {
            color: #000;
            font-size: 20px;
            font-weight: bold;
            margin: 10px 0;
        }

        .daily-complete-name {
            color: #333;
            font-size: 16px;
        }

        .daily-complete-reward {
            color: #060;
            font-size: 24px;
            font-weight: bold;
            margin-top: 10px;
        }

        /* Audio notification toast */
        .audio-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(40, 40, 60, 0.95);
            border: 1px solid rgba(255, 200, 0, 0.5);
            border-radius: 8px;
            padding: 12px 24px;
            color: #ffc800;
            font-size: 14px;
            z-index: 1001;
            animation: slideUp 0.3s ease-out;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .audio-notification.fade-out {
            opacity: 0;
            transform: translateX(-50%) translateY(10px);
            transition: opacity 0.3s, transform 0.3s;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        /* Epic Amiga-style scroll text */
        .scroll-text-container {
            width: 90%;
            max-width: 700px;
            height: 40px;
            overflow: hidden;
            position: relative;
            margin: 10px auto 20px auto;
            background: transparent;
            border-radius: 20px;
            border: none;
        }

        .scroll-text {
            display: inline-block;
            white-space: nowrap;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            font-weight: 700;
            letter-spacing: 0.1em;
            color: #0ff;
            text-shadow:
                0 0 10px #0ff,
                0 0 20px #f0f;
            animation: marqueeScroll 20s linear infinite;
            line-height: 40px;
            text-transform: uppercase;
        }

        @keyframes marqueeScroll {
            0% { transform: translateX(100%); }
            100% { transform: translateX(-100%); }
        }

        /* Copper bar effect - subtle top bar */
        .copper-bars {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg,
                #0ff 0%, #f0f 50%, #0ff 100%);
            background-size: 200% 100%;
            animation: copperMove 4s linear infinite;
            opacity: 0.6;
        }

        @keyframes copperMove {
            0% { background-position: 0% 0%; }
            100% { background-position: 200% 0%; }
        }

        /* Sine wave text effect for title */
        .sine-text {
            display: inline-block;
            color: #0ff;
            animation: subtleGlow 3s ease-in-out infinite;
        }

        .sine-text:nth-child(odd) { animation-delay: 0s; }
        .sine-text:nth-child(even) { animation-delay: 1.5s; }

        @keyframes subtleGlow {
            0%, 100% {
                text-shadow: 0 0 10px rgba(0, 255, 255, 0.8), 0 0 20px rgba(0, 255, 255, 0.4);
            }
            50% {
                text-shadow: 0 0 20px rgba(255, 0, 255, 0.8), 0 0 40px rgba(255, 0, 255, 0.4);
            }
        }

        /* Retro scanlines effect */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 100;
            opacity: 0.3;
        }

        /* Raster bar effect - hidden for cleaner UI */
        .raster-bar {
            display: none;
        }

        /* Responsive - Mobile (Clean & Minimal) */
        @media (max-width: 850px) {
            .game-container {
                border: none;
                border-radius: 0;
            }
            canvas {
                width: 100vw;
                height: auto;
                max-height: 65vh;
                border-radius: 0;
            }
            /* Minimal HUD */
            .ui-overlay {
                font-size: 10px;
                padding: 0 5px;
                top: 5px;
                gap: 5px;
            }
            .score, .lives, .level {
                padding: 3px 6px;
                min-width: auto;
                border-radius: 4px;
                background: rgba(0, 0, 0, 0.6);
                border: none;
                box-shadow: none;
            }
            .score::before, .lives::before, .level::before {
                display: none;
            }
            /* Hide non-essential UI on mobile */
            .daily-challenge-container,
            .powerup-indicator,
            .combo-display,
            .endless-timer,
            .endless-wave,
            .achievement-popup,
            .controls-panel {
                display: none !important;
            }
            /* Smaller boss health */
            .boss-health {
                top: 35px;
                padding: 3px 8px;
                font-size: 9px;
                background: rgba(0, 0, 0, 0.6);
            }
            .boss-health-bar {
                height: 4px;
            }
            /* Semi-transparent controls */
            .mobile-controls {
                opacity: 0.6;
                bottom: 15px;
                padding: 0 15px;
            }
            /* Smaller joystick */
            .joystick-container, .joystick-base {
                width: 90px;
                height: 90px;
            }
            .joystick-base {
                border-width: 2px;
                background: rgba(0, 20, 40, 0.7);
            }
            .joystick-base::before, .joystick-base::after {
                display: none;
            }
            .joystick-stick {
                width: 40px;
                height: 40px;
            }
            .joystick-arrow {
                font-size: 9px;
                opacity: 0.5;
            }
            .joystick-arrow.up, .joystick-arrow.down {
                display: none;
            }
            /* Smaller fire buttons */
            #fireBtn {
                width: 65px;
                height: 65px;
                font-size: 22px;
            }
            #autoFireBtn {
                width: 38px;
                height: 38px;
                font-size: 10px;
            }
            .fire-buttons {
                gap: 6px;
            }
            .touch-hint {
                display: none;
            }
            /* Hide footer on mobile */
            .game-footer {
                display: none;
            }
        }

        /* Touch device specific */
        body.touch-device .mobile-controls {
            display: flex;
        }

        /* Landscape mode */
        @media (max-height: 500px) and (orientation: landscape) {
            canvas {
                max-height: 80vh;
            }
            .mobile-controls {
                bottom: 5px;
                opacity: 0.5;
            }
            .joystick-container, .joystick-base {
                width: 70px;
                height: 70px;
            }
            .joystick-stick {
                width: 30px;
                height: 30px;
            }
            #fireBtn {
                width: 50px;
                height: 50px;
                font-size: 18px;
            }
            #autoFireBtn {
                width: 30px;
                height: 30px;
                font-size: 8px;
            }
            .ui-overlay {
                top: 2px;
            }
        }

        /* Very small screens */
        @media (max-width: 400px) {
            canvas {
                max-height: 60vh;
            }
            .joystick-container, .joystick-base {
                width: 80px;
                height: 80px;
            }
            .joystick-stick {
                width: 35px;
                height: 35px;
            }
            #fireBtn {
                width: 55px;
                height: 55px;
                font-size: 18px;
            }
            #autoFireBtn {
                width: 32px;
                height: 32px;
            }
        }

        /* Footer */
        .game-footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            text-align: center;
            padding: 15px 20px;
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 13px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 0.5px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, transparent 100%);
        }

        .game-footer a {
            color: rgba(0, 255, 255, 0.6);
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .game-footer a:hover {
            color: #0ff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center, #0a0a2a 0%, #000 70%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .loading-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            color: #0ff;
            text-transform: uppercase;
            letter-spacing: 8px;
            margin-bottom: 60px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            animation: loadingPulse 1.5s ease-in-out infinite;
        }

        @keyframes loadingPulse {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }

        .loading-ship-container {
            position: relative;
            width: 300px;
            height: 80px;
            margin-bottom: 40px;
        }

        .loading-ship {
            position: absolute;
            font-size: 40px;
            animation: loadingShipMove 2s ease-in-out infinite;
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.8));
        }

        @keyframes loadingShipMove {
            0% { left: 0; transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-10px) rotate(-5deg); }
            50% { left: calc(100% - 50px); transform: translateY(0) rotate(0deg); }
            75% { transform: translateY(10px) rotate(5deg); }
            100% { left: 0; transform: translateY(0) rotate(0deg); }
        }

        .loading-ship-trail {
            position: absolute;
            top: 50%;
            left: 20px;
            right: 20px;
            height: 4px;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(0, 255, 255, 0.3) 20%,
                rgba(0, 255, 255, 0.1) 80%,
                transparent 100%);
            transform: translateY(-50%);
            border-radius: 2px;
        }

        .loading-stars {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            pointer-events: none;
        }

        .loading-star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            animation: loadingStarTwinkle 1.5s ease-in-out infinite;
        }

        @keyframes loadingStarTwinkle {
            0%, 100% { opacity: 0.2; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.5); }
        }

        .loading-bar-container {
            width: 300px;
            height: 20px;
            background: rgba(0, 50, 100, 0.3);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #0ff, #00f, #0ff);
            background-size: 200% 100%;
            animation: loadingBarShine 1s linear infinite;
            border-radius: 8px;
            transition: width 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        @keyframes loadingBarShine {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .loading-text {
            margin-top: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .loading-percent {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            color: #0ff;
            margin-top: 10px;
            letter-spacing: 4px;
        }

        .loading-tips {
            position: absolute;
            bottom: 80px;
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            max-width: 400px;
            animation: tipFade 4s ease-in-out infinite;
        }

        @keyframes tipFade {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; }
        }

        @media (max-width: 600px) {
            .loading-title {
                font-size: 18px;
                letter-spacing: 4px;
            }
            .loading-ship-container {
                width: 200px;
            }
            .loading-bar-container {
                width: 200px;
            }
            .loading-tips {
                font-size: 14px;
                max-width: 280px;
                padding: 0 20px;
            }
        }

        /* ==========================================
           FIRST-TIME USER EXPERIENCE (FTUE) TUTORIAL
           ========================================== */
        .ftue-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.4s ease, visibility 0.4s ease;
        }

        .ftue-overlay.active {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .ftue-step {
            text-align: center;
            max-width: 400px;
            padding: 40px;
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .ftue-step.active {
            opacity: 1;
            transform: translateY(0);
        }

        .ftue-icon {
            font-size: 64px;
            margin-bottom: 20px;
            animation: ftueIconPulse 1.5s ease-in-out infinite;
        }

        @keyframes ftueIconPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }

        .ftue-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            font-weight: 700;
            color: #0ff;
            margin-bottom: 15px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
            letter-spacing: 2px;
        }

        .ftue-desc {
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 20px;
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.5;
        }

        .ftue-keys {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 25px;
        }

        .ftue-key {
            background: linear-gradient(180deg, rgba(0, 100, 150, 0.6) 0%, rgba(0, 50, 100, 0.8) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 10px;
            padding: 15px 25px;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), 0 0 20px rgba(0, 255, 255, 0.2);
            animation: ftueKeyBounce 0.8s ease-in-out infinite;
        }

        .ftue-key:nth-child(2) { animation-delay: 0.1s; }
        .ftue-key:nth-child(3) { animation-delay: 0.2s; }

        @keyframes ftueKeyBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .ftue-progress {
            display: flex;
            gap: 10px;
            margin-top: 40px;
        }

        .ftue-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .ftue-dot.active {
            background: #0ff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
            transform: scale(1.2);
        }

        .ftue-dot.completed {
            background: #0f0;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .ftue-skip {
            position: absolute;
            top: 30px;
            right: 30px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 10px 20px;
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .ftue-skip:hover {
            border-color: rgba(255, 255, 255, 0.6);
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        .ftue-continue {
            margin-top: 30px;
            background: linear-gradient(135deg, #0ff, #00b8b8);
            border: none;
            border-radius: 30px;
            padding: 15px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            font-weight: 600;
            color: #000;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            transition: all 0.3s ease;
        }

        .ftue-continue:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.7);
        }

        /* ==========================================
           VISUAL FEEDBACK: HIT EFFECTS
           ========================================== */
        .hit-flash {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.9) 0%, rgba(255, 100, 100, 0.6) 50%, transparent 70%);
            pointer-events: none;
            animation: hitFlashAnim 0.2s ease-out forwards;
        }

        @keyframes hitFlashAnim {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        /* ==========================================
           VISUAL FEEDBACK: FLOATING TEXT
           ========================================== */
        .floating-text {
            position: absolute;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 700;
            color: #0ff;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.8), 0 0 30px rgba(0, 255, 255, 0.5);
            pointer-events: none;
            animation: floatUp 1.2s ease-out forwards;
            white-space: nowrap;
            z-index: 1000;
        }

        .floating-text.powerup {
            color: #f0f;
            text-shadow: 0 0 15px rgba(255, 0, 255, 0.8), 0 0 30px rgba(255, 0, 255, 0.5);
        }

        .floating-text.damage {
            color: #ff6b6b;
            text-shadow: 0 0 15px rgba(255, 100, 100, 0.8);
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(0.8);
                opacity: 1;
            }
            70% {
                opacity: 1;
            }
            100% {
                transform: translateY(-60px) scale(1.1);
                opacity: 0;
            }
        }

    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-stars" id="loadingStars"></div>
        <div class="loading-title">Cosmic Blasterz</div>
        <div class="loading-ship-container">
            <div class="loading-ship-trail"></div>
            <div class="loading-ship"></div>
        </div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div class="loading-text" id="loadingText">Initializing...</div>
        <div class="loading-percent" id="loadingPercent">0%</div>
        <div class="loading-tips" id="loadingTips">Use arrow keys to move and SPACE to shoot</div>
    </div>

    <!-- Screen Transition Overlay -->
    <div class="screen-transition-overlay" id="screenTransition">
        <div class="transition-content">
            <div class="transition-icon" id="transitionIcon"></div>
            <div class="transition-text" id="transitionText">Loading...</div>
        </div>
    </div>

    <!-- Splash Screen -->
    <div class="splash-screen hidden" id="splashScreen">
        <div class="splash-stars" id="splashStars"></div>
        <img src="logo.png" alt="Cosmic Blasterz" class="splash-logo">
        <div class="splash-prompt">Press Any Button to Continue</div>
        <div class="splash-scroller">
            <canvas id="scrollerCanvas"></canvas>
        </div>
        <div class="splash-copyright">Copyright  2026 | Invincible.as | All Rights Reserved.</div>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas" width="1000" height="700"></canvas>
        <div class="crt-overlay flicker"></div>
        <div class="screen-flash" id="screenFlash"></div>
        <div class="ui-overlay">
            <div class="score">SCORE: <span id="scoreValue">0</span></div>
            <div class="level">LEVEL: <span id="levelValue">1</span></div>
            <div class="lives">P1: <span id="livesValue"></span></div>
            <div class="lives player2-lives hidden" id="player2Lives">P2: <span id="lives2Value"></span></div>
        </div>

        <!-- FTUE Tutorial Overlay -->
        <div class="ftue-overlay" id="ftueOverlay">
            <button class="ftue-skip" onclick="skipFTUE()">Skip Tutorial</button>

            <!-- Step 1: Movement -->
            <div class="ftue-step active" id="ftueStep1">
                <div class="ftue-icon"></div>
                <div class="ftue-title">Move Your Ship</div>
                <div class="ftue-desc">Dodge enemy fire and position yourself for the perfect shot!</div>
                <div class="ftue-keys">
                    <div class="ftue-key"></div>
                    <div class="ftue-key"></div>
                </div>
                <button class="ftue-continue" onclick="nextFTUEStep()">Got It!</button>
                <div class="ftue-progress">
                    <div class="ftue-dot active"></div>
                    <div class="ftue-dot"></div>
                    <div class="ftue-dot"></div>
                </div>
            </div>

            <!-- Step 2: Shooting -->
            <div class="ftue-step" id="ftueStep2">
                <div class="ftue-icon"></div>
                <div class="ftue-title">Fire!</div>
                <div class="ftue-desc">Blast the alien invaders before they reach Earth!</div>
                <div class="ftue-keys">
                    <div class="ftue-key">SPACE</div>
                </div>
                <button class="ftue-continue" onclick="nextFTUEStep()">Let's Go!</button>
                <div class="ftue-progress">
                    <div class="ftue-dot completed"></div>
                    <div class="ftue-dot active"></div>
                    <div class="ftue-dot"></div>
                </div>
            </div>

            <!-- Step 3: Objective -->
            <div class="ftue-step" id="ftueStep3">
                <div class="ftue-icon"></div>
                <div class="ftue-title">Destroy & Survive</div>
                <div class="ftue-desc">Eliminate all enemies, collect power-ups, and survive the onslaught!</div>
                <button class="ftue-continue" onclick="completeFTUE()">Start Mission!</button>
                <div class="ftue-progress">
                    <div class="ftue-dot completed"></div>
                    <div class="ftue-dot completed"></div>
                    <div class="ftue-dot active"></div>
                </div>
            </div>
        </div>

        <div class="start-screen" id="startScreen">
            <canvas id="starfieldCanvas" class="starfield-canvas"></canvas>
            <div class="scanlines"></div>

            <!-- Clean Title -->
            <h1 class="game-title">
                <span class="letter" style="animation-delay: 0s"></span><span class="space"></span><span class="letter" style="animation-delay: 0.05s">C</span><span class="letter" style="animation-delay: 0.1s">O</span><span class="letter" style="animation-delay: 0.15s">S</span><span class="letter" style="animation-delay: 0.2s">M</span><span class="letter" style="animation-delay: 0.25s">I</span><span class="letter" style="animation-delay: 0.3s">C</span><span class="space"></span><span class="letter" style="animation-delay: 0.35s">B</span><span class="letter" style="animation-delay: 0.4s">L</span><span class="letter" style="animation-delay: 0.45s">A</span><span class="letter" style="animation-delay: 0.5s">S</span><span class="letter" style="animation-delay: 0.55s">T</span><span class="letter" style="animation-delay: 0.6s">E</span><span class="letter" style="animation-delay: 0.65s">R</span><span class="letter" style="animation-delay: 0.7s">Z</span><span class="space"></span><span class="letter" style="animation-delay: 0.75s"></span>
            </h1>

            <!-- Scroll text -->
            <div class="scroll-text-container">
                <div class="scroll-text">
                     WELCOME TO COSMIC BLASTERZ  THE ULTIMATE RETRO SPACE SHOOTER  ARROWS/WASD TO MOVE  SPACE TO SHOOT  COLLECT POWER-UPS  DEFEAT EPIC BOSSES  CLIMB THE GLOBAL LEADERBOARD  GREETINGS TO ALL RETRO GAMERS  MADE WITH  BY MRICEBIRD  BUILT WITH AI AS CO-PILOT 
                </div>
            </div>

            <!-- Quick Settings Bar -->
            <div class="menu-settings-bar">
                <div class="menu-name-input">
                    <input type="text" id="playerName" placeholder="Enter pilot name..." maxlength="15" autocomplete="off" spellcheck="false">
                </div>
                <div class="menu-quick-settings">
                    <button class="menu-quick-btn" id="menuMusicBtn" onclick="toggleMenuMusic()" title="Music">
                        <span class="btn-icon"></span>
                        <span class="btn-label">Music</span>
                    </button>
                    <button class="menu-quick-btn" id="menuSoundBtn" onclick="toggleSound()" title="Sound">
                        <span class="btn-icon"></span>
                        <span class="btn-label">Sound</span>
                    </button>
                    <button class="menu-quick-btn" id="fullscreenBtn" onclick="toggleFullscreen()" title="Fullscreen">
                        <span class="btn-icon"></span>
                        <span class="btn-label">Fullscreen</span>
                    </button>
                </div>
            </div>

            <!-- Difficulty -->
            <div class="difficulty-selector">
                <div class="difficulty-option easy">
                    <button class="difficulty-btn easy" onclick="setDifficulty('easy')"></button>
                    <span class="difficulty-label">Easy</span>
                </div>
                <div class="difficulty-option normal">
                    <button class="difficulty-btn normal active" onclick="setDifficulty('normal')"></button>
                    <span class="difficulty-label">Normal</span>
                </div>
                <div class="difficulty-option hard">
                    <button class="difficulty-btn hard" onclick="setDifficulty('hard')"></button>
                    <span class="difficulty-label">Hard</span>
                </div>
                <div class="difficulty-option nightmare">
                    <button class="difficulty-btn nightmare" onclick="setDifficulty('nightmare')"></button>
                    <span class="difficulty-label">Nightmare</span>
                </div>
            </div>

            <!-- Game Modes -->
            <div class="mode-buttons">
                <div class="mode-card normal" onclick="startGame(false)">
                    <div class="mode-icon"></div>
                    <div class="mode-title">PLAY</div>
                    <div class="mode-desc">25 levels + bosses</div>
                </div>
                <div class="mode-card endless" onclick="startGame(true)">
                    <div class="mode-icon"></div>
                    <div class="mode-title">ENDLESS</div>
                    <div class="mode-desc">Survive forever</div>
                </div>
                <div class="mode-card twoplayer" onclick="startGame(false, true)">
                    <div class="mode-icon"></div>
                    <div class="mode-title">CO-OP</div>
                    <div class="mode-desc">2 player mode</div>
                </div>
            </div>

            <!-- Extra buttons -->
            <div class="menu-footer">
                <button class="menu-footer-btn" onclick="openGarage()"> Garage</button>
                <button class="menu-footer-btn" onclick="openStats()"> Stats</button>
                <button class="menu-footer-btn" onclick="startTutorial()"> Tutorial</button>
                <button class="menu-footer-btn" onclick="startAIDemo()"> Watch AI</button>
                <button class="menu-footer-btn" onclick="openFeedback()"> Feedback</button>
                <button class="menu-footer-btn hidden" id="installPwaBtn" onclick="installPwa()"> Install</button>
            </div>

            <!-- Highscores -->
            <div class="highscore-list" id="startHighscores"></div>

            <!-- Creator credit -->
            <div class="credits-row">
                <a href="https://www.linkedin.com/in/mricebird/" target="_blank" class="creator-link">Made by @mricebird</a>
                <span class="ai-badge" title="Built using Claude AI as co-pilot"> Built with AI</span>
            </div>
        </div>

        <!-- Invite Friend Modal -->
        <div class="invite-modal hidden" id="inviteModal">
            <div class="invite-modal-content">
                <h2> Invite Friends</h2>
                <p>Share Cosmic Blasterz with your friends and challenge them to beat your highscore!</p>
                <div class="invite-link-box" id="inviteLink">https://mricebird.github.io/cosmic-blasterz/</div>
                <div class="invite-share-buttons">
                    <button class="invite-share-btn twitter" onclick="inviteViaTwitter()"> Twitter</button>
                    <button class="invite-share-btn facebook" onclick="inviteViaFacebook()"> Facebook</button>
                    <button class="invite-share-btn whatsapp" onclick="inviteViaWhatsApp()"> WhatsApp</button>
                    <button class="invite-share-btn copy" onclick="copyInviteLink()"> Copy Link</button>
                </div>
                <button class="invite-close-btn" onclick="closeInviteModal()">Close</button>
            </div>
        </div>

        <div class="game-over-screen hidden" id="gameOverScreen">
            <h1 id="gameOverTitle"> GAME OVER </h1>
            <p class="game-over-subtitle" id="gameOverSubtitle">The aliens have won this battle...</p>
            <div id="newHighscoreMsg" class="new-highscore hidden"> NEW HIGHSCORE! </div>
            <div class="final-score"><span id="playerNameDisplay"></span>'s Score: <span id="finalScore">0</span></div>
            <div class="endless-survival hidden" id="endlessSurvival"> Survived: <span id="survivalTime">00:00</span> | Wave: <span id="finalWave">1</span></div>
            <div class="game-stats-grid" id="gameStatsGrid">
                <div class="stat-item">
                    <span class="stat-icon"></span>
                    <span class="stat-value" id="statKills">0</span>
                    <span class="stat-label">Enemies Killed</span>
                </div>
                <div class="stat-item">
                    <span class="stat-icon"></span>
                    <span class="stat-value" id="statAccuracy">0%</span>
                    <span class="stat-label">Accuracy</span>
                </div>
                <div class="stat-item">
                    <span class="stat-icon"></span>
                    <span class="stat-value" id="statMaxCombo">0x</span>
                    <span class="stat-label">Max Combo</span>
                </div>
                <div class="stat-item">
                    <span class="stat-icon"></span>
                    <span class="stat-value" id="statTime">00:00</span>
                    <span class="stat-label">Time Played</span>
                </div>
                <div class="stat-item">
                    <span class="stat-icon"></span>
                    <span class="stat-value" id="statPowerups">0</span>
                    <span class="stat-label">Powerups</span>
                </div>
                <div class="stat-item">
                    <span class="stat-icon"></span>
                    <span class="stat-value" id="statLevel">1</span>
                    <span class="stat-label">Level Reached</span>
                </div>
            </div>
            <div class="highscore-list" id="gameOverHighscores"></div>
            <div class="achievements-section">
                <h4> ACHIEVEMENTS</h4>
                <div class="achievement-badges" id="achievementBadges"></div>
            </div>
            <div class="game-over-buttons">
                <button class="restart-btn" onclick="restartGame()">PLAY AGAIN</button>
                <button class="menu-btn" onclick="backToMenu()"> MAIN MENU</button>
                <button class="share-btn" onclick="shareScore()"> SHARE SCORE</button>
            </div>
            <div class="share-options hidden" id="shareOptions">
                <button class="share-option-btn" onclick="shareToLinkedIn()"> LinkedIn</button>
                <button class="share-option-btn" onclick="shareToTwitter()"> Twitter</button>
                <button class="share-option-btn" onclick="shareToFacebook()"> Facebook</button>
                <button class="share-option-btn" onclick="copyShareLink()"> Copy</button>
            </div>
            <div class="share-copied hidden" id="shareCopied"> Copied to clipboard!</div>
        </div>

        <!-- Pause screen -->
        <div class="pause-screen hidden" id="pauseScreen">
            <div class="pause-container">
                <h2> PAUSED</h2>

                <div class="pause-buttons">
                    <button class="pause-btn primary" onclick="togglePause()"> RESUME</button>
                    <button class="pause-btn" onclick="restartFromPause()"> RESTART LEVEL</button>
                    <button class="pause-btn danger" onclick="quitToMenu()"> QUIT TO MENU</button>
                </div>

                <div class="pause-settings">
                    <h3> Audio Settings</h3>
                    <div class="volume-control">
                        <span class="volume-label">SFX</span>
                        <input type="range" class="volume-slider" id="pauseSfxVolume" min="0" max="100" value="100" oninput="updateSfxVolume(this.value)">
                        <span class="volume-value" id="pauseSfxValue">100%</span>
                    </div>
                    <div class="volume-control">
                        <span class="volume-label">Music</span>
                        <input type="range" class="volume-slider" id="pauseMusicVolume" min="0" max="100" value="100" oninput="updateMusicVolume(this.value)">
                        <span class="volume-value" id="pauseMusicValue">100%</span>
                    </div>
                </div>

                <div class="pause-controls-ref">
                    <h3> Controls</h3>
                    <div class="controls-grid">
                        <div class="control-item">
                            <span class="control-key"> </span>
                            <span class="control-action">Move</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">SPACE</span>
                            <span class="control-action">Shoot</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">P</span>
                            <span class="control-action">Pause</span>
                        </div>
                        <div class="control-item">
                            <span class="control-key">M</span>
                            <span class="control-action">Mute</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Roguelike Upgrade Modal -->
        <div class="roguelike-modal hidden" id="roguelikeModal">
            <div class="roguelike-title"> CHOOSE AN UPGRADE </div>
            <div class="upgrade-cards" id="upgradeCards">
                <!-- Upgrade cards will be inserted here dynamically -->
            </div>
        </div>

        <!-- Custom Confirm Modal -->
        <div class="confirm-modal" id="confirmModal">
            <div class="confirm-dialog">
                <div class="confirm-icon"></div>
                <div class="confirm-title" id="confirmTitle">Confirm Action</div>
                <div class="confirm-message" id="confirmMessage">Are you sure?</div>
                <div class="confirm-buttons">
                    <button class="confirm-btn confirm-btn-cancel" onclick="hideConfirmModal()">Cancel</button>
                    <button class="confirm-btn confirm-btn-confirm" id="confirmBtn" onclick="executeConfirmAction()">Confirm</button>
                </div>
            </div>
        </div>

        <!-- AI Demo overlay -->
        <div class="demo-overlay hidden" id="demoOverlay">
            <div class="demo-banner">
                <span class="demo-icon"></span>
                <span class="demo-text">AI DEMO MODE</span>
                <span class="demo-hint">Press any key or click to play yourself!</span>
            </div>
        </div>

        <!-- Garage Screen -->
        <div class="garage-screen hidden" id="garageScreen">
            <div class="garage-header">
                <button class="garage-back-btn" onclick="closeGarage()"> BACK</button>
                <h1> GARAGE</h1>
                <div class="garage-coins"> <span id="garageCoins">0</span></div>
            </div>

            <div class="garage-content">
                <div class="garage-ship-display">
                    <canvas id="garageCanvas" width="400" height="350"></canvas>
                    <div class="garage-ship-name" id="garageShipName">CLASSIC FIGHTER</div>
                    <div class="garage-ship-stats" id="garageShipStats">
                        <div class="stat-item"><span class="stat-label">SPEED</span><div class="stat-bar"><div class="stat-fill" id="statSpeed" style="width: 50%"></div></div></div>
                        <div class="stat-item"><span class="stat-label">DAMAGE</span><div class="stat-bar"><div class="stat-fill" id="statDamage" style="width: 40%"></div></div></div>
                        <div class="stat-item"><span class="stat-label">FIRE RATE</span><div class="stat-bar"><div class="stat-fill" id="statFireRate" style="width: 50%"></div></div></div>
                        <div class="stat-item"><span class="stat-label">DEFENSE</span><div class="stat-bar"><div class="stat-fill" id="statDefense" style="width: 30%"></div></div></div>
                    </div>
                </div>

                <div class="garage-customization">
                    <div class="garage-tabs">
                        <button class="garage-tab active" onclick="switchGarageTab('skins')" id="garageSkinsTab"> SKINS</button>
                        <button class="garage-tab" onclick="switchGarageTab('trails')" id="garageTrailsTab"> TRAILS</button>
                        <button class="garage-tab" onclick="switchGarageTab('weapons')" id="garageWeaponsTab"> WEAPONS</button>
                        <button class="garage-tab" onclick="switchGarageTab('upgrades')" id="garageUpgradesTab"> UPGRADES</button>
                    </div>

                    <div class="garage-items" id="garageItems">
                        <!-- Items will be rendered here -->
                    </div>
                </div>
            </div>

            <div class="garage-equipped">
                <h3>EQUIPPED</h3>
                <div class="equipped-items">
                    <div class="equipped-item">
                        <span class="equipped-label">SKIN</span>
                        <span class="equipped-value" id="equippedSkin">Classic</span>
                    </div>
                    <div class="equipped-item">
                        <span class="equipped-label">TRAIL</span>
                        <span class="equipped-value" id="equippedTrail">Classic</span>
                    </div>
                    <div class="equipped-item">
                        <span class="equipped-label">WEAPON</span>
                        <span class="equipped-value" id="equippedWeapon">Laser</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Statistics Screen -->
        <div class="stats-screen hidden" id="statsScreen">
            <div class="stats-container">
                <div class="stats-header">
                    <h2 class="stats-title"> Statistics</h2>
                    <button class="stats-close-btn" onclick="closeStats()"></button>
                </div>

                <div class="stats-section-title"> Gameplay</div>
                <div class="stats-grid">
                    <div class="stat-card highlight">
                        <div class="stat-icon"></div>
                        <div class="stat-value" id="statHighScore">0</div>
                        <div class="stat-label">High Score</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon"></div>
                        <div class="stat-value" id="statGamesPlayed">0</div>
                        <div class="stat-label">Games Played</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon"></div>
                        <div class="stat-value" id="statHighLevel">0</div>
                        <div class="stat-label">Highest Level</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon"></div>
                        <div class="stat-value" id="statTotalTime">0h</div>
                        <div class="stat-label">Time Played</div>
                    </div>
                </div>

                <div class="stats-section-title"> Combat</div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-icon"></div>
                        <div class="stat-value" id="statTotalKills">0</div>
                        <div class="stat-label">Enemies Killed</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon"></div>
                        <div class="stat-value" id="statBossKills">0</div>
                        <div class="stat-label">Bosses Defeated</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon"></div>
                        <div class="stat-value" id="statBestCombo">0</div>
                        <div class="stat-label">Best Combo</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon"></div>
                        <div class="stat-value" id="statPowerUps">0</div>
                        <div class="stat-label">Power-Ups</div>
                    </div>
                </div>

                <div class="stats-section-title"> Economy</div>
                <div class="stats-grid">
                    <div class="stat-card highlight">
                        <div class="stat-icon"></div>
                        <div class="stat-value" id="statTotalCoins">0</div>
                        <div class="stat-label">Coins Earned</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon"></div>
                        <div class="stat-value" id="statChallenges">0</div>
                        <div class="stat-label">Challenges Done</div>
                    </div>
                </div>

                <div class="stats-footer">
                    <button class="stats-reset-btn" onclick="confirmResetStats()">Reset Statistics</button>
                </div>
            </div>
        </div>

        <!-- Bottom toolbar -->
        <div class="bottom-toolbar">
            <div class="toolbar-center">
                <!-- Shop & Coins -->
                <div class="toolbar-group">
                    <button class="shop-btn" id="shopBtn" onclick="toggleShop()"> SHOP</button>
                    <div class="coins-display" id="coinsDisplay"> 0</div>
                </div>

                <div class="toolbar-divider"></div>

                <!-- Weapons -->
                <div class="toolbar-group weapon-selector" id="weaponSelector">
                    <button class="weapon-btn active" id="weapon1" onclick="selectWeapon('laser')" title="Laser (1)">
                        <span class="weapon-icon"></span>
                        <span class="weapon-key">1</span>
                    </button>
                    <button class="weapon-btn" id="weapon2" onclick="selectWeapon('missile')" title="Missile (2)">
                        <span class="weapon-icon"></span>
                        <span class="weapon-key">2</span>
                    </button>
                    <button class="weapon-btn" id="weapon3" onclick="selectWeapon('plasma')" title="Plasma (3)">
                        <span class="weapon-icon"></span>
                        <span class="weapon-key">3</span>
                    </button>
                </div>

                <div class="toolbar-divider"></div>

                <!-- Audio Controls -->
                <div class="toolbar-group game-controls" id="gameControls">
                    <button class="control-btn" id="muteBtn" onclick="toggleMute()" title="Sound (M)"></button>
                    <button class="control-btn" id="musicBtn" onclick="toggleMusic()" title="Music"></button>
                    <button class="control-btn" id="announcerBtn" onclick="toggleAnnouncer()" title="Announcer"></button>
                </div>

                <div class="toolbar-divider"></div>

                <!-- Game Controls -->
                <div class="toolbar-group">
                    <button class="control-btn" id="pauseBtn" onclick="togglePause()" title="Pause (P)"></button>
                    <button class="settings-btn" id="settingsBtn" onclick="toggleSettings()"></button>
                    <button class="share-btn" onclick="shareGame()" title="Share"></button>
                </div>
            </div>
        </div>

        <!-- Power-up indicator -->
        <div class="powerup-indicator hidden" id="powerupIndicator"></div>

        <!-- Combo display -->
        <div class="combo-display" id="comboDisplay"></div>

        <!-- Achievement popup -->
        <div class="achievement-popup" id="achievementPopup">
            <h4> ACHIEVEMENT UNLOCKED!</h4>
            <div class="achievement-icon" id="achievementIcon"></div>
            <div class="achievement-name" id="achievementName">First Blood</div>
            <div class="achievement-desc" id="achievementDesc">Kill your first enemy</div>
        </div>

        <!-- Achievement detail modal -->
        <div class="achievement-detail-overlay hidden" id="achievementDetailOverlay" onclick="closeAchievementDetail()">
            <div class="achievement-detail-modal" onclick="event.stopPropagation()">
                <button class="achievement-detail-close" onclick="closeAchievementDetail()">&times;</button>
                <div class="achievement-detail-icon" id="detailIcon"></div>
                <h3 class="achievement-detail-name" id="detailName">First Blood</h3>
                <div class="achievement-detail-rarity" id="detailRarity">COMMON</div>
                <p class="achievement-detail-desc" id="detailDesc">Kill your first enemy</p>
                <p class="achievement-detail-long" id="detailLong">Every journey begins with a single step...</p>
                <div class="achievement-detail-tip">
                    <span class="tip-label"> TIP:</span>
                    <span id="detailTip">Just shoot any enemy to unlock this achievement.</span>
                </div>
                <div class="achievement-detail-reward">
                    <span> REWARD:</span>
                    <span id="detailReward">10 coins</span>
                </div>
                <div class="achievement-detail-status" id="detailStatus"> UNLOCKED</div>
            </div>
        </div>

        <!-- Boss health bar -->
        <div class="boss-health hidden" id="bossHealth">
            <div class="boss-name" id="bossName">GUARDIAN</div>
            <div class="boss-health-bar">
                <div class="boss-health-fill" id="bossHealthFill"></div>
            </div>
        </div>

        <!-- Mobile controls -->
        <div class="mobile-controls" id="mobileControls">
            <!-- Virtual Joystick -->
            <div class="joystick-container" id="joystickContainer">
                <div class="joystick-base">
                    <div class="joystick-directions">
                        <span class="joystick-arrow up" id="arrowUp"></span>
                        <span class="joystick-arrow down" id="arrowDown"></span>
                        <span class="joystick-arrow left" id="arrowLeft"></span>
                        <span class="joystick-arrow right" id="arrowRight"></span>
                    </div>
                </div>
                <div class="joystick-stick" id="joystickStick"></div>
            </div>

            <!-- Touch hint -->
            <div class="touch-hint" id="touchHint">
                Joystick: Move ship  Fire: Shoot<br>
                AUTO: Toggle auto-fire
            </div>

            <!-- Fire buttons -->
            <div class="fire-buttons">
                <button class="mobile-btn" id="fireBtn"></button>
                <button class="mobile-btn" id="autoFireBtn">AUTO</button>
            </div>
        </div>

        <!-- Shop panel -->
        <div class="shop-panel hidden" id="shopPanel">
            <button class="shop-close" onclick="toggleShop()"></button>
            <h2> SHOP</h2>
            <div id="shopItems"></div>
        </div>

        <!-- Settings panel -->
        <div class="settings-panel hidden" id="settingsPanel">
            <button class="settings-close" onclick="toggleSettings()"></button>
            <h2> SETTINGS</h2>
            <div class="settings-item">
                <div class="settings-label">
                    <span> Sound Effects</span>
                    <span class="settings-value" id="sfxValue">100%</span>
                </div>
                <input type="range" class="settings-slider" id="sfxVolume" min="0" max="100" value="100" oninput="updateVolume('sfx', this.value)">
            </div>
            <div class="settings-item">
                <div class="settings-label">
                    <span> Music</span>
                    <span class="settings-value" id="musicValue">100%</span>
                </div>
                <input type="range" class="settings-slider" id="musicVolume" min="0" max="100" value="100" oninput="updateVolume('music', this.value)">
            </div>
            <div class="settings-item">
                <div class="settings-label">
                    <span> Announcer</span>
                    <span class="settings-value" id="announcerValue">100%</span>
                </div>
                <input type="range" class="settings-slider" id="announcerVolume" min="0" max="100" value="100" oninput="updateVolume('announcer', this.value)">
            </div>
            <div class="settings-item">
                <div class="settings-label">
                    <span> Screen Size</span>
                </div>
                <div class="size-buttons">
                    <button class="size-btn" onclick="setScreenSize('small')">S</button>
                    <button class="size-btn active" onclick="setScreenSize('medium')">M</button>
                    <button class="size-btn" onclick="setScreenSize('large')">L</button>
                    <button class="size-btn" onclick="setScreenSize('xlarge')">XL</button>
                </div>
            </div>
        </div>

        <!-- Daily Challenge -->
        <div class="daily-challenge-container" id="dailyChallengeContainer"></div>

        <!-- Endless Mode UI -->
        <div class="endless-timer hidden" id="endlessTimer"> 00:00</div>
        <div class="endless-wave hidden" id="endlessWave">Wave 1</div>

        <!-- Boss Rush UI -->
        <div class="boss-rush-display hidden" id="bossRushDisplay">
            <span class="boss-rush-icon"></span>
            <span class="boss-rush-text">BOSS <span id="bossRushCurrent">1</span> of <span id="bossRushTotal">5</span></span>
        </div>

        <!-- Tutorial overlay -->
        <div class="tutorial-overlay hidden" id="tutorialOverlay">
            <div class="tutorial-box">
                <div class="tutorial-progress" id="tutorialProgress"></div>
                <div class="tutorial-title" id="tutorialTitle">Welcome!</div>
                <div class="tutorial-text" id="tutorialText">Learn to play Cosmic Blasterz!</div>
                <div>
                    <button class="tutorial-btn-next" onclick="nextTutorialStep()">Next</button>
                    <button class="tutorial-btn-skip" onclick="skipTutorial()">Skip</button>
                </div>
            </div>
        </div>
    </div>

    <footer class="game-footer">
        Copyright  2026 | <a href="https://invincible.as" target="_blank">Invincible.as</a> | All Rights Reserved.
    </footer>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Stub function for daily challenge progress tracking (defined early to ensure availability)
        function updateDailyChallengeProgress(type, value) {
            // Progress is tracked via checkDailyChallenge() during gameplay
            // This stub prevents "not defined" errors
        }

        // Audio context for sound effects
        let audioCtx = null;
        let audioReady = false;
        let audioErrorShown = false;

        function showAudioNotification(message) {
            if (audioErrorShown) return;
            audioErrorShown = true;

            const notification = document.createElement('div');
            notification.className = 'audio-notification';
            notification.innerHTML = `<span></span><span>${message}</span>`;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.classList.add('fade-out');
                setTimeout(() => notification.remove(), 300);
            }, 4000);
        }

        async function initAudio() {
            try {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                // Resume AudioContext if suspended (required by modern browsers)
                if (audioCtx.state === 'suspended') {
                    await audioCtx.resume();
                }
                audioReady = true;
            } catch (e) {
                showAudioNotification('Audio unavailable - tap screen to enable');
            }
        }

        // Helper to ensure audio is ready before playing
        function ensureAudio() {
            try {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                if (audioCtx && audioCtx.state !== 'running') {
                    showAudioNotification('Audio unavailable - tap screen to enable');
                }
                return audioCtx && audioCtx.state === 'running';
            } catch (e) {
                showAudioNotification('Audio unavailable - tap screen to enable');
                return false;
            }
        }

        // Enhanced Sound effect: Player shooting with weapon variations
        function playShootSound() {
            if (soundMuted || sfxVolume === 0) return;
            if (!ensureAudio()) return;
            try {
                const weapon = typeof currentWeapon !== 'undefined' ? currentWeapon : 'laser';
                const vol = Math.max(0.01, 0.15 * (sfxVolume / 100));

                // Random pitch variation for natural feel
                const pitchVar = 0.9 + Math.random() * 0.2;

                if (weapon === 'laser') {
                    // Laser: high-pitched zap with harmonics
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    const filter = audioCtx.createBiquadFilter();

                    filter.type = 'highpass';
                    filter.frequency.value = 500;

                    osc1.connect(gain);
                    osc2.connect(gain);
                    gain.connect(filter);
                    filter.connect(audioCtx.destination);

                    osc1.type = 'square';
                    osc1.frequency.setValueAtTime(1200 * pitchVar, audioCtx.currentTime);
                    osc1.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.08);

                    osc2.type = 'sawtooth';
                    osc2.frequency.setValueAtTime(800 * pitchVar, audioCtx.currentTime);
                    osc2.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.08);

                    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);

                    osc1.start(audioCtx.currentTime);
                    osc2.start(audioCtx.currentTime);
                    osc1.stop(audioCtx.currentTime + 0.08);
                    osc2.stop(audioCtx.currentTime + 0.08);
                } else if (weapon === 'missile') {
                    // Missile: whoosh with low rumble
                    const osc = audioCtx.createOscillator();
                    const noise = createNoiseBuffer(0.15);
                    const noiseSource = audioCtx.createBufferSource();
                    noiseSource.buffer = noise;

                    const gain1 = audioCtx.createGain();
                    const gain2 = audioCtx.createGain();
                    const filter = audioCtx.createBiquadFilter();

                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(800, audioCtx.currentTime);
                    filter.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.15);

                    osc.connect(gain1);
                    gain1.connect(audioCtx.destination);

                    noiseSource.connect(filter);
                    filter.connect(gain2);
                    gain2.connect(audioCtx.destination);

                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(150 * pitchVar, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.15);

                    gain1.gain.setValueAtTime(vol * 0.8, audioCtx.currentTime);
                    gain1.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);

                    gain2.gain.setValueAtTime(vol * 0.5, audioCtx.currentTime);
                    gain2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);

                    osc.start(audioCtx.currentTime);
                    noiseSource.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.15);
                } else if (weapon === 'plasma') {
                    // Plasma: electric buzz with modulation
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const modulator = audioCtx.createOscillator();
                    const modGain = audioCtx.createGain();
                    const gain = audioCtx.createGain();

                    modulator.connect(modGain);
                    modGain.connect(osc1.frequency);

                    osc1.connect(gain);
                    osc2.connect(gain);
                    gain.connect(audioCtx.destination);

                    modulator.type = 'sine';
                    modulator.frequency.value = 30;
                    modGain.gain.value = 100;

                    osc1.type = 'sawtooth';
                    osc1.frequency.setValueAtTime(400 * pitchVar, audioCtx.currentTime);

                    osc2.type = 'square';
                    osc2.frequency.setValueAtTime(600 * pitchVar, audioCtx.currentTime);
                    osc2.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.12);

                    gain.gain.setValueAtTime(vol * 0.7, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.12);

                    modulator.start(audioCtx.currentTime);
                    osc1.start(audioCtx.currentTime);
                    osc2.start(audioCtx.currentTime);
                    modulator.stop(audioCtx.currentTime + 0.12);
                    osc1.stop(audioCtx.currentTime + 0.12);
                    osc2.stop(audioCtx.currentTime + 0.12);
                }
            } catch (e) { /* Silent fail */ }
        }

        // Helper: Create noise buffer
        function createNoiseBuffer(duration) {
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 1.5);
            }
            return buffer;
        }

        // Helper: Create stereo panner based on X position
        function createPositionalPanner(xPosition) {
            if (!audioCtx) return null;
            try {
                const panner = audioCtx.createStereoPanner();
                // Convert x position (0 to canvas.width) to pan value (-1 to 1)
                const canvasWidth = typeof canvas !== 'undefined' ? canvas.width : 800;
                const normalizedX = (xPosition / canvasWidth) * 2 - 1;
                // Clamp to valid range and reduce intensity slightly
                panner.pan.value = Math.max(-0.8, Math.min(0.8, normalizedX * 0.8));
                return panner;
            } catch (e) {
                return null;
            }
        }

        // Play explosion with positional audio
        function playPositionalExplosion(x, y, type = 'basic') {
            if (soundMuted || sfxVolume === 0) return;
            if (!ensureAudio()) return;
            try {
                const duration = type === 'boss' ? 0.6 : type === 'medium' ? 0.4 : 0.25;
                const freq = type === 'boss' ? 120 : type === 'medium' ? 180 : 250;
                const vol = Math.max(0.01, (type === 'boss' ? 0.4 : 0.3) * (sfxVolume / 100));

                // Create panner for positional audio
                const panner = createPositionalPanner(x);

                // Primary explosion noise
                const buffer = createNoiseBuffer(duration);
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;

                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(freq * 4, audioCtx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(freq * 0.5, audioCtx.currentTime + duration);

                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

                noise.connect(filter);
                filter.connect(gain);
                if (panner) {
                    gain.connect(panner);
                    panner.connect(audioCtx.destination);
                } else {
                    gain.connect(audioCtx.destination);
                }
                noise.start(audioCtx.currentTime);

                // Sub-bass thump (centered for impact)
                const subOsc = audioCtx.createOscillator();
                const subGain = audioCtx.createGain();
                subOsc.connect(subGain);
                subGain.connect(audioCtx.destination);

                subOsc.type = 'sine';
                subOsc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                subOsc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + duration * 0.5);

                subGain.gain.setValueAtTime(vol * 0.6, audioCtx.currentTime);
                subGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration * 0.5);

                subOsc.start(audioCtx.currentTime);
                subOsc.stop(audioCtx.currentTime + duration * 0.5);
            } catch (e) {}
        }

        // Play positional powerup collect sound
        function playPowerupSound(x) {
            if (soundMuted || sfxVolume === 0) return;
            if (!ensureAudio()) return;
            try {
                const vol = Math.max(0.01, 0.2 * (sfxVolume / 100));
                const panner = createPositionalPanner(x);

                // Ascending chime
                const notes = [880, 1100, 1320];
                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();

                    osc.connect(gain);
                    if (panner) {
                        gain.connect(panner);
                        panner.connect(audioCtx.destination);
                    } else {
                        gain.connect(audioCtx.destination);
                    }

                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(freq, audioCtx.currentTime + i * 0.06);

                    gain.gain.setValueAtTime(vol, audioCtx.currentTime + i * 0.06);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.06 + 0.15);

                    osc.start(audioCtx.currentTime + i * 0.06);
                    osc.stop(audioCtx.currentTime + i * 0.06 + 0.15);
                });

                // Sparkle
                for (let i = 0; i < 3; i++) {
                    const sparkle = audioCtx.createOscillator();
                    const sparkleGain = audioCtx.createGain();
                    sparkle.connect(sparkleGain);
                    if (panner) {
                        sparkleGain.connect(panner);
                    } else {
                        sparkleGain.connect(audioCtx.destination);
                    }

                    sparkle.type = 'sine';
                    sparkle.frequency.value = 2000 + Math.random() * 1500;

                    const startTime = audioCtx.currentTime + 0.1 + i * 0.05;
                    sparkleGain.gain.setValueAtTime(vol * 0.3, startTime);
                    sparkleGain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.1);

                    sparkle.start(startTime);
                    sparkle.stop(startTime + 0.1);
                }
            } catch (e) {}
        }

        // Play positional enemy shoot sound
        function playPositionalEnemyShoot(x) {
            if (soundMuted || sfxVolume === 0) return;
            if (!ensureAudio()) return;

            const now = Date.now();
            if (now - lastEnemyShootTime < 80) return;
            lastEnemyShootTime = now;

            try {
                const vol = Math.max(0.01, 0.08 * (sfxVolume / 100));
                const panner = createPositionalPanner(x);

                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.connect(gain);
                if (panner) {
                    gain.connect(panner);
                    panner.connect(audioCtx.destination);
                } else {
                    gain.connect(audioCtx.destination);
                }

                osc.type = 'sawtooth';
                const pitchVar = 0.9 + Math.random() * 0.2;
                osc.frequency.setValueAtTime(300 * pitchVar, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.08);

                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);

                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.08);
            } catch (e) {}
        }

        // Enhanced Sound effect: Enemy explosion with reverb-like tail
        function playExplosionSound(type = 'basic') {
            if (soundMuted || sfxVolume === 0) return;
            if (!ensureAudio()) return;
            try {
                const duration = type === 'boss' ? 0.6 : type === 'medium' ? 0.4 : 0.25;
                const freq = type === 'boss' ? 120 : type === 'medium' ? 180 : 250;
                const vol = Math.max(0.01, (type === 'boss' ? 0.4 : 0.3) * (sfxVolume / 100));

                // Primary explosion noise
                const buffer = createNoiseBuffer(duration);
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;

                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(freq * 4, audioCtx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(freq * 0.5, audioCtx.currentTime + duration);

                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(audioCtx.currentTime);

                // Sub-bass thump for impact
                const subOsc = audioCtx.createOscillator();
                const subGain = audioCtx.createGain();
                subOsc.connect(subGain);
                subGain.connect(audioCtx.destination);

                subOsc.type = 'sine';
                subOsc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                subOsc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + duration * 0.5);

                subGain.gain.setValueAtTime(vol * 0.8, audioCtx.currentTime);
                subGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration * 0.5);

                subOsc.start(audioCtx.currentTime);
                subOsc.stop(audioCtx.currentTime + duration * 0.5);

                // Metallic debris for larger explosions
                if (type === 'boss' || type === 'medium') {
                    setTimeout(() => {
                        if (!ensureAudio()) return;
                        const debris = audioCtx.createOscillator();
                        const debrisGain = audioCtx.createGain();
                        debris.connect(debrisGain);
                        debrisGain.connect(audioCtx.destination);

                        debris.type = 'square';
                        debris.frequency.setValueAtTime(800, audioCtx.currentTime);
                        debris.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.2);

                        debrisGain.gain.setValueAtTime(vol * 0.3, audioCtx.currentTime);
                        debrisGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);

                        debris.start(audioCtx.currentTime);
                        debris.stop(audioCtx.currentTime + 0.2);
                    }, 50);
                }
            } catch (e) {}
        }

        // Sound effect: Enemy hit (damage but not killed)
        function playEnemyHitSound() {
            if (soundMuted || sfxVolume === 0) return;
            if (!ensureAudio()) return;
            try {
                const vol = Math.max(0.01, 0.15 * (sfxVolume / 100));

                // Quick metallic ping
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.type = 'square';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.05);

                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);

                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.05);

                // Secondary hit confirmation
                const osc2 = audioCtx.createOscillator();
                const gain2 = audioCtx.createGain();

                osc2.connect(gain2);
                gain2.connect(audioCtx.destination);

                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(1200, audioCtx.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.03);

                gain2.gain.setValueAtTime(vol * 0.5, audioCtx.currentTime);
                gain2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.03);

                osc2.start(audioCtx.currentTime);
                osc2.stop(audioCtx.currentTime + 0.03);
            } catch (e) {}
        }

        // Enhanced Sound effect: Player hit with alarm
        function playPlayerHitSound() {
            if (soundMuted || sfxVolume === 0) return;
            if (!ensureAudio()) return;
            try {
                const vol = Math.max(0.01, 0.25 * (sfxVolume / 100));

                // Main impact
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const distortion = audioCtx.createWaveShaper();

                // Create distortion curve
                const curve = new Float32Array(256);
                for (let i = 0; i < 256; i++) {
                    const x = (i / 128) - 1;
                    curve[i] = Math.tanh(x * 2);
                }
                distortion.curve = curve;

                osc.connect(distortion);
                distortion.connect(gain);
                gain.connect(audioCtx.destination);

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(250, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.4);

                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);

                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.4);

                // Warning beeps
                for (let i = 0; i < 3; i++) {
                    const beep = audioCtx.createOscillator();
                    const beepGain = audioCtx.createGain();
                    beep.connect(beepGain);
                    beepGain.connect(audioCtx.destination);

                    beep.type = 'square';
                    beep.frequency.value = 800;

                    const startTime = audioCtx.currentTime + 0.1 + i * 0.12;
                    beepGain.gain.setValueAtTime(vol * 0.4, startTime);
                    beepGain.gain.setValueAtTime(0, startTime + 0.05);

                    beep.start(startTime);
                    beep.stop(startTime + 0.05);
                }
            } catch (e) { /* Silent fail */ }
        }

        // Enhanced Sound effect: Level up with triumphant fanfare
        function playLevelUpSound() {
            if (soundMuted || sfxVolume === 0) return;
            if (!ensureAudio()) return;
            try {
                const vol = Math.max(0.01, 0.2 * (sfxVolume / 100));
                const notes = [523, 659, 784, 1047, 1319]; // C5, E5, G5, C6, E6

                notes.forEach((freq, i) => {
                    // Main note
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();

                    osc.connect(gain);
                    gain.connect(audioCtx.destination);

                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(freq, audioCtx.currentTime + i * 0.08);

                    gain.gain.setValueAtTime(0, audioCtx.currentTime + i * 0.08);
                    gain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + i * 0.08 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.08 + 0.35);

                    osc.start(audioCtx.currentTime + i * 0.08);
                    osc.stop(audioCtx.currentTime + i * 0.08 + 0.35);

                    // Harmonic overtone
                    const harmonic = audioCtx.createOscillator();
                    const harmonicGain = audioCtx.createGain();

                    harmonic.connect(harmonicGain);
                    harmonicGain.connect(audioCtx.destination);

                    harmonic.type = 'triangle';
                    harmonic.frequency.setValueAtTime(freq * 2, audioCtx.currentTime + i * 0.08);

                    harmonicGain.gain.setValueAtTime(0, audioCtx.currentTime + i * 0.08);
                    harmonicGain.gain.linearRampToValueAtTime(vol * 0.3, audioCtx.currentTime + i * 0.08 + 0.02);
                    harmonicGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.08 + 0.25);

                    harmonic.start(audioCtx.currentTime + i * 0.08);
                    harmonic.stop(audioCtx.currentTime + i * 0.08 + 0.25);
                });

                // Final shimmer
                setTimeout(() => {
                    if (!ensureAudio()) return;
                    for (let i = 0; i < 5; i++) {
                        const shimmer = audioCtx.createOscillator();
                        const shimmerGain = audioCtx.createGain();
                        shimmer.connect(shimmerGain);
                        shimmerGain.connect(audioCtx.destination);

                        shimmer.type = 'sine';
                        shimmer.frequency.value = 2000 + Math.random() * 2000;

                        shimmerGain.gain.setValueAtTime(vol * 0.15, audioCtx.currentTime);
                        shimmerGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

                        shimmer.start(audioCtx.currentTime);
                        shimmer.stop(audioCtx.currentTime + 0.3);
                    }
                }, 400);
            } catch (e) { /* Silent fail */ }
        }

        // Enhanced Sound effect: Game over with dramatic descent
        function playGameOverSound() {
            if (soundMuted || sfxVolume === 0) return;
            if (!ensureAudio()) return;
            try {
                const vol = Math.max(0.01, 0.25 * (sfxVolume / 100));
                const notes = [392, 349, 330, 294, 262, 220]; // G4, F4, E4, D4, C4, A3

                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();

                    osc.connect(gain);
                    gain.connect(audioCtx.destination);

                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(freq, audioCtx.currentTime + i * 0.25);
                    osc.frequency.exponentialRampToValueAtTime(freq * 0.9, audioCtx.currentTime + i * 0.25 + 0.5);

                    gain.gain.setValueAtTime(vol, audioCtx.currentTime + i * 0.25);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.25 + 0.5);

                    osc.start(audioCtx.currentTime + i * 0.25);
                    osc.stop(audioCtx.currentTime + i * 0.25 + 0.5);
                });

                // Ominous sub-bass drone
                const drone = audioCtx.createOscillator();
                const droneGain = audioCtx.createGain();
                drone.connect(droneGain);
                droneGain.connect(audioCtx.destination);

                drone.type = 'sine';
                drone.frequency.setValueAtTime(80, audioCtx.currentTime);
                drone.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 2);

                droneGain.gain.setValueAtTime(vol * 0.5, audioCtx.currentTime);
                droneGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 2);

                drone.start(audioCtx.currentTime);
                drone.stop(audioCtx.currentTime + 2);
            } catch (e) { /* Silent fail */ }
        }

        // Sound effect: Enemy shooting (throttled)
        let lastEnemyShootTime = 0;
        function playEnemyShootSound() {
            if (soundMuted || sfxVolume === 0) return;
            if (!ensureAudio()) return;

            // Throttle to max once every 100ms
            const now = Date.now();
            if (now - lastEnemyShootTime < 100) return;
            lastEnemyShootTime = now;

            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);

                const vol = Math.max(0.01, 0.08 * (sfxVolume / 100));
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);

                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.15);
            } catch (e) {}
        }

        // Polyfill for roundRect (not supported in all browsers)
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }

        // Game state
        let gameRunning = false;
        let gamePaused = false;
        let soundMuted = false;
        let musicMuted = false;
        let score = 0;
        let lives = 3;
        let level = 1;
        let playerName = 'Gamer';
        let gameStartTime = 0;

        // ========================================
        // CENTRALIZED UI STATE MANAGEMENT
        // ========================================
        // Possible states: 'loading', 'splash', 'menu', 'playing', 'paused', 'gameover', 'garage', 'stats', 'tutorial'
        let currentUIState = 'loading';

        // All screen element IDs mapped to their states
        const UI_SCREENS = {
            loading: 'loadingScreen',
            splash: 'splashScreen',
            menu: 'startScreen',
            gameover: 'gameOverScreen',
            paused: 'pauseScreen',
            garage: 'garageScreen',
            stats: 'statsScreen',
            tutorial: 'tutorialOverlay'
        };

        // Elements that should be hidden when not playing
        const IN_GAME_ELEMENTS = [
            'bossHealth',
            'powerupIndicator',
            'endlessTimer',
            'endlessWave',
            'bossRushDisplay',
            'demoOverlay'
        ];

        /**
         * Set the current UI state and update all screen visibility
         * @param {string} newState - The new UI state
         * @param {Object} options - Additional options
         */
        function setUIState(newState, options = {}) {
            currentUIState = newState;

            // Update body class for CSS state-based styling
            document.body.className = document.body.className
                .replace(/state-\w+/g, '')
                .trim();
            document.body.classList.add(`state-${newState}`);

            // Hide all main screens first
            Object.entries(UI_SCREENS).forEach(([state, elementId]) => {
                const element = document.getElementById(elementId);
                if (element) {
                    if (state === newState) {
                        element.classList.remove('hidden');
                    } else if (state !== 'loading' && state !== 'splash') {
                        // Don't hide loading/splash via this - they have their own logic
                        element.classList.add('hidden');
                    }
                }
            });

            // Handle in-game elements visibility
            const showInGameElements = ['playing', 'paused'].includes(newState);
            IN_GAME_ELEMENTS.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element && !showInGameElements) {
                    element.classList.add('hidden');
                }
            });

            // Handle mobile controls
            const mobileControls = document.getElementById('mobileControls');
            if (mobileControls) {
                mobileControls.style.display = (newState === 'playing') ? 'flex' : 'none';
            }

            // Sync gameRunning and gamePaused with UI state
            if (newState === 'playing') {
                gameRunning = true;
                gamePaused = false;
            } else if (newState === 'paused') {
                gamePaused = true;
            } else if (['menu', 'gameover', 'garage', 'stats'].includes(newState)) {
                gameRunning = false;
                gamePaused = false;
            }
        }

        /**
         * Get the current UI state
         * @returns {string} The current UI state
         */
        function getUIState() {
            return currentUIState;
        }

        /**
         * Check if we're in a specific UI state
         * @param {string} state - The state to check
         * @returns {boolean}
         */
        function isUIState(state) {
            return currentUIState === state;
        }

        // Difficulty settings
        let currentDifficulty = 'normal';
        const DIFFICULTY_SETTINGS = {
            easy: {
                name: 'Easy',
                enemySpeedMultiplier: 0.7,
                enemyFireRateMultiplier: 0.5,
                enemyHealthMultiplier: 0.8,
                playerLives: 5,
                scoreMultiplier: 0.5,
                coinMultiplier: 0.5,
                powerupChance: 1.5,
                bossHealthMultiplier: 0.7
            },
            normal: {
                name: 'Normal',
                enemySpeedMultiplier: 1.0,
                enemyFireRateMultiplier: 1.0,
                enemyHealthMultiplier: 1.0,
                playerLives: 3,
                scoreMultiplier: 1.0,
                coinMultiplier: 1.0,
                powerupChance: 1.0,
                bossHealthMultiplier: 1.0
            },
            hard: {
                name: 'Hard',
                enemySpeedMultiplier: 1.3,
                enemyFireRateMultiplier: 1.5,
                enemyHealthMultiplier: 1.3,
                playerLives: 2,
                scoreMultiplier: 1.5,
                coinMultiplier: 1.5,
                powerupChance: 0.7,
                bossHealthMultiplier: 1.3
            },
            nightmare: {
                name: 'Nightmare',
                enemySpeedMultiplier: 1.6,
                enemyFireRateMultiplier: 2.0,
                enemyHealthMultiplier: 1.5,
                playerLives: 1,
                scoreMultiplier: 2.5,
                coinMultiplier: 2.5,
                powerupChance: 0.4,
                bossHealthMultiplier: 1.6
            }
        };

        function getDifficulty() {
            return DIFFICULTY_SETTINGS[currentDifficulty];
        }

        function addScore(points) {
            const diff = getDifficulty();
            score += Math.round(points * diff.scoreMultiplier);
        }

        function setDifficulty(diff) {
            currentDifficulty = diff;
            // Update UI
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.difficulty-btn.${diff}`).classList.add('active');
            // Save preference
            localStorage.setItem('gameDifficulty', diff);
            playSelectSound();
        }

        function loadDifficultySetting() {
            const saved = localStorage.getItem('gameDifficulty');
            if (saved && DIFFICULTY_SETTINGS[saved]) {
                currentDifficulty = saved;
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                const btn = document.querySelector(`.difficulty-btn.${saved}`);
                if (btn) btn.classList.add('active');
            }
        }

        // Menu tab switching
        function switchMenuTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.menu-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.menu-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const tabContent = document.getElementById('tab-' + tabName);
            if (tabContent) {
                tabContent.classList.add('active');
            }

            playSelectSound();
        }

        // Volume settings (0-100)
        let sfxVolume = 100;
        let musicVolumeLevel = 100;
        let announcerVolume = 100;
        let settingsOpen = false;

        // Load saved volume settings
        function loadVolumeSettings() {
            const saved = localStorage.getItem('spaceInvadersVolume');
            if (saved) {
                const settings = JSON.parse(saved);
                sfxVolume = settings.sfx ?? 100;
                musicVolumeLevel = settings.music ?? 100;
                announcerVolume = settings.announcer ?? 100;

                // Update UI sliders
                document.getElementById('sfxVolume').value = sfxVolume;
                document.getElementById('musicVolume').value = musicVolumeLevel;
                document.getElementById('announcerVolume').value = announcerVolume;
                document.getElementById('sfxValue').textContent = sfxVolume + '%';
                document.getElementById('musicValue').textContent = musicVolumeLevel + '%';
                document.getElementById('announcerValue').textContent = announcerVolume + '%';
            }
        }

        // Save volume settings
        function saveVolumeSettings() {
            localStorage.setItem('spaceInvadersVolume', JSON.stringify({
                sfx: sfxVolume,
                music: musicVolumeLevel,
                announcer: announcerVolume
            }));
        }

        // Update volume from slider
        function updateVolume(type, value) {
            value = parseInt(value);
            if (type === 'sfx') {
                sfxVolume = value;
                document.getElementById('sfxValue').textContent = value + '%';
            } else if (type === 'music') {
                musicVolumeLevel = value;
                document.getElementById('musicValue').textContent = value + '%';
                // Update music gain in real-time
                if (musicGain) {
                    musicGain.gain.setValueAtTime(0.08 * (value / 100), audioCtx.currentTime);
                }
            } else if (type === 'announcer') {
                announcerVolume = value;
                document.getElementById('announcerValue').textContent = value + '%';
            }
            saveVolumeSettings();
        }

        // Toggle settings panel
        function toggleSettings() {
            settingsOpen = !settingsOpen;
            document.getElementById('settingsPanel').classList.toggle('hidden', !settingsOpen);
        }

        // Share game with friends
        function shareGame() {
            const shareData = {
                title: 'Cosmic Blasterz',
                text: 'Play Cosmic Blasterz - Defend Earth from the alien invasion!',
                url: 'https://mricebird.github.io/cosmic-blasterz/'
            };

            if (navigator.share) {
                navigator.share(shareData).catch(() => {
                    copyToClipboard(shareData.url);
                });
            } else {
                copyToClipboard(shareData.url);
            }
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showShareToast('Link copied to clipboard!');
            }).catch(() => {
                showShareToast('Share: ' + text);
            });
        }

        function showShareToast(message) {
            const existingToast = document.querySelector('.share-toast');
            if (existingToast) existingToast.remove();

            const toast = document.createElement('div');
            toast.className = 'share-toast';
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transition = 'opacity 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 2500);
        }

        // Invite Friend functions
        const GAME_URL = 'https://mricebird.github.io/cosmic-blasterz/';
        const INVITE_MESSAGE = ' Join me in Cosmic Blasterz! Defend Earth from alien invasion in this epic retro arcade shooter!';

        function openInviteModal() {
            document.getElementById('inviteModal').classList.remove('hidden');
            // Try native share API first on mobile
            if (navigator.share) {
                navigator.share({
                    title: 'Cosmic Blasterz',
                    text: INVITE_MESSAGE,
                    url: GAME_URL
                }).then(() => {
                    closeInviteModal();
                }).catch(() => {
                    // User cancelled or not supported, show modal
                });
            }
        }

        function closeInviteModal() {
            document.getElementById('inviteModal').classList.add('hidden');
        }

        function inviteViaTwitter() {
            const text = encodeURIComponent(INVITE_MESSAGE + ' ');
            const url = encodeURIComponent(GAME_URL);
            window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`, '_blank', 'width=600,height=400');
            closeInviteModal();
        }

        function inviteViaFacebook() {
            const url = encodeURIComponent(GAME_URL);
            window.open(`https://www.facebook.com/sharer/sharer.php?u=${url}`, '_blank', 'width=600,height=400');
            closeInviteModal();
        }

        function inviteViaWhatsApp() {
            const text = encodeURIComponent(INVITE_MESSAGE + ' ' + GAME_URL);
            window.open(`https://wa.me/?text=${text}`, '_blank');
            closeInviteModal();
        }

        function copyInviteLink() {
            const fullMessage = INVITE_MESSAGE + '\n' + GAME_URL;
            navigator.clipboard.writeText(fullMessage).then(() => {
                showShareToast(' Invite link copied!');
                closeInviteModal();
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = fullMessage;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showShareToast(' Invite link copied!');
                closeInviteModal();
            });
        }

        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('inviteModal');
            if (e.target === modal) {
                closeInviteModal();
            }
        });

        // Exit AI demo mode on canvas click
        canvas.addEventListener('click', (e) => {
            if (aiDemoMode && gameRunning) {
                handleDemoExit(e);
            }
        });

        // Screen size presets
        const SCREEN_SIZES = {
            small: { width: 800, height: 560 },
            medium: { width: 1000, height: 700 },
            large: { width: 1200, height: 840 },
            xlarge: { width: 1400, height: 980 }
        };
        let currentScreenSize = 'medium';

        function setScreenSize(size) {
            if (!SCREEN_SIZES[size]) return;

            currentScreenSize = size;
            const { width, height } = SCREEN_SIZES[size];

            canvas.width = width;
            canvas.height = height;

            // Update active button
            document.querySelectorAll('.size-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            // Reposition player
            if (player) {
                player.x = Math.min(player.x, canvas.width - player.width);
                player.y = canvas.height - 70;
            }

            // Reinitialize background elements
            initBackground();

            // Save preference
            localStorage.setItem('spaceInvadersScreenSize', size);
        }

        // Load saved screen size
        function loadScreenSize() {
            const saved = localStorage.getItem('spaceInvadersScreenSize');
            if (saved && SCREEN_SIZES[saved]) {
                currentScreenSize = saved;
                const { width, height } = SCREEN_SIZES[saved];
                canvas.width = width;
                canvas.height = height;

                // Update active button
                document.querySelectorAll('.size-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.textContent === saved[0].toUpperCase() ||
                        (saved === 'xlarge' && btn.textContent === 'XL') ||
                        (saved === 'small' && btn.textContent === 'S') ||
                        (saved === 'medium' && btn.textContent === 'M') ||
                        (saved === 'large' && btn.textContent === 'L'));
                });
            }
        }

        // Ambient Space Sound System
        let ambientPlaying = false;
        let ambientGain = null;
        let ambientInterval = null;
        let spaceHumOsc = null;

        function initAmbientSounds() {
            if (ambientPlaying) return;
            if (!ensureAudio()) return;
            if (soundMuted || sfxVolume === 0) return;

            ambientPlaying = true;

            // Create master gain for ambient sounds
            ambientGain = audioCtx.createGain();
            const ambientVol = Math.max(0.01, 0.03 * (sfxVolume / 100));
            ambientGain.gain.setValueAtTime(ambientVol, audioCtx.currentTime);
            ambientGain.connect(audioCtx.destination);

            // Start continuous space hum (low frequency drone)
            startSpaceHum();

            // Start random cosmic sounds
            ambientInterval = setInterval(() => {
                if (!ambientPlaying || soundMuted) return;
                playRandomCosmicSound();
            }, 4000 + Math.random() * 6000);
        }

        function startSpaceHum() {
            if (!ensureAudio() || !ambientGain) return;

            try {
                // Create layered space hum
                spaceHumOsc = [];

                // Deep sub-bass drone
                const subDrone = audioCtx.createOscillator();
                const subGain = audioCtx.createGain();
                subDrone.type = 'sine';
                subDrone.frequency.value = 40;
                subGain.gain.value = 0.3;
                subDrone.connect(subGain);
                subGain.connect(ambientGain);
                subDrone.start();
                spaceHumOsc.push({ osc: subDrone, gain: subGain });

                // Modulated mid-frequency hum
                const midDrone = audioCtx.createOscillator();
                const midGain = audioCtx.createGain();
                const lfo = audioCtx.createOscillator();
                const lfoGain = audioCtx.createGain();

                lfo.type = 'sine';
                lfo.frequency.value = 0.1;
                lfoGain.gain.value = 5;
                lfo.connect(lfoGain);
                lfoGain.connect(midDrone.frequency);

                midDrone.type = 'sine';
                midDrone.frequency.value = 80;
                midGain.gain.value = 0.15;
                midDrone.connect(midGain);
                midGain.connect(ambientGain);
                lfo.start();
                midDrone.start();
                spaceHumOsc.push({ osc: midDrone, gain: midGain, lfo: lfo });

                // High frequency shimmer
                const shimmer = audioCtx.createOscillator();
                const shimmerGain = audioCtx.createGain();
                const shimmerLfo = audioCtx.createOscillator();
                const shimmerLfoGain = audioCtx.createGain();

                shimmerLfo.type = 'sine';
                shimmerLfo.frequency.value = 0.05;
                shimmerLfoGain.gain.value = 0.08;
                shimmerLfo.connect(shimmerLfoGain);
                shimmerLfoGain.connect(shimmerGain.gain);

                shimmer.type = 'sine';
                shimmer.frequency.value = 2000;
                shimmerGain.gain.value = 0.02;
                shimmer.connect(shimmerGain);
                shimmerGain.connect(ambientGain);
                shimmerLfo.start();
                shimmer.start();
                spaceHumOsc.push({ osc: shimmer, gain: shimmerGain, lfo: shimmerLfo });

            } catch (e) { /* Silent fail */ }
        }

        function playRandomCosmicSound() {
            if (!ensureAudio() || !ambientGain || soundMuted) return;

            const soundType = Math.floor(Math.random() * 5);

            try {
                if (soundType === 0) {
                    // Distant rumble
                    const rumbleBuffer = createNoiseBuffer(2);
                    const rumble = audioCtx.createBufferSource();
                    rumble.buffer = rumbleBuffer;

                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 100;

                    const gain = audioCtx.createGain();
                    gain.gain.setValueAtTime(0, audioCtx.currentTime);
                    gain.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.5);
                    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 2);

                    rumble.connect(filter);
                    filter.connect(gain);
                    gain.connect(ambientGain);
                    rumble.start(audioCtx.currentTime);

                } else if (soundType === 1) {
                    // Cosmic ping
                    const ping = audioCtx.createOscillator();
                    const pingGain = audioCtx.createGain();

                    ping.type = 'sine';
                    ping.frequency.value = 1000 + Math.random() * 2000;

                    pingGain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    pingGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.5);

                    ping.connect(pingGain);
                    pingGain.connect(ambientGain);
                    ping.start(audioCtx.currentTime);
                    ping.stop(audioCtx.currentTime + 1.5);

                } else if (soundType === 2) {
                    // Ethereal sweep
                    const sweep = audioCtx.createOscillator();
                    const sweepGain = audioCtx.createGain();

                    sweep.type = 'sine';
                    sweep.frequency.setValueAtTime(200, audioCtx.currentTime);
                    sweep.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 1);
                    sweep.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 2);

                    sweepGain.gain.setValueAtTime(0, audioCtx.currentTime);
                    sweepGain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.5);
                    sweepGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 2);

                    sweep.connect(sweepGain);
                    sweepGain.connect(ambientGain);
                    sweep.start(audioCtx.currentTime);
                    sweep.stop(audioCtx.currentTime + 2);

                } else if (soundType === 3) {
                    // Digital glitch
                    for (let i = 0; i < 3; i++) {
                        const glitch = audioCtx.createOscillator();
                        const glitchGain = audioCtx.createGain();

                        glitch.type = 'square';
                        glitch.frequency.value = 100 + Math.random() * 400;

                        const startTime = audioCtx.currentTime + i * 0.08;
                        glitchGain.gain.setValueAtTime(0.15, startTime);
                        glitchGain.gain.setValueAtTime(0, startTime + 0.03);

                        glitch.connect(glitchGain);
                        glitchGain.connect(ambientGain);
                        glitch.start(startTime);
                        glitch.stop(startTime + 0.03);
                    }

                } else {
                    // Distant beacon
                    const beacon = audioCtx.createOscillator();
                    const beaconGain = audioCtx.createGain();

                    beacon.type = 'triangle';
                    beacon.frequency.value = 600;

                    for (let i = 0; i < 3; i++) {
                        const t = audioCtx.currentTime + i * 0.5;
                        beaconGain.gain.setValueAtTime(0.1, t);
                        beaconGain.gain.setValueAtTime(0, t + 0.1);
                    }

                    beacon.connect(beaconGain);
                    beaconGain.connect(ambientGain);
                    beacon.start(audioCtx.currentTime);
                    beacon.stop(audioCtx.currentTime + 1.5);
                }
            } catch (e) {}
        }

        function stopAmbientSounds() {
            ambientPlaying = false;

            if (ambientInterval) {
                clearInterval(ambientInterval);
                ambientInterval = null;
            }

            if (spaceHumOsc) {
                spaceHumOsc.forEach(item => {
                    try {
                        if (item.osc) item.osc.stop();
                        if (item.lfo) item.lfo.stop();
                    } catch (e) {}
                });
                spaceHumOsc = null;
            }
        }

        function updateAmbientVolume() {
            if (ambientGain && audioCtx) {
                const ambientVol = soundMuted ? 0 : Math.max(0.01, 0.03 * (sfxVolume / 100));
                ambientGain.gain.setValueAtTime(ambientVol, audioCtx.currentTime);
            }
        }

        // Background music system
        // ==========================================
        // AMIGA-STYLE TRACKER MUSIC SYSTEM
        // ==========================================
        let musicGain = null;
        let musicPlaying = false;
        let musicPattern = 0;
        let musicRow = 0;
        let musicTimerId = null;
        const MUSIC_BPM = 125;
        const ROWS_PER_BEAT = 4;
        const ROW_TIME = (60000 / MUSIC_BPM) / ROWS_PER_BEAT;

        // ==========================================
        // DYNAMIC MUSIC SYSTEM
        // ==========================================
        let musicIntensity = 0; // 0-100
        let musicFilterNode = null;
        let musicTargetIntensity = 0;

        function updateMusicIntensity() {
            // Calculate music intensity based on game state
            let intensity = 0;

            // Base intensity from level
            intensity += Math.min(level * 3, 30);

            // High combo increases intensity
            if (comboCount >= 3) intensity += 15;
            if (comboCount >= 5) intensity += 15;
            if (comboCount >= 10) intensity += 20;

            // Low health increases tension
            if (lives === 1) intensity += 30;
            if (lives === 2) intensity += 15;

            // Boss fight maxes intensity
            if (currentBoss) intensity = 100;

            // Enemy proximity increases tension
            const lowestEnemy = enemies.reduce((lowest, e) =>
                e.y + e.height > lowest ? e.y + e.height : lowest, 0);
            if (lowestEnemy > canvas.height * 0.6) intensity += 20;
            if (lowestEnemy > canvas.height * 0.75) intensity += 20;

            // Bullet time reduces intensity for dramatic effect
            if (bulletTimeActive) intensity = 20;

            musicTargetIntensity = Math.min(intensity, 100);

            // Smoothly interpolate to target
            musicIntensity += (musicTargetIntensity - musicIntensity) * 0.1;

            // Update filter if exists (creates tension through filter sweep)
            if (musicFilterNode && audioCtx) {
                const baseFreq = 800;
                const maxFreq = 4000;
                const filterFreq = baseFreq + (musicIntensity / 100) * (maxFreq - baseFreq);
                musicFilterNode.frequency.setTargetAtTime(filterFreq, audioCtx.currentTime, 0.1);
            }
        }

        function getMusicTempoMultiplier() {
            // Tempo speeds up slightly with intensity
            if (bossMode) return 0.8; // Boss always fast
            if (bulletTimeActive) return 1.5; // Slow music during bullet time
            // Subtle tempo increase: 1.0 at 0 intensity, 0.9 at 100 intensity
            return 1.0 - (musicIntensity / 100) * 0.1;
        }

        // Note frequencies (Amiga style - A4 = 440Hz)
        const NOTE = {
            C2: 65.41, D2: 73.42, E2: 82.41, F2: 87.31, G2: 98.00, A2: 110.0, B2: 123.5,
            C3: 130.8, D3: 146.8, E3: 164.8, F3: 174.6, G3: 196.0, A3: 220.0, B3: 246.9,
            C4: 261.6, D4: 293.7, E4: 329.6, F4: 349.2, G4: 392.0, A4: 440.0, B4: 493.9,
            C5: 523.3, D5: 587.3, E5: 659.3, F5: 698.5, G5: 784.0, A5: 880.0, B5: 987.8,
            C6: 1047, D6: 1175, E6: 1319, REST: 0
        };

        // Amiga-style patterns (each pattern = 16 rows)
        // Format: [bass, lead, arpeggio, drum]
        const PATTERNS = [
            // Pattern 0: Main theme intro
            [
                [NOTE.A2, NOTE.E4, NOTE.A4, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.C5, 'H'],
                [NOTE.A2, NOTE.REST, NOTE.E5, 'H'],
                [NOTE.REST, NOTE.E4, NOTE.A4, 'H'],
                [NOTE.A2, NOTE.REST, NOTE.C5, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.E5, 'H'],
                [NOTE.G2, NOTE.D4, NOTE.A4, 'H'],
                [NOTE.REST, NOTE.REST, NOTE.C5, 'S'],
                [NOTE.F2, NOTE.C4, NOTE.E5, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.A4, 'H'],
                [NOTE.F2, NOTE.REST, NOTE.C5, 'H'],
                [NOTE.REST, NOTE.C4, NOTE.E5, 'H'],
                [NOTE.G2, NOTE.D4, NOTE.A4, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.C5, 'H'],
                [NOTE.G2, NOTE.REST, NOTE.E5, 'H'],
                [NOTE.REST, NOTE.B3, NOTE.G4, 'S'],
            ],
            // Pattern 1: Build up
            [
                [NOTE.A2, NOTE.A4, NOTE.E5, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.A5, 'H'],
                [NOTE.A2, NOTE.REST, NOTE.E5, 'H'],
                [NOTE.REST, NOTE.A4, NOTE.A5, 'H'],
                [NOTE.C3, NOTE.C5, NOTE.E5, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.G5, 'H'],
                [NOTE.C3, NOTE.REST, NOTE.E5, 'H'],
                [NOTE.REST, NOTE.E4, NOTE.G5, 'S'],
                [NOTE.D3, NOTE.D5, NOTE.F5, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.A5, 'H'],
                [NOTE.D3, NOTE.REST, NOTE.F5, 'H'],
                [NOTE.REST, NOTE.D5, NOTE.A5, 'H'],
                [NOTE.E3, NOTE.E5, NOTE.G5, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.B5, 'H'],
                [NOTE.E3, NOTE.REST, NOTE.G5, 'H'],
                [NOTE.REST, NOTE.G4, NOTE.B5, 'S'],
            ],
            // Pattern 2: Chorus (energetic)
            [
                [NOTE.A2, NOTE.E5, NOTE.A5, 'K'],
                [NOTE.A3, NOTE.REST, NOTE.E5, 'H'],
                [NOTE.A2, NOTE.E5, NOTE.A5, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.E5, 'H'],
                [NOTE.G2, NOTE.D5, NOTE.G5, 'K'],
                [NOTE.G3, NOTE.REST, NOTE.D5, 'H'],
                [NOTE.G2, NOTE.D5, NOTE.G5, 'H'],
                [NOTE.REST, NOTE.REST, NOTE.B4, 'S'],
                [NOTE.F2, NOTE.C5, NOTE.F5, 'K'],
                [NOTE.F3, NOTE.REST, NOTE.C5, 'H'],
                [NOTE.F2, NOTE.C5, NOTE.F5, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.A4, 'H'],
                [NOTE.E2, NOTE.B4, NOTE.E5, 'K'],
                [NOTE.E3, NOTE.REST, NOTE.B4, 'H'],
                [NOTE.E2, NOTE.G4, NOTE.B4, 'H'],
                [NOTE.REST, NOTE.E4, NOTE.G4, 'S'],
            ],
            // Pattern 3: Breakdown
            [
                [NOTE.A2, NOTE.REST, NOTE.A4, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.C5, 'R'],
                [NOTE.REST, NOTE.REST, NOTE.E5, 'R'],
                [NOTE.REST, NOTE.A4, NOTE.A5, 'H'],
                [NOTE.REST, NOTE.REST, NOTE.E5, 'R'],
                [NOTE.REST, NOTE.REST, NOTE.C5, 'R'],
                [NOTE.G2, NOTE.REST, NOTE.A4, 'K'],
                [NOTE.REST, NOTE.G4, NOTE.B4, 'S'],
                [NOTE.F2, NOTE.REST, NOTE.A4, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.C5, 'R'],
                [NOTE.REST, NOTE.REST, NOTE.F5, 'R'],
                [NOTE.REST, NOTE.C5, NOTE.A5, 'H'],
                [NOTE.E2, NOTE.REST, NOTE.F5, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.C5, 'R'],
                [NOTE.REST, NOTE.B4, NOTE.A4, 'H'],
                [NOTE.REST, NOTE.G4, NOTE.E4, 'S'],
            ],
        ];

        // Pattern sequence for full song
        const SONG = [0, 0, 1, 1, 2, 2, 3, 1, 2, 2, 3, 3];

        function initMusic() {
            if (musicPlaying) return;
            if (!ensureAudio()) return;

            musicPlaying = true;
            musicPattern = 0;
            musicRow = 0;
            musicIntensity = 0;

            // Create dynamic music filter for intensity control
            musicFilterNode = audioCtx.createBiquadFilter();
            musicFilterNode.type = 'lowpass';
            musicFilterNode.frequency.value = 800;
            musicFilterNode.Q.value = 1;

            // Create master gain for music
            musicGain = audioCtx.createGain();
            const musicVol = Math.max(0.01, 0.12 * (musicVolumeLevel / 100));
            musicGain.gain.setValueAtTime(musicVol, audioCtx.currentTime);

            // Route through filter for dynamic control
            musicGain.connect(musicFilterNode);
            musicFilterNode.connect(audioCtx.destination);

            playMusicRow();
        }

        // Play bass with classic Amiga punch
        function playBass(freq, time) {
            if (freq === 0) return;
            const osc = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            // Detuned oscillators for fat sound
            osc.type = 'sawtooth';
            osc2.type = 'square';
            osc.frequency.setValueAtTime(freq, time);
            osc2.frequency.setValueAtTime(freq * 1.002, time);

            // Filter sweep for punch
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800, time);
            filter.frequency.exponentialRampToValueAtTime(200, time + 0.1);
            filter.Q.value = 2;

            gain.gain.setValueAtTime(0.25, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);

            osc.connect(filter);
            osc2.connect(filter);
            filter.connect(gain);
            gain.connect(musicGain);

            osc.start(time);
            osc2.start(time);
            osc.stop(time + 0.25);
            osc2.stop(time + 0.25);
        }

        // Play lead with PWM-style sound
        function playLead(freq, time) {
            if (freq === 0) return;
            const osc = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            // Two slightly detuned square waves for PWM effect
            osc.type = 'square';
            osc2.type = 'square';
            osc.frequency.setValueAtTime(freq, time);
            osc2.frequency.setValueAtTime(freq * 1.005, time);

            // Vibrato
            const lfo = audioCtx.createOscillator();
            const lfoGain = audioCtx.createGain();
            lfo.frequency.value = 5;
            lfoGain.gain.value = 3;
            lfo.connect(lfoGain);
            lfoGain.connect(osc.frequency);
            lfo.start(time);
            lfo.stop(time + 0.3);

            gain.gain.setValueAtTime(0.08, time);
            gain.gain.setValueAtTime(0.06, time + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.25);

            osc.connect(gain);
            osc2.connect(gain);
            gain.connect(musicGain);

            osc.start(time);
            osc2.start(time);
            osc.stop(time + 0.3);
            osc2.stop(time + 0.3);
        }

        // Play arpeggio (classic Amiga effect)
        function playArpeggio(freq, time) {
            if (freq === 0) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = 'square';
            osc.frequency.setValueAtTime(freq, time);

            gain.gain.setValueAtTime(0.04, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.08);

            osc.connect(gain);
            gain.connect(musicGain);

            osc.start(time);
            osc.stop(time + 0.1);
        }

        // Play drums
        function playDrum(type, time) {
            if (type === 'K') {
                // Kick drum
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(40, time + 0.08);
                gain.gain.setValueAtTime(0.4, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
                osc.connect(gain);
                gain.connect(musicGain);
                osc.start(time);
                osc.stop(time + 0.2);
            } else if (type === 'S') {
                // Snare
                const noise = audioCtx.createBufferSource();
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.1, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = buffer;

                const noiseGain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1000;
                noiseGain.gain.setValueAtTime(0.15, time);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                noise.connect(filter);
                filter.connect(noiseGain);
                noiseGain.connect(musicGain);
                noise.start(time);

                // Tonal part
                const osc = audioCtx.createOscillator();
                const oscGain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, time);
                osc.frequency.exponentialRampToValueAtTime(100, time + 0.05);
                oscGain.gain.setValueAtTime(0.15, time);
                oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.08);
                osc.connect(oscGain);
                oscGain.connect(musicGain);
                osc.start(time);
                osc.stop(time + 0.1);
            } else if (type === 'H') {
                // Hi-hat
                const noise = audioCtx.createBufferSource();
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.05, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = buffer;

                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 7000;
                gain.gain.setValueAtTime(0.06, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.04);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(musicGain);
                noise.start(time);
            } else if (type === 'R') {
                // Rest / ghost note
            }
        }

        function playMusicRow() {
            if (!musicPlaying || musicMuted) return;
            if (!ensureAudio()) return;

            const time = audioCtx.currentTime;

            // Use boss patterns if in boss mode
            let patternIndex, pattern;
            if (bossMode) {
                patternIndex = BOSS_SONG[musicPattern % BOSS_SONG.length];
                pattern = BOSS_PATTERNS[patternIndex];
            } else {
                patternIndex = SONG[musicPattern % SONG.length];
                pattern = PATTERNS[patternIndex];
            }
            const row = pattern[musicRow];

            // Play all channels
            playBass(row[0], time);
            playLead(row[1], time);
            playArpeggio(row[2], time);
            playDrum(row[3], time);

            // Advance row
            musicRow++;
            if (musicRow >= 16) {
                musicRow = 0;
                musicPattern++;
            }

            // Schedule next row with dynamic tempo
            const rowTime = ROW_TIME * getMusicTempoMultiplier();
            if (musicPlaying && !musicMuted) {
                musicTimerId = setTimeout(playMusicRow, rowTime);
            }
        }

        function stopMusic() {
            musicPlaying = false;
            if (musicTimerId) {
                clearTimeout(musicTimerId);
                musicTimerId = null;
            }
        }

        function toggleMusic() {
            musicMuted = !musicMuted;
            document.getElementById('musicBtn').textContent = musicMuted ? '' : '';
            if (!musicMuted && gameRunning && !gamePaused) {
                playMusicRow();
            }
        }

        // Boss battle music - more intense patterns
        let bossMode = false;
        const BOSS_PATTERNS = [
            // Intense boss pattern 1
            [
                [NOTE.E2, NOTE.E5, NOTE.B5, 'K'],
                [NOTE.E3, NOTE.REST, NOTE.E5, 'H'],
                [NOTE.E2, NOTE.E5, NOTE.B5, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.E5, 'H'],
                [NOTE.E2, NOTE.G5, NOTE.B5, 'K'],
                [NOTE.E3, NOTE.REST, NOTE.G5, 'H'],
                [NOTE.E2, NOTE.REST, NOTE.E5, 'S'],
                [NOTE.REST, NOTE.E5, NOTE.B5, 'H'],
                [NOTE.D2, NOTE.D5, NOTE.A5, 'K'],
                [NOTE.D3, NOTE.REST, NOTE.D5, 'H'],
                [NOTE.D2, NOTE.D5, NOTE.A5, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.F5, 'H'],
                [NOTE.C2, NOTE.C5, NOTE.G5, 'K'],
                [NOTE.C3, NOTE.REST, NOTE.E5, 'H'],
                [NOTE.B2, NOTE.B4, NOTE.F5, 'K'],
                [NOTE.REST, NOTE.G4, NOTE.E5, 'S'],
            ],
            // Intense boss pattern 2
            [
                [NOTE.A2, NOTE.A5, NOTE.E6, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.A5, 'H'],
                [NOTE.A2, NOTE.A5, NOTE.E6, 'K'],
                [NOTE.A3, NOTE.REST, NOTE.A5, 'H'],
                [NOTE.G2, NOTE.G5, NOTE.D6, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.G5, 'H'],
                [NOTE.G2, NOTE.G5, NOTE.D6, 'S'],
                [NOTE.G3, NOTE.REST, NOTE.B5, 'H'],
                [NOTE.F2, NOTE.F5, NOTE.C6, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.F5, 'H'],
                [NOTE.F2, NOTE.F5, NOTE.C6, 'K'],
                [NOTE.F3, NOTE.REST, NOTE.A5, 'H'],
                [NOTE.E2, NOTE.E5, NOTE.B5, 'K'],
                [NOTE.REST, NOTE.REST, NOTE.E5, 'H'],
                [NOTE.E2, NOTE.G5, NOTE.B5, 'K'],
                [NOTE.E3, NOTE.E5, NOTE.G5, 'S'],
            ],
        ];

        const BOSS_SONG = [0, 0, 1, 1, 0, 1, 0, 1];

        function startBossMusic() {
            bossMode = true;
            musicPattern = 0;
            musicRow = 0;
        }

        function stopBossMusic() {
            bossMode = false;
            musicPattern = 0;
            musicRow = 0;
        }

        // Victory fanfare (level complete)
        function playVictoryFanfare() {
            if (!ensureAudio() || musicMuted) return;

            const time = audioCtx.currentTime;
            const fanfareGain = audioCtx.createGain();
            fanfareGain.gain.setValueAtTime(0.15 * (musicVolumeLevel / 100), time);
            fanfareGain.connect(audioCtx.destination);

            // Victory melody notes
            const notes = [
                { freq: NOTE.C5, time: 0, dur: 0.15 },
                { freq: NOTE.E5, time: 0.15, dur: 0.15 },
                { freq: NOTE.G5, time: 0.3, dur: 0.15 },
                { freq: NOTE.C6, time: 0.45, dur: 0.4 },
                { freq: NOTE.G5, time: 0.65, dur: 0.15 },
                { freq: NOTE.C6, time: 0.8, dur: 0.6 },
            ];

            notes.forEach(note => {
                const osc = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.type = 'square';
                osc2.type = 'sawtooth';
                osc.frequency.value = note.freq;
                osc2.frequency.value = note.freq * 1.002;

                gain.gain.setValueAtTime(0.2, time + note.time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + note.time + note.dur);

                osc.connect(gain);
                osc2.connect(gain);
                gain.connect(fanfareGain);

                osc.start(time + note.time);
                osc2.start(time + note.time);
                osc.stop(time + note.time + note.dur + 0.1);
                osc2.stop(time + note.time + note.dur + 0.1);
            });

            // Triumphant chord at the end
            const chordTime = time + 1.0;
            [NOTE.C5, NOTE.E5, NOTE.G5, NOTE.C6].forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0.1, chordTime);
                gain.gain.exponentialRampToValueAtTime(0.01, chordTime + 1.0);
                osc.connect(gain);
                gain.connect(fanfareGain);
                osc.start(chordTime);
                osc.stop(chordTime + 1.2);
            });
        }

        // Announcer voice system
        let announcerEnabled = true;
        let lastAnnouncement = 0;
        const ANNOUNCEMENT_COOLDOWN = 2000;

        const ANNOUNCEMENTS = {
            gameStart: ['Defend Earth!', 'Ready for battle!', 'Show them who is boss!'],
            levelUp: ['Level up!', 'Well done!', 'Next wave!', 'Keep it up!'],
            bossAppear: ['Warning! Boss detected!', 'Big enemy!', 'Boss fight!'],
            bossDefeat: ['Boss eliminated!', 'Fantastic!', 'Boss defeated!'],
            combo5: ['Combo master!', 'Incredible!', 'Five in a row!'],
            combo7: ['Legendary combo!', 'Unstoppable!', 'Super combo!'],
            powerUp: ['Power up!', 'Bonus activated!'],
            ufoKill: ['UFO destroyed!', 'Bonus points!'],
            lowHealth: ['Warning! Low health!', 'Watch out!'],
            gameOver: ['Game over!', 'Better luck next time!'],
            newHighscore: ['New record!', 'Amazing score!'],
            dailyChallenge: ['Daily challenge complete!', 'Challenge completed!', 'Bonus coins earned!']
        };

        function announce(type) {
            if (!announcerEnabled || soundMuted) return;
            if (Date.now() - lastAnnouncement < ANNOUNCEMENT_COOLDOWN) return;

            const messages = ANNOUNCEMENTS[type];
            if (!messages || messages.length === 0) return;

            const message = messages[Math.floor(Math.random() * messages.length)];

            if ('speechSynthesis' in window) {
                // Cancel any ongoing speech
                window.speechSynthesis.cancel();

                const utterance = new SpeechSynthesisUtterance(message);
                utterance.lang = 'en-US';
                utterance.rate = 1.1;
                utterance.pitch = 1.0;
                utterance.volume = 0.8 * (announcerVolume / 100);

                // Try to find an English voice
                const voices = window.speechSynthesis.getVoices();
                const englishVoice = voices.find(v => v.lang.startsWith('en'));
                if (englishVoice) {
                    utterance.voice = englishVoice;
                }

                window.speechSynthesis.speak(utterance);
                lastAnnouncement = Date.now();
            }
        }

        function toggleAnnouncer() {
            announcerEnabled = !announcerEnabled;
            document.getElementById('announcerBtn').textContent = announcerEnabled ? '' : '';
        }

        // Load voices when available
        if ('speechSynthesis' in window) {
            window.speechSynthesis.onvoiceschanged = () => {
                window.speechSynthesis.getVoices();
            };
        }

        // Endless mode
        let endlessMode = false;
        let endlessStartTime = 0;
        let endlessWave = 1;
        let endlessSpawnTimer = 0;
        let endlessSpawnInterval = 3000;

        // Tutorial system
        let tutorialActive = false;
        let tutorialStep = 0;
        const TUTORIAL_STEPS = [
            {
                title: ' Welcome to Cosmic Blasterz!',
                text: 'In this game you must defend Earth against waves of aliens. Let\'s learn the basic controls!'
            },
            {
                title: '  Movement',
                text: 'Use the <span class="tutorial-highlight">left and right arrow keys</span> to move your spaceship. Try it now!',
                action: 'move'
            },
            {
                title: ' Shooting',
                text: 'Press <span class="tutorial-highlight">SPACE</span> to shoot lasers at the enemies. Shoot now!',
                action: 'shoot'
            },
            {
                title: ' Weapon System',
                text: 'You have 3 weapons: <span class="tutorial-highlight">1=Laser</span>, <span class="tutorial-highlight">2=Missile</span>, <span class="tutorial-highlight">3=Plasma</span>. Each has unique properties!'
            },
            {
                title: ' Power-ups',
                text: 'Collect power-ups that fall from enemies: <span class="tutorial-highlight">Shield</span> protects you, <span class="tutorial-highlight">Rapid Fire</span> increases fire rate, <span class="tutorial-highlight">Spread Shot</span> shoots 3 bullets, and <span class="tutorial-highlight">Bomb</span> clears the screen!'
            },
            {
                title: ' Boss Battles',
                text: 'Every 5th level you meet a <span class="tutorial-highlight">BOSS</span>. Bosses have lots of health and shoot faster!'
            },
            {
                title: ' Barriers',
                text: 'The green <span class="tutorial-highlight">barriers</span> protect you from enemy fire, but they can also be destroyed!'
            },
            {
                title: ' UFO Bonus',
                text: 'Occasionally a <span class="tutorial-highlight">UFO</span> flies across the screen. Shoot it for bonus points and power-ups!'
            },
            {
                title: ' Coins & Shop',
                text: 'You earn <span class="tutorial-highlight">coins</span> by killing enemies. Use them in the <span class="tutorial-highlight">SHOP</span> for permanent upgrades!'
            },
            {
                title: ' Combo System',
                text: 'Kill enemies quickly in succession to build up <span class="tutorial-highlight">combo</span> and earn more points!'
            },
            {
                title: ' You\'re ready!',
                text: 'Now you know the basics! Remember: P=Pause, M=Mute. Have fun with the game!'
            }
        ];

        function startTutorial() {
            stopSplashMusic();
            tutorialActive = true;
            tutorialStep = 0;
            document.getElementById('startScreen').classList.add('hidden');

            // Start the game in tutorial mode
            initAudio();
            playerName = 'Tutorial';
            endlessMode = false;
            resetGame();
            gameRunning = true;
            gamePaused = true; // Pause initially

            showTutorialStep();
            requestAnimationFrame(gameLoop);
        }

        function showTutorialStep() {
            const step = TUTORIAL_STEPS[tutorialStep];
            document.getElementById('tutorialTitle').textContent = step.title;
            document.getElementById('tutorialText').innerHTML = step.text;

            // Update progress dots
            let dots = '';
            for (let i = 0; i < TUTORIAL_STEPS.length; i++) {
                let dotClass = 'tutorial-dot';
                if (i < tutorialStep) dotClass += ' completed';
                if (i === tutorialStep) dotClass += ' active';
                dots += `<div class="${dotClass}"></div>`;
            }
            document.getElementById('tutorialProgress').innerHTML = dots;

            // Show overlay
            document.getElementById('tutorialOverlay').classList.remove('hidden');

            // Check if this step requires action
            if (step.action) {
                gamePaused = false;
            } else {
                gamePaused = true;
            }
        }

        function nextTutorialStep() {
            tutorialStep++;

            if (tutorialStep >= TUTORIAL_STEPS.length) {
                endTutorial();
            } else {
                showTutorialStep();
            }
        }

        function skipTutorial() {
            endTutorial();
        }

        function endTutorial() {
            tutorialActive = false;
            gameRunning = false;
            gamePaused = false;
            document.getElementById('tutorialOverlay').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
        }

        function checkTutorialAction(action) {
            if (!tutorialActive) return;

            const step = TUTORIAL_STEPS[tutorialStep];
            if (step && step.action === action) {
                // Small delay before advancing
                setTimeout(() => {
                    if (tutorialActive && tutorialStep < TUTORIAL_STEPS.length - 1) {
                        nextTutorialStep();
                    }
                }, 500);
            }
        }

        // Share score system
        function shareScore() {
            document.getElementById('shareOptions').classList.toggle('hidden');
            document.getElementById('shareCopied').classList.add('hidden');
        }

        function getShareText() {
            let text = ` I scored ${score} points in Cosmic Blasterz! `;
            if (endlessMode) {
                const elapsed = Math.floor((Date.now() - endlessStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                text += ` (Endless Mode: ${minutes}m ${seconds}s, Wave ${endlessWave})`;
            } else {
                text += ` (Level ${level})`;
            }
            text += `\nCan you beat me? `;
            return text;
        }

        function shareToTwitter() {
            const text = encodeURIComponent(getShareText());
            const url = `https://twitter.com/intent/tweet?text=${text}`;
            window.open(url, '_blank', 'width=550,height=420');
        }

        function shareToFacebook() {
            const text = encodeURIComponent(getShareText());
            const url = `https://www.facebook.com/sharer/sharer.php?quote=${text}`;
            window.open(url, '_blank', 'width=550,height=420');
        }

        function shareToLinkedIn() {
            const gameUrl = encodeURIComponent('https://mricebird.github.io/cosmic-blasterz/');
            const url = `https://www.linkedin.com/sharing/share-offsite/?url=${gameUrl}`;
            window.open(url, '_blank', 'width=550,height=420');
        }

        async function copyShareLink() {
            const text = getShareText();
            try {
                await navigator.clipboard.writeText(text);
                document.getElementById('shareCopied').classList.remove('hidden');
                setTimeout(() => {
                    document.getElementById('shareCopied').classList.add('hidden');
                }, 2000);
            } catch (err) {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                document.getElementById('shareCopied').classList.remove('hidden');
                setTimeout(() => {
                    document.getElementById('shareCopied').classList.add('hidden');
                }, 2000);
            }
        }

        // Combo system
        let comboCount = 0;
        let comboTimer = 0;
        const COMBO_TIMEOUT = 1500; // ms to maintain combo
        const COMBO_MULTIPLIERS = [1, 1.5, 2, 2.5, 3, 4, 5]; // Multiplier based on combo count
        let comboDisplayTimer = null;

        function getComboMultiplier() {
            const index = Math.min(comboCount - 1, COMBO_MULTIPLIERS.length - 1);
            return index >= 0 ? COMBO_MULTIPLIERS[index] : 1;
        }

        function addComboKill(basePoints) {
            comboCount++;
            comboTimer = Date.now();

            const multiplier = getComboMultiplier();
            let bonusPoints = Math.floor(basePoints * multiplier);

            // Apply double points power-up
            if (doublePointsActive) {
                bonusPoints *= 2;
            }

            // Update combo display
            const comboEl = document.getElementById('comboDisplay');
            if (comboCount >= 2) {
                const doubleText = doublePointsActive ? ' (2X!)' : '';
                comboEl.textContent = `${comboCount}x COMBO! +${bonusPoints}${doubleText}`;
                comboEl.classList.add('active');

                // Change color based on combo level
                if (comboCount >= 7) {
                    comboEl.style.color = '#f0f';
                    announce('combo7');
                } else if (comboCount >= 5) {
                    comboEl.style.color = '#f0f';
                    announce('combo5');
                } else if (comboCount >= 3) {
                    comboEl.style.color = '#f80';
                } else {
                    comboEl.style.color = '#ff0';
                }

                // Clear previous timer
                if (comboDisplayTimer) clearTimeout(comboDisplayTimer);
                comboDisplayTimer = setTimeout(() => {
                    comboEl.classList.remove('active');
                }, 1000);
            }

            return bonusPoints;
        }

        function updateCombo() {
            // Reset combo if timeout exceeded
            if (comboCount > 0 && Date.now() - comboTimer > COMBO_TIMEOUT) {
                comboCount = 0;
                document.getElementById('comboDisplay').classList.remove('active');
            }
        }

        // Achievement system
        const ACHIEVEMENTS = {
            firstBlood: {
                icon: '', name: 'First Blood', desc: 'Kill your first enemy',
                longDesc: 'Every journey begins with a single step. You have taken down your first alien invader and begun your path to becoming a legendary space defender.',
                tip: 'Just shoot any enemy to unlock this achievement.',
                rarity: 'common', reward: 10,
                check: (stats) => stats.totalKills >= 1
            },
            killer: {
                icon: '', name: 'Killer', desc: 'Kill 50 enemies',
                longDesc: 'You have proven yourself as a capable fighter. 50 alien invaders have fallen to your weapons. The invasion force is starting to fear you.',
                tip: 'Keep playing and racking up kills. Use rapid-fire power-ups to speed this up.',
                rarity: 'common', reward: 25,
                check: (stats) => stats.totalKills >= 50
            },
            massacre: {
                icon: '', name: 'Massacre', desc: 'Kill 200 enemies',
                longDesc: 'A true warrior emerges! 200 alien souls have been vanquished by your relentless assault. You are becoming a legend among the stars.',
                tip: 'Endless mode is great for racking up large kill counts quickly.',
                rarity: 'rare', reward: 50,
                check: (stats) => stats.totalKills >= 200
            },
            comboStarter: {
                icon: '', name: 'Combo Starter', desc: 'Get a 3x combo',
                longDesc: 'You discovered the power of chaining kills! Combo attacks deal bonus damage and earn extra points. Master this technique to dominate.',
                tip: 'Kill enemies quickly in succession. The combo timer shows how long you have before it resets.',
                rarity: 'common', reward: 15,
                check: (stats) => stats.maxCombo >= 3
            },
            comboMaster: {
                icon: '', name: 'Combo Master', desc: 'Get a 5x combo',
                longDesc: 'Your reflexes are lightning fast! A 5x combo requires precision timing and aggressive play. The aliens cannot keep up with your assault.',
                tip: 'Use spread weapons like plasma to hit multiple enemies at once and build combos faster.',
                rarity: 'rare', reward: 35,
                check: (stats) => stats.maxCombo >= 5
            },
            survivor: {
                icon: '', name: 'Survivor', desc: 'Reach level 5',
                longDesc: 'You have survived the initial waves and reached level 5. The real challenge begins now as enemies become faster and more aggressive.',
                tip: 'Use barriers for cover and collect shield power-ups when low on lives.',
                rarity: 'common', reward: 20,
                check: (stats) => stats.maxLevel >= 5
            },
            veteran: {
                icon: '', name: 'Veteran', desc: 'Reach level 10',
                longDesc: 'A decorated veteran of the cosmic war! Level 10 brings elite enemy formations and your first major boss encounter. You have earned your stripes.',
                tip: 'Boss fights occur at levels 5, 10, 15, 20, and 25. Learn their attack patterns!',
                rarity: 'rare', reward: 50,
                check: (stats) => stats.maxLevel >= 10
            },
            bossSlayer: {
                icon: '', name: 'Boss Slayer', desc: 'Defeat your first boss',
                longDesc: 'You have faced a mighty alien commander and emerged victorious! Boss battles are the ultimate test of skill, requiring you to dodge complex attack patterns while dealing damage.',
                tip: 'Focus on dodging first, shooting second. Bosses have predictable patterns - learn them!',
                rarity: 'rare', reward: 75,
                check: (stats) => stats.bossKills >= 1
            },
            untouchable: {
                icon: '', name: 'Untouchable', desc: 'Complete a level without getting hit',
                longDesc: 'Perfect performance! You cleared an entire level without taking a single hit. Your evasion skills are unmatched in the galaxy.',
                tip: 'Focus on the early levels where enemies are slower. Stay mobile and watch for enemy bullets.',
                rarity: 'epic', reward: 100,
                check: (stats) => stats.perfectLevels >= 1
            },
            powerPlayer: {
                icon: '', name: 'Power Player', desc: 'Collect 10 power-ups',
                longDesc: 'You know the value of power-ups! These cosmic gifts provide shields, rapid fire, multi-shot, and slow-motion abilities. Collect them all to dominate.',
                tip: 'Power-ups drop from destroyed enemies. Higher tier enemies have better drop rates.',
                rarity: 'common', reward: 20,
                check: (stats) => stats.powerUpsCollected >= 10
            },
            scoreHunter: {
                icon: '', name: 'Score Hunter', desc: 'Achieve 5000 points',
                longDesc: 'Your name is climbing the leaderboards! 5000 points shows dedication and skill. Keep pushing for even higher scores.',
                tip: 'Combos multiply your score. Also, defeating bosses and collecting power-ups gives bonus points.',
                rarity: 'common', reward: 30,
                check: (stats) => stats.maxScore >= 5000
            },
            legend: {
                icon: '', name: 'Legend', desc: 'Achieve 20000 points',
                longDesc: 'You have achieved legendary status! 20000 points puts you among the elite defenders of the cosmos. Your name will be remembered forever.',
                tip: 'Master combos, survive boss fights, and play consistently to reach this milestone.',
                rarity: 'legendary', reward: 150,
                check: (stats) => stats.maxScore >= 20000
            },
            comboGod: {
                icon: '', name: 'Combo God', desc: 'Get a 10x combo',
                longDesc: 'UNSTOPPABLE! A 10x combo means you are a true master of destruction. Your enemies fall like dominoes before your relentless assault.',
                tip: 'Use spread weapons and bomb power-ups strategically to chain massive combos.',
                rarity: 'legendary', reward: 200,
                check: (stats) => stats.maxCombo >= 10
            },
            bossHunter: {
                icon: '', name: 'Boss Hunter', desc: 'Defeat 5 bosses',
                longDesc: 'Five alien commanders have fallen to your might! You have become a nightmare for the enemy leadership. They whisper your name in fear.',
                tip: 'Keep playing through levels - bosses appear at levels 5, 10, 15, 20, and 25.',
                rarity: 'epic', reward: 100,
                check: (stats) => stats.bossKills >= 5
            },
            dedicated: {
                icon: '', name: 'Dedicated', desc: 'Play 10 games',
                longDesc: 'Your dedication to defending the cosmos is admirable! 10 games shows commitment to the cause.',
                tip: 'Just keep playing! Each game counts towards this achievement.',
                rarity: 'common', reward: 25,
                check: (stats) => stats.gamesPlayed >= 10
            },
            veteran50: {
                icon: '', name: 'Space Veteran', desc: 'Play 50 games',
                longDesc: 'A true space veteran! 50 games of intense alien combat has hardened you into an elite defender.',
                tip: 'Keep at it, soldier! Your experience is showing.',
                rarity: 'rare', reward: 75,
                check: (stats) => stats.gamesPlayed >= 50
            },
            collector: {
                icon: '', name: 'Collector', desc: 'Collect 50 power-ups',
                longDesc: 'You have a talent for grabbing those cosmic bonuses! 50 power-ups collected shows you know how to gear up.',
                tip: 'Power-ups drop from enemies. Use the magnet power-up to attract them!',
                rarity: 'rare', reward: 50,
                check: (stats) => stats.powerUpsCollected >= 50
            },
            destroyer: {
                icon: '', name: 'Destroyer', desc: 'Kill 1000 enemies',
                longDesc: 'One thousand aliens have met their end at your hands. You are a walking apocalypse for the invasion force.',
                tip: 'Endless mode is great for racking up massive kill counts.',
                rarity: 'epic', reward: 100,
                check: (stats) => stats.totalKills >= 1000
            },
            elite: {
                icon: '', name: 'Elite', desc: 'Reach level 20',
                longDesc: 'Only the elite reach level 20. The enemies here are the deadliest the invasion has to offer. You are among the best.',
                tip: 'Focus on survival. Upgrade your weapons and use power-ups wisely.',
                rarity: 'epic', reward: 125,
                check: (stats) => stats.maxLevel >= 20
            },
            perfectionist: {
                icon: '', name: 'Perfectionist', desc: 'Complete 5 levels without getting hit',
                longDesc: 'Five perfect levels! Your reflexes and positioning are legendary. The aliens cannot touch you.',
                tip: 'Take your time, stay mobile, and prioritize dodging over attacking.',
                rarity: 'legendary', reward: 200,
                check: (stats) => stats.perfectLevels >= 5
            }
        };

        const ACHIEVEMENTS_STORAGE_KEY = 'spaceInvadersAchievements';
        const STATS_STORAGE_KEY = 'spaceInvadersStats';

        let unlockedAchievements = [];
        let gameStats = {
            totalKills: 0,
            maxCombo: 0,
            maxLevel: 0,
            bossKills: 0,
            perfectLevels: 0,
            powerUpsCollected: 0,
            maxScore: 0,
            levelDamageTaken: 0,
            gamesPlayed: 0
        };
        let sessionStats = {
            totalKills: 0,
            maxCombo: 0,
            maxLevel: 0,
            bossKills: 0,
            perfectLevels: 0,
            powerUpsCollected: 0,
            maxScore: 0,
            levelDamageTaken: 0,
            gamesPlayed: 0
        };

        function loadAchievements() {
            try {
                const data = localStorage.getItem(ACHIEVEMENTS_STORAGE_KEY);
                unlockedAchievements = data ? JSON.parse(data) : [];
                const statsData = localStorage.getItem(STATS_STORAGE_KEY);
                gameStats = statsData ? JSON.parse(statsData) : gameStats;
            } catch (e) {
                unlockedAchievements = [];
            }
        }

        function saveAchievements() {
            try {
                localStorage.setItem(ACHIEVEMENTS_STORAGE_KEY, JSON.stringify(unlockedAchievements));
                localStorage.setItem(STATS_STORAGE_KEY, JSON.stringify(gameStats));
            } catch (e) {}
        }

        function checkAchievements() {
            // Merge session stats into game stats
            gameStats.totalKills = Math.max(gameStats.totalKills, sessionStats.totalKills);
            gameStats.maxCombo = Math.max(gameStats.maxCombo, sessionStats.maxCombo);
            gameStats.maxLevel = Math.max(gameStats.maxLevel, sessionStats.maxLevel);
            gameStats.bossKills += sessionStats.bossKills;
            gameStats.perfectLevels += sessionStats.perfectLevels;
            gameStats.powerUpsCollected += sessionStats.powerUpsCollected;
            gameStats.maxScore = Math.max(gameStats.maxScore, sessionStats.maxScore);
            // Also sync from lifetimeStats for cumulative achievements
            gameStats.gamesPlayed = lifetimeStats.gamesPlayed || 0;
            gameStats.totalKills = Math.max(gameStats.totalKills, lifetimeStats.totalKills || 0);
            gameStats.powerUpsCollected = Math.max(gameStats.powerUpsCollected, lifetimeStats.powerUpsCollected || 0);

            Object.keys(ACHIEVEMENTS).forEach(key => {
                if (!unlockedAchievements.includes(key) && ACHIEVEMENTS[key].check(gameStats)) {
                    unlockAchievement(key);
                }
            });

            saveAchievements();
        }

        function unlockAchievement(key) {
            if (unlockedAchievements.includes(key)) return;

            unlockedAchievements.push(key);
            const achievement = ACHIEVEMENTS[key];

            // Show popup
            const popup = document.getElementById('achievementPopup');
            document.getElementById('achievementIcon').textContent = achievement.icon;
            document.getElementById('achievementName').textContent = achievement.name;
            document.getElementById('achievementDesc').textContent = achievement.desc;

            popup.classList.add('show');

            // Play sound
            playLevelUpSound();

            // Spawn achievement particles
            const rect = popup.getBoundingClientRect();
            setTimeout(() => {
                spawnAchievementParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, achievement.icon);
            }, 100);

            // Hide after 3 seconds
            setTimeout(() => {
                popup.classList.remove('show');
            }, 3000);

            saveAchievements();
        }

        function renderAchievementBadges() {
            const container = document.getElementById('achievementBadges');
            let html = '';

            Object.keys(ACHIEVEMENTS).forEach(key => {
                const achievement = ACHIEVEMENTS[key];
                const unlocked = unlockedAchievements.includes(key);
                html += `<div class="achievement-badge ${unlocked ? 'unlocked' : ''}"
                    title="${achievement.name}: ${achievement.desc}"
                    onclick="showAchievementDetail('${key}')"
                    style="cursor: pointer;">${achievement.icon}</div>`;
            });

            container.innerHTML = html;
        }

        function showAchievementDetail(key) {
            const achievement = ACHIEVEMENTS[key];
            const unlocked = unlockedAchievements.includes(key);

            document.getElementById('detailIcon').textContent = achievement.icon;
            document.getElementById('detailName').textContent = achievement.name;
            document.getElementById('detailDesc').textContent = achievement.desc;
            document.getElementById('detailLong').textContent = achievement.longDesc || '';
            document.getElementById('detailTip').textContent = achievement.tip || '';
            document.getElementById('detailReward').textContent = (achievement.reward || 0) + ' coins';

            const rarityEl = document.getElementById('detailRarity');
            rarityEl.textContent = (achievement.rarity || 'common').toUpperCase();
            rarityEl.className = 'achievement-detail-rarity ' + (achievement.rarity || 'common');

            const statusEl = document.getElementById('detailStatus');
            if (unlocked) {
                statusEl.textContent = ' UNLOCKED';
                statusEl.className = 'achievement-detail-status unlocked';
            } else {
                statusEl.textContent = ' LOCKED';
                statusEl.className = 'achievement-detail-status locked';
            }

            document.getElementById('achievementDetailOverlay').classList.remove('hidden');
            playSelectSound();
        }

        function closeAchievementDetail() {
            document.getElementById('achievementDetailOverlay').classList.add('hidden');
        }

        function updateSessionStats(stat, value) {
            if (stat === 'kill') {
                sessionStats.totalKills++;
            } else if (stat === 'combo') {
                sessionStats.maxCombo = Math.max(sessionStats.maxCombo, value);
            } else if (stat === 'level') {
                sessionStats.maxLevel = Math.max(sessionStats.maxLevel, value);
                // Check for perfect level (no damage taken this level)
                if (sessionStats.levelDamageTaken === 0 && value > 1) {
                    sessionStats.perfectLevels++;
                }
                sessionStats.levelDamageTaken = 0;
            } else if (stat === 'bossKill') {
                sessionStats.bossKills++;
            } else if (stat === 'powerUp') {
                sessionStats.powerUpsCollected++;
            } else if (stat === 'score') {
                sessionStats.maxScore = Math.max(sessionStats.maxScore, value);
            } else if (stat === 'damage') {
                sessionStats.levelDamageTaken++;
            }

            // Check achievements in real-time for certain milestones
            const tempStats = { ...gameStats };
            tempStats.totalKills = Math.max(tempStats.totalKills, sessionStats.totalKills);
            tempStats.maxCombo = Math.max(tempStats.maxCombo, sessionStats.maxCombo);
            tempStats.maxLevel = Math.max(tempStats.maxLevel, sessionStats.maxLevel);
            tempStats.bossKills = gameStats.bossKills + sessionStats.bossKills;
            tempStats.perfectLevels = gameStats.perfectLevels + sessionStats.perfectLevels;
            tempStats.powerUpsCollected = gameStats.powerUpsCollected + sessionStats.powerUpsCollected;
            tempStats.maxScore = Math.max(tempStats.maxScore, sessionStats.maxScore);

            Object.keys(ACHIEVEMENTS).forEach(key => {
                if (!unlockedAchievements.includes(key) && ACHIEVEMENTS[key].check(tempStats)) {
                    unlockAchievement(key);
                }
            });
        }

        function resetSessionStats() {
            sessionStats = {
                totalKills: 0,
                maxCombo: 0,
                maxLevel: 1,
                bossKills: 0,
                perfectLevels: 0,
                powerUpsCollected: 0,
                maxScore: 0,
                levelDamageTaken: 0
            };
        }

        // Load achievements on start
        loadAchievements();

        // Shop system
        const SHOP_STORAGE_KEY = 'spaceInvadersShop';
        let totalCoins = 0;
        let ownedUpgrades = [];

        const SHOP_ITEMS = {
            extraLife: { name: 'Extra Life', desc: 'Start with 4 lives instead of 3', price: 500, effect: 'startLives' },
            fasterShip: { name: 'Faster Ship', desc: '+20% movement speed', price: 300, effect: 'shipSpeed' },
            biggerBullets: { name: 'Bigger Bullets', desc: '+50% damage on all weapons', price: 400, effect: 'bulletDamage' },
            longerPowerups: { name: 'Longer Power-ups', desc: 'Power-ups last 50% longer', price: 350, effect: 'powerupDuration' },
            coinMagnet: { name: 'Coin Magnet', desc: '+25% more coins per kill', price: 250, effect: 'coinBonus' },
            startShield: { name: 'Start Shield', desc: 'Start with shield for 5 seconds', price: 600, effect: 'startShield' }
        };

        // Ship skins system
        const SHIP_SKINS = {
            classic: {
                name: 'Classic',
                rarity: 'common',
                price: 0,
                colors: { body: '#0ff', cockpit: '#fff', engine: '#f80' },
                stats: { speed: 50, damage: 50, fireRate: 50, defense: 50 }
            },
            stealth: {
                name: 'Stealth',
                rarity: 'common',
                price: 200,
                colors: { body: '#333', cockpit: '#0f0', engine: '#0f0' },
                stats: { speed: 70, damage: 40, fireRate: 60, defense: 30 }
            },
            crimson: {
                name: 'Crimson',
                rarity: 'common',
                price: 250,
                colors: { body: '#f33', cockpit: '#fff', engine: '#ff0' },
                stats: { speed: 50, damage: 70, fireRate: 45, defense: 45 }
            },
            royal: {
                name: 'Royal',
                rarity: 'rare',
                price: 400,
                colors: { body: '#a0f', cockpit: '#fff', engine: '#f0f' },
                stats: { speed: 55, damage: 60, fireRate: 55, defense: 55 }
            },
            golden: {
                name: 'Golden',
                rarity: 'rare',
                price: 500,
                colors: { body: '#fc0', cockpit: '#fff', engine: '#f80' },
                stats: { speed: 45, damage: 50, fireRate: 50, defense: 75 }
            },
            neon: {
                name: 'Neon',
                rarity: 'rare',
                price: 450,
                colors: { body: '#0f0', cockpit: '#fff', engine: '#0ff' },
                stats: { speed: 60, damage: 45, fireRate: 75, defense: 35 }
            },
            phantom: {
                name: 'Phantom',
                rarity: 'epic',
                price: 800,
                colors: { body: '#808', cockpit: '#f0f', engine: '#a0f' },
                stats: { speed: 80, damage: 50, fireRate: 70, defense: 30 }
            },
            arctic: {
                name: 'Arctic',
                rarity: 'epic',
                price: 750,
                colors: { body: '#aef', cockpit: '#fff', engine: '#0af' },
                stats: { speed: 45, damage: 55, fireRate: 65, defense: 70 }
            },
            inferno: {
                name: 'Inferno',
                rarity: 'epic',
                price: 850,
                colors: { body: '#f50', cockpit: '#ff0', engine: '#f00' },
                stats: { speed: 45, damage: 85, fireRate: 40, defense: 55 }
            },
            galaxy: {
                name: 'Galaxy',
                rarity: 'legendary',
                price: 1500,
                colors: { body: '#50f', cockpit: '#fff', engine: '#f0f', gradient: true },
                stats: { speed: 65, damage: 65, fireRate: 65, defense: 65 }
            },
            rainbow: {
                name: 'Rainbow',
                rarity: 'legendary',
                price: 2000,
                colors: { body: '#f00', cockpit: '#fff', engine: '#ff0', rainbow: true },
                stats: { speed: 75, damage: 60, fireRate: 80, defense: 50 }
            },
            void: {
                name: 'Void',
                rarity: 'legendary',
                price: 2500,
                colors: { body: '#111', cockpit: '#f00', engine: '#f00', glow: '#f00' },
                stats: { speed: 40, damage: 90, fireRate: 40, defense: 85 }
            }
        };

        let selectedSkin = 'classic';
        let ownedSkins = ['classic'];
        let currentShopTab = 'upgrades';

        // Trail styles system
        const TRAIL_STYLES = {
            classic: {
                name: 'Classic',
                rarity: 'common',
                price: 0,
                color1: '#0ff',
                color2: '#008',
                desc: 'Standard cyan engine trail'
            },
            fire: {
                name: 'Fire',
                rarity: 'common',
                price: 200,
                color1: '#f80',
                color2: '#f00',
                desc: 'Blazing orange flame trail'
            },
            plasma: {
                name: 'Plasma',
                rarity: 'rare',
                price: 350,
                color1: '#f0f',
                color2: '#808',
                desc: 'Purple plasma energy trail'
            },
            neon: {
                name: 'Neon',
                rarity: 'rare',
                price: 400,
                color1: '#0f0',
                color2: '#080',
                desc: 'Bright green neon glow'
            },
            rainbow: {
                name: 'Rainbow',
                rarity: 'epic',
                price: 600,
                color1: '#f00',
                color2: '#00f',
                rainbow: true,
                desc: 'Color-cycling rainbow trail'
            },
            electric: {
                name: 'Electric',
                rarity: 'epic',
                price: 700,
                color1: '#0af',
                color2: '#fff',
                electric: true,
                desc: 'Crackling electric sparks'
            },
            galaxy: {
                name: 'Galaxy',
                rarity: 'legendary',
                price: 1200,
                color1: '#a0f',
                color2: '#05a',
                starfield: true,
                desc: 'Cosmic starfield trail'
            }
        };

        let selectedTrail = 'classic';
        let ownedTrails = ['classic'];

        // Weapon upgrade system
        const WEAPON_UPGRADES = {
            laser: {
                name: 'Laser',
                icon: '',
                upgrades: [
                    { level: 1, name: 'Damage I', stat: 'damage', bonus: 0.5, price: 150, desc: '+50% damage' },
                    { level: 2, name: 'Speed I', stat: 'speed', bonus: 2, price: 200, desc: '+2 bullet speed' },
                    { level: 3, name: 'Rapid I', stat: 'cooldown', bonus: -30, price: 250, desc: '-30ms cooldown' },
                    { level: 4, name: 'Damage II', stat: 'damage', bonus: 0.5, price: 350, desc: '+50% more damage' },
                    { level: 5, name: 'Rapid II', stat: 'cooldown', bonus: -30, price: 450, desc: '-30ms more cooldown' }
                ]
            },
            missile: {
                name: 'Missile',
                icon: '',
                upgrades: [
                    { level: 1, name: 'Blast I', stat: 'splash', bonus: 15, price: 200, desc: '+15 splash radius' },
                    { level: 2, name: 'Damage I', stat: 'damage', bonus: 1, price: 300, desc: '+1 damage' },
                    { level: 3, name: 'Speed I', stat: 'speed', bonus: 1, price: 350, desc: '+1 missile speed' },
                    { level: 4, name: 'Blast II', stat: 'splash', bonus: 20, price: 500, desc: '+20 more splash' },
                    { level: 5, name: 'Damage II', stat: 'damage', bonus: 2, price: 600, desc: '+2 more damage' }
                ]
            },
            plasma: {
                name: 'Plasma',
                icon: '',
                upgrades: [
                    { level: 1, name: 'Pierce I', stat: 'width', bonus: 2, price: 200, desc: '+2 beam width' },
                    { level: 2, name: 'Speed I', stat: 'speed', bonus: 3, price: 250, desc: '+3 beam speed' },
                    { level: 3, name: 'Rapid I', stat: 'cooldown', bonus: -20, price: 300, desc: '-20ms cooldown' },
                    { level: 4, name: 'Pierce II', stat: 'width', bonus: 3, price: 400, desc: '+3 more beam width' },
                    { level: 5, name: 'Rapid II', stat: 'cooldown', bonus: -20, price: 500, desc: '-20ms more cooldown' }
                ]
            }
        };

        let weaponUpgradeLevels = { laser: 0, missile: 0, plasma: 0 };

        function loadShopData() {
            try {
                const data = localStorage.getItem(SHOP_STORAGE_KEY);
                if (data) {
                    const parsed = JSON.parse(data);
                    totalCoins = parsed.coins || 0;
                    ownedUpgrades = parsed.owned || [];
                    ownedSkins = parsed.skins || ['classic'];
                    selectedSkin = parsed.selectedSkin || 'classic';
                    ownedTrails = parsed.trails || ['classic'];
                    selectedTrail = parsed.selectedTrail || 'classic';
                    weaponUpgradeLevels = parsed.weaponUpgrades || { laser: 0, missile: 0, plasma: 0 };
                    // Ensure classic is always owned
                    if (!ownedSkins.includes('classic')) {
                        ownedSkins.push('classic');
                    }
                    if (!ownedTrails.includes('classic')) {
                        ownedTrails.push('classic');
                    }
                }
            } catch (e) {}
            updateCoinsDisplay();
            applyWeaponUpgrades();
        }

        function saveShopData() {
            try {
                localStorage.setItem(SHOP_STORAGE_KEY, JSON.stringify({
                    coins: totalCoins,
                    owned: ownedUpgrades,
                    skins: ownedSkins,
                    selectedSkin: selectedSkin,
                    trails: ownedTrails,
                    selectedTrail: selectedTrail,
                    weaponUpgrades: weaponUpgradeLevels
                }));
            } catch (e) {}
        }

        let weaponsInitialized = false;

        function applyWeaponUpgrades() {
            // Check if WEAPONS is defined yet (called later in initialization)
            if (!weaponsInitialized) return;

            // Apply all purchased weapon upgrades
            Object.keys(WEAPON_UPGRADES).forEach(weaponKey => {
                const weapon = WEAPONS[weaponKey];
                const upgradeData = WEAPON_UPGRADES[weaponKey];
                const currentLevel = weaponUpgradeLevels[weaponKey] || 0;

                // Reset to base stats first (clone from original)
                const baseStats = {
                    laser: { damage: 1, speed: 10, cooldown: 200, width: 4, splash: 0 },
                    missile: { damage: 3, speed: 6, cooldown: 500, width: 8, splash: 30 },
                    plasma: { damage: 1, speed: 12, cooldown: 150, width: 6, splash: 0 }
                };

                // Apply base stats
                weapon.damage = baseStats[weaponKey].damage;
                weapon.speed = baseStats[weaponKey].speed;
                weapon.cooldown = baseStats[weaponKey].cooldown;
                weapon.width = baseStats[weaponKey].width;
                weapon.splash = baseStats[weaponKey].splash;

                // Apply each level's upgrade
                for (let i = 0; i < currentLevel; i++) {
                    const upgrade = upgradeData.upgrades[i];
                    weapon[upgrade.stat] += upgrade.bonus;
                }
            });
        }

        function purchaseWeaponUpgrade(weaponKey) {
            const upgradeData = WEAPON_UPGRADES[weaponKey];
            const currentLevel = weaponUpgradeLevels[weaponKey] || 0;

            if (currentLevel >= upgradeData.upgrades.length) return;

            const nextUpgrade = upgradeData.upgrades[currentLevel];
            if (totalCoins < nextUpgrade.price) return;

            totalCoins -= nextUpgrade.price;
            weaponUpgradeLevels[weaponKey] = currentLevel + 1;

            saveShopData();
            updateCoinsDisplay();
            applyWeaponUpgrades();
            renderShopItems();
            playPurchaseSound();
            showShareToast(`${upgradeData.name} upgraded to level ${currentLevel + 1}!`);
        }

        function playPurchaseSound() {
            if (!ensureAudio() || soundMuted) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(600, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.2);
        }

        function addCoins(amount) {
            // Apply difficulty multiplier
            const difficulty = getDifficulty();
            amount = Math.floor(amount * (difficulty.coinMultiplier || 1));
            // Apply coin bonus if owned
            if (ownedUpgrades.includes('coinMagnet')) {
                amount = Math.floor(amount * 1.25);
            }
            totalCoins += amount;
            updateCoinsDisplay();
            saveShopData();
            // Track lifetime stats
            updateLifetimeStat('totalCoinsEarned', amount, 'add');
        }

        function updateCoinsDisplay() {
            document.getElementById('coinsDisplay').textContent = ' ' + totalCoins;
        }

        function toggleShop() {
            const panel = document.getElementById('shopPanel');
            panel.classList.toggle('hidden');
            if (!panel.classList.contains('hidden')) {
                renderShopItems();
                if (gameRunning && !gamePaused) {
                    togglePause();
                }
            }
        }

        function renderShopItems() {
            const container = document.getElementById('shopItems');
            let html = '';

            // Tabs
            html += `
                <div class="shop-tabs">
                    <button class="shop-tab ${currentShopTab === 'upgrades' ? 'active' : ''}" onclick="switchShopTab('upgrades')"> UPGRADES</button>
                    <button class="shop-tab ${currentShopTab === 'weapons' ? 'active' : ''}" onclick="switchShopTab('weapons')"> WEAPONS</button>
                    <button class="shop-tab ${currentShopTab === 'skins' ? 'active' : ''}" onclick="switchShopTab('skins')"> SKINS</button>
                    <button class="shop-tab ${currentShopTab === 'trails' ? 'active' : ''}" onclick="switchShopTab('trails')"> TRAILS</button>
                </div>
            `;

            if (currentShopTab === 'upgrades') {
                // Upgrades tab
                Object.keys(SHOP_ITEMS).forEach(key => {
                    const item = SHOP_ITEMS[key];
                    const owned = ownedUpgrades.includes(key);
                    const canAfford = totalCoins >= item.price;

                    html += `
                        <div class="shop-item ${owned ? 'owned' : ''}">
                            <div class="shop-item-info">
                                <div class="shop-item-name">${item.name}</div>
                                <div class="shop-item-desc">${item.desc}</div>
                            </div>
                            <button class="shop-item-btn"
                                ${owned || !canAfford ? 'disabled' : ''}
                                onclick="purchaseItem('${key}')">
                                ${owned ? ' OWNED' : ' ' + item.price}
                            </button>
                        </div>
                    `;
                });
            } else if (currentShopTab === 'weapons') {
                // Weapons tab with visual previews
                const weaponInfo = {
                    laser: { color: '#0ff', desc: 'Fast, precise shots', stats: 'Speed:  | Damage: ' },
                    missile: { color: '#f80', desc: 'Explosive splash damage', stats: 'Speed:  | Damage: ' },
                    plasma: { color: '#f0f', desc: 'Penetrates enemies', stats: 'Speed:  | Damage: ' }
                };

                Object.keys(WEAPON_UPGRADES).forEach(weaponKey => {
                    const weaponData = WEAPON_UPGRADES[weaponKey];
                    const wInfo = weaponInfo[weaponKey];
                    const currentLevel = weaponUpgradeLevels[weaponKey] || 0;
                    const maxLevel = weaponData.upgrades.length;
                    const isMaxed = currentLevel >= maxLevel;
                    const nextUpgrade = isMaxed ? null : weaponData.upgrades[currentLevel];
                    const canAfford = nextUpgrade ? totalCoins >= nextUpgrade.price : false;

                    // Progress bar
                    const progressPercent = (currentLevel / maxLevel) * 100;

                    html += `
                        <div class="weapon-upgrade-card">
                            <div class="weapon-preview-container">
                                <canvas id="weaponPreview_${weaponKey}" width="120" height="60"></canvas>
                            </div>
                            <div class="weapon-upgrade-header">
                                <span class="weapon-icon">${weaponData.icon}</span>
                                <span class="weapon-name">${weaponData.name}</span>
                                <span class="weapon-level">LVL ${currentLevel}/${maxLevel}</span>
                            </div>
                            <div class="weapon-desc">${wInfo.desc}</div>
                            <div class="weapon-stats">${wInfo.stats}</div>
                            <div class="weapon-progress-bar">
                                <div class="weapon-progress-fill" style="width: ${progressPercent}%"></div>
                            </div>
                            <div class="weapon-upgrade-info">
                                ${isMaxed ? '<span class="weapon-maxed"> MAXED OUT </span>' :
                                  `<span class="weapon-next-upgrade">${nextUpgrade.name}: ${nextUpgrade.desc}</span>`}
                            </div>
                            <button class="weapon-upgrade-btn"
                                ${isMaxed || !canAfford ? 'disabled' : ''}
                                onclick="purchaseWeaponUpgrade('${weaponKey}')">
                                ${isMaxed ? ' MAX' : ' ' + nextUpgrade.price}
                            </button>
                        </div>
                    `;
                });
            } else if (currentShopTab === 'skins') {
                // Skins tab
                html += '<div class="skins-grid">';
                Object.keys(SHIP_SKINS).forEach(key => {
                    const skin = SHIP_SKINS[key];
                    const owned = ownedSkins.includes(key);
                    const isSelected = selectedSkin === key;
                    const canAfford = totalCoins >= skin.price;

                    html += `
                        <div class="skin-card ${isSelected ? 'selected' : ''} ${!owned ? 'locked' : ''}"
                             onclick="${owned ? `selectSkin('${key}')` : (canAfford ? `purchaseSkin('${key}')` : '')}">
                            <div class="skin-preview">
                                <canvas id="skinPreview_${key}" width="60" height="50"></canvas>
                            </div>
                            <div class="skin-name">${skin.name}</div>
                            <div class="skin-price ${owned ? 'owned' : ''}">${owned ? (isSelected ? ' EQUIPPED' : 'OWNED') : ' ' + skin.price}</div>
                            <div class="skin-rarity ${skin.rarity}">${skin.rarity.toUpperCase()}</div>
                        </div>
                    `;
                });
                html += '</div>';
            } else if (currentShopTab === 'trails') {
                // Trails tab
                html += '<div class="skins-grid">';
                Object.keys(TRAIL_STYLES).forEach(key => {
                    const trail = TRAIL_STYLES[key];
                    const owned = ownedTrails.includes(key);
                    const isSelected = selectedTrail === key;
                    const canAfford = totalCoins >= trail.price;

                    html += `
                        <div class="skin-card trail-card ${isSelected ? 'selected' : ''} ${!owned ? 'locked' : ''}"
                             onclick="${owned ? `selectTrail('${key}')` : (canAfford ? `purchaseTrail('${key}')` : '')}">
                            <div class="trail-preview" style="background: linear-gradient(135deg, ${trail.color1}, ${trail.color2});"></div>
                            <div class="skin-name">${trail.name}</div>
                            <div class="trail-desc">${trail.desc}</div>
                            <div class="skin-price ${owned ? 'owned' : ''}">${owned ? (isSelected ? ' EQUIPPED' : 'OWNED') : ' ' + trail.price}</div>
                            <div class="skin-rarity ${trail.rarity}">${trail.rarity.toUpperCase()}</div>
                        </div>
                    `;
                });
                html += '</div>';
            }

            container.innerHTML = html;

            // Render skin previews if on skins tab
            if (currentShopTab === 'skins') {
                setTimeout(() => renderSkinPreviews(), 10);
            }
            if (currentShopTab === 'weapons') {
                setTimeout(() => renderWeaponPreviews(), 10);
            }
        }

        function switchShopTab(tab) {
            currentShopTab = tab;
            renderShopItems();
        }

        function renderSkinPreviews() {
            Object.keys(SHIP_SKINS).forEach(key => {
                const canvas = document.getElementById(`skinPreview_${key}`);
                if (!canvas) return;
                const skinCtx = canvas.getContext('2d');
                const skin = SHIP_SKINS[key];
                const colors = skin.colors;

                skinCtx.clearRect(0, 0, 60, 50);

                // Draw ship preview
                const x = 10;
                const y = 5;
                const w = 40;
                const h = 35;

                // Body
                let bodyColor = colors.body;
                if (colors.rainbow) {
                    const gradient = skinCtx.createLinearGradient(x, y, x + w, y + h);
                    gradient.addColorStop(0, '#f00');
                    gradient.addColorStop(0.2, '#ff0');
                    gradient.addColorStop(0.4, '#0f0');
                    gradient.addColorStop(0.6, '#0ff');
                    gradient.addColorStop(0.8, '#00f');
                    gradient.addColorStop(1, '#f0f');
                    bodyColor = gradient;
                } else if (colors.gradient) {
                    const gradient = skinCtx.createLinearGradient(x, y, x + w, y + h);
                    gradient.addColorStop(0, '#50f');
                    gradient.addColorStop(0.5, '#f0f');
                    gradient.addColorStop(1, '#0ff');
                    bodyColor = gradient;
                }

                if (colors.glow) {
                    skinCtx.shadowColor = colors.glow;
                    skinCtx.shadowBlur = 8;
                }

                skinCtx.fillStyle = bodyColor;
                skinCtx.beginPath();
                skinCtx.moveTo(x + w / 2, y);
                skinCtx.lineTo(x + w, y + h);
                skinCtx.lineTo(x + w - 8, y + h - 8);
                skinCtx.lineTo(x + w / 2, y + h - 5);
                skinCtx.lineTo(x + 8, y + h - 8);
                skinCtx.lineTo(x, y + h);
                skinCtx.closePath();
                skinCtx.fill();

                skinCtx.shadowBlur = 0;

                // Cockpit
                skinCtx.fillStyle = colors.cockpit;
                skinCtx.beginPath();
                skinCtx.arc(x + w / 2, y + 12, 4, 0, Math.PI * 2);
                skinCtx.fill();

                // Engine
                skinCtx.fillStyle = colors.engine;
                skinCtx.beginPath();
                skinCtx.moveTo(x + 10, y + h);
                skinCtx.lineTo(x + w / 2, y + h + 6);
                skinCtx.lineTo(x + w - 10, y + h);
                skinCtx.closePath();
                skinCtx.fill();
            });
        }

        // Animated weapon previews
        let weaponPreviewAnimations = {};

        function renderWeaponPreviews() {
            // Clear existing animations
            Object.values(weaponPreviewAnimations).forEach(id => cancelAnimationFrame(id));
            weaponPreviewAnimations = {};

            const weaponVisuals = {
                laser: { color: '#0ff', width: 4, height: 12, speed: 3, glow: '#0ff' },
                missile: { color: '#f80', width: 8, height: 16, speed: 2, glow: '#f80', trail: true },
                plasma: { color: '#f0f', width: 6, height: 20, speed: 2.5, glow: '#f0f', penetrating: true }
            };

            Object.keys(weaponVisuals).forEach(weaponKey => {
                const canvas = document.getElementById(`weaponPreview_${weaponKey}`);
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const visual = weaponVisuals[weaponKey];
                let bullets = [];
                let frame = 0;

                function spawnBullet() {
                    bullets.push({
                        x: 60 + Math.random() * 20 - 10,
                        y: 55,
                        width: visual.width,
                        height: visual.height
                    });
                }

                function animate() {
                    ctx.clearRect(0, 0, 120, 60);

                    // Draw dark background with grid
                    ctx.fillStyle = 'rgba(0, 10, 20, 0.9)';
                    ctx.fillRect(0, 0, 120, 60);

                    // Grid lines
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 120; i += 15) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i, 60);
                        ctx.stroke();
                    }
                    for (let i = 0; i < 60; i += 15) {
                        ctx.beginPath();
                        ctx.moveTo(0, i);
                        ctx.lineTo(120, i);
                        ctx.stroke();
                    }

                    // Update and draw bullets
                    bullets = bullets.filter(b => b.y > -20);
                    bullets.forEach(b => {
                        b.y -= visual.speed;

                        // Glow effect
                        ctx.shadowColor = visual.glow;
                        ctx.shadowBlur = 8;

                        // Draw bullet based on type
                        ctx.fillStyle = visual.color;

                        if (weaponKey === 'laser') {
                            // Simple rectangle
                            ctx.fillRect(b.x - b.width/2, b.y, b.width, b.height);
                        } else if (weaponKey === 'missile') {
                            // Missile shape with trail
                            ctx.beginPath();
                            ctx.moveTo(b.x, b.y);
                            ctx.lineTo(b.x - b.width/2, b.y + b.height);
                            ctx.lineTo(b.x + b.width/2, b.y + b.height);
                            ctx.closePath();
                            ctx.fill();

                            // Trail
                            ctx.fillStyle = '#ff0';
                            ctx.beginPath();
                            ctx.moveTo(b.x - 2, b.y + b.height);
                            ctx.lineTo(b.x, b.y + b.height + 8);
                            ctx.lineTo(b.x + 2, b.y + b.height);
                            ctx.closePath();
                            ctx.fill();
                        } else if (weaponKey === 'plasma') {
                            // Elongated beam
                            const gradient = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.height);
                            gradient.addColorStop(0, '#fff');
                            gradient.addColorStop(0.3, visual.color);
                            gradient.addColorStop(1, 'rgba(255,0,255,0.3)');
                            ctx.fillStyle = gradient;
                            ctx.fillRect(b.x - b.width/2, b.y, b.width, b.height);
                        }

                        ctx.shadowBlur = 0;
                    });

                    // Spawn new bullet periodically
                    frame++;
                    if (frame % 25 === 0) {
                        spawnBullet();
                    }

                    weaponPreviewAnimations[weaponKey] = requestAnimationFrame(animate);
                }

                // Initial bullets
                spawnBullet();
                setTimeout(() => spawnBullet(), 200);

                animate();
            });
        }

        function selectSkin(key) {
            if (!ownedSkins.includes(key)) return;
            selectedSkin = key;
            saveShopData();
            renderShopItems();
            playSelectSound();
        }

        function purchaseSkin(key) {
            const skin = SHIP_SKINS[key];
            if (ownedSkins.includes(key) || totalCoins < skin.price) return;

            totalCoins -= skin.price;
            ownedSkins.push(key);
            selectedSkin = key;
            saveShopData();
            updateCoinsDisplay();
            renderShopItems();
            playLevelUpSound();
            announce(`New ship skin unlocked: ${skin.name}!`);
        }

        function selectTrail(key) {
            if (!ownedTrails.includes(key)) return;
            selectedTrail = key;
            saveShopData();
            renderShopItems();
            playSelectSound();
        }

        function purchaseTrail(key) {
            const trail = TRAIL_STYLES[key];
            if (ownedTrails.includes(key) || totalCoins < trail.price) return;

            totalCoins -= trail.price;
            ownedTrails.push(key);
            selectedTrail = key;
            saveShopData();
            updateCoinsDisplay();
            renderShopItems();
            playLevelUpSound();
            announce(`New trail style unlocked: ${trail.name}!`);
        }

        function playSelectSound() {
            if (soundMuted || sfxVolume === 0) return;
            if (!ensureAudio()) return;
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1);
                const vol = Math.max(0.01, 0.1 * (sfxVolume / 100));
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.1);
            } catch (e) {}
        }

        function purchaseItem(key) {
            const item = SHOP_ITEMS[key];
            if (ownedUpgrades.includes(key) || totalCoins < item.price) return;

            totalCoins -= item.price;
            ownedUpgrades.push(key);
            saveShopData();
            updateCoinsDisplay();
            renderShopItems();
            playLevelUpSound();
        }

        function hasUpgrade(key) {
            return ownedUpgrades.includes(key);
        }

        // Load shop data on start
        loadShopData();

        // Load volume settings on start
        loadVolumeSettings();

        // Load screen size on start
        loadScreenSize();

        // Load difficulty setting on start
        loadDifficultySetting();

        // Daily Challenges system
        const DAILY_CHALLENGES = [
            { id: 'speed', name: 'Speed Master', desc: 'Kill 30 enemies in 60 seconds', goal: 30, timeLimit: 60, reward: 100 },
            { id: 'combo', name: 'Combo King', desc: 'Achieve a 7x combo', goal: 7, reward: 150 },
            { id: 'boss', name: 'Boss Hunter', desc: 'Defeat a boss without losing a life', goal: 1, reward: 200 },
            { id: 'accuracy', name: 'Sharpshooter', desc: 'Achieve 80% accuracy in a round', goal: 80, reward: 125 },
            { id: 'survival', name: 'Survivor', desc: 'Reach level 5 without losing a life', goal: 5, reward: 175 },
            { id: 'powerup', name: 'Power Collector', desc: 'Collect 10 power-ups in one round', goal: 10, reward: 100 },
            { id: 'ufo', name: 'UFO Hunter', desc: 'Shoot down 3 UFOs in one round', goal: 3, reward: 150 }
        ];

        let dailyChallenge = null;
        let dailyChallengeProgress = 0;
        let dailyChallengeCompleted = false;
        let dailyChallengeStats = {
            killsInTime: 0,
            timeStarted: 0,
            shotsFired: 0,
            shotsHit: 0,
            livesLostThisRound: 0,
            powerupsCollected: 0,
            ufosKilled: 0,
            bossesDefeatedNoLives: 0
        };

        function getDailyChallenge() {
            const today = new Date();
            const dayOfYear = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / 86400000);
            const index = dayOfYear % DAILY_CHALLENGES.length;
            return DAILY_CHALLENGES[index];
        }

        function loadDailyChallenge() {
            const saved = localStorage.getItem('spaceInvadersDailyChallenge');
            const today = new Date().toDateString();

            if (saved) {
                const data = JSON.parse(saved);
                if (data.date === today) {
                    dailyChallengeCompleted = data.completed;
                }
            }

            dailyChallenge = getDailyChallenge();
            updateDailyChallengeUI();
        }

        function saveDailyChallenge() {
            const today = new Date().toDateString();
            localStorage.setItem('spaceInvadersDailyChallenge', JSON.stringify({
                date: today,
                completed: dailyChallengeCompleted
            }));
        }

        function resetDailyChallengeStats() {
            dailyChallengeStats = {
                killsInTime: 0,
                timeStarted: Date.now(),
                shotsFired: 0,
                shotsHit: 0,
                livesLostThisRound: 0,
                powerupsCollected: 0,
                ufosKilled: 0,
                bossesDefeatedNoLives: 0
            };
            dailyChallengeProgress = 0;
        }

        function checkDailyChallenge() {
            if (!dailyChallenge || dailyChallengeCompleted) return;

            let completed = false;

            switch (dailyChallenge.id) {
                case 'speed':
                    const elapsed = (Date.now() - dailyChallengeStats.timeStarted) / 1000;
                    if (elapsed <= dailyChallenge.timeLimit) {
                        dailyChallengeProgress = dailyChallengeStats.killsInTime;
                        if (dailyChallengeStats.killsInTime >= dailyChallenge.goal) {
                            completed = true;
                        }
                    }
                    break;
                case 'combo':
                    dailyChallengeProgress = comboCount;
                    if (comboCount >= dailyChallenge.goal) {
                        completed = true;
                    }
                    break;
                case 'boss':
                    dailyChallengeProgress = dailyChallengeStats.bossesDefeatedNoLives;
                    if (dailyChallengeStats.bossesDefeatedNoLives >= dailyChallenge.goal) {
                        completed = true;
                    }
                    break;
                case 'accuracy':
                    if (dailyChallengeStats.shotsFired > 0) {
                        const accuracy = Math.round((dailyChallengeStats.shotsHit / dailyChallengeStats.shotsFired) * 100);
                        dailyChallengeProgress = accuracy;
                    }
                    break;
                case 'survival':
                    if (dailyChallengeStats.livesLostThisRound === 0) {
                        dailyChallengeProgress = level;
                        if (level >= dailyChallenge.goal) {
                            completed = true;
                        }
                    }
                    break;
                case 'powerup':
                    dailyChallengeProgress = dailyChallengeStats.powerupsCollected;
                    if (dailyChallengeStats.powerupsCollected >= dailyChallenge.goal) {
                        completed = true;
                    }
                    break;
                case 'ufo':
                    dailyChallengeProgress = dailyChallengeStats.ufosKilled;
                    if (dailyChallengeStats.ufosKilled >= dailyChallenge.goal) {
                        completed = true;
                    }
                    break;
            }

            if (completed) {
                completeDailyChallenge();
            }

            updateDailyChallengeUI();
        }

        function completeDailyChallenge() {
            if (dailyChallengeCompleted) return;

            dailyChallengeCompleted = true;
            playerCoins += dailyChallenge.reward;
            saveDailyChallenge();
            saveShopData();

            showDailyChallengeComplete();
        }

        function showDailyChallengeComplete() {
            const popup = document.createElement('div');
            popup.className = 'daily-challenge-complete';
            popup.innerHTML = `
                <div class="daily-complete-icon"></div>
                <div class="daily-complete-title">Daily Challenge Complete!</div>
                <div class="daily-complete-name">${dailyChallenge.name}</div>
                <div class="daily-complete-reward">+${dailyChallenge.reward} coins</div>
            `;
            document.body.appendChild(popup);

            setTimeout(() => {
                popup.classList.add('fade-out');
                setTimeout(() => popup.remove(), 500);
            }, 3000);
        }

        function updateDailyChallengeUI() {
            const container = document.getElementById('dailyChallengeContainer');
            if (!container || !dailyChallenge) return;

            container.innerHTML = `
                <div class="daily-challenge-header"> Daily Challenge</div>
                <div class="daily-challenge-name">${dailyChallenge.name}</div>
                <div class="daily-challenge-desc">${dailyChallenge.desc}</div>
                <div class="daily-challenge-progress">
                    ${dailyChallengeCompleted ? ' Completed!' : `Progress: ${dailyChallengeProgress}/${dailyChallenge.goal}`}
                </div>
                <div class="daily-challenge-reward">Reward: ${dailyChallenge.reward} coins</div>
            `;
        }

        // Update the start screen daily challenge panel
        function updateStartScreenChallenge() {
            if (!dailyChallenge) return;

            const nameEl = document.getElementById('challengeName');
            const descEl = document.getElementById('challengeDesc');
            const rewardEl = document.getElementById('challengeReward');
            const barEl = document.getElementById('challengeBar');
            const progressTextEl = document.getElementById('challengeProgressText');
            const timerEl = document.getElementById('challengeTimer');

            if (nameEl) nameEl.textContent = dailyChallenge.name;
            if (descEl) descEl.textContent = dailyChallenge.desc;
            if (rewardEl) rewardEl.textContent = dailyChallenge.reward;

            const progress = dailyChallengeCompleted ? 100 : Math.min(100, (dailyChallengeProgress / dailyChallenge.goal) * 100);
            if (barEl) barEl.style.width = progress + '%';
            if (progressTextEl) {
                progressTextEl.textContent = dailyChallengeCompleted
                    ? ' Completed!'
                    : `${dailyChallengeProgress} / ${dailyChallenge.goal}`;
            }

            // Update timer
            if (timerEl) {
                updateChallengeTimer();
                setInterval(updateChallengeTimer, 1000);
            }
        }

        function updateChallengeTimer() {
            const timerEl = document.getElementById('challengeTimer');
            if (!timerEl) return;

            const now = new Date();
            const tomorrow = new Date(now);
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setHours(0, 0, 0, 0);

            const diff = tomorrow - now;
            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);

            timerEl.textContent = `Resets in: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        loadDailyChallenge();
        updateStartScreenChallenge();

        // Weapon system
        const WEAPONS = {
            laser: {
                name: 'Laser',
                color: '#0ff',
                speed: 10,
                damage: 1,
                cooldown: 200,
                width: 4,
                height: 15,
                penetrating: false,
                splash: 0
            },
            missile: {
                name: 'Missile',
                color: '#f80',
                speed: 6,
                damage: 3,
                cooldown: 500,
                width: 8,
                height: 20,
                penetrating: false,
                splash: 30
            },
            plasma: {
                name: 'Plasma',
                color: '#f0f',
                speed: 12,
                damage: 1,
                cooldown: 150,
                width: 6,
                height: 25,
                penetrating: true,
                splash: 0
            }
        };
        let currentWeapon = 'laser';

        // Mark WEAPONS as initialized and apply upgrades
        weaponsInitialized = true;
        applyWeaponUpgrades();

        function selectWeapon(weapon) {
            if (!WEAPONS[weapon]) return;
            currentWeapon = weapon;

            // Update UI
            document.querySelectorAll('.weapon-btn').forEach(btn => btn.classList.remove('active'));
            const btnId = weapon === 'laser' ? 'weapon1' : weapon === 'missile' ? 'weapon2' : 'weapon3';
            document.getElementById(btnId).classList.add('active');

            // Update cooldown based on weapon (unless rapid fire is active)
            if (activePowerUp !== 'rapidFire') {
                shootCooldown = WEAPONS[weapon].cooldown;
            }

            // Play sound
            playShootSound();
        }

        // Calculate weapon damage including shop upgrades
        // Note: Weapon upgrade levels are already applied to WEAPONS via applyWeaponUpgrades()
        function calculateWeaponDamage(weapon, weaponKey) {
            let damage = weapon.damage;

            // Apply Bigger Bullets shop upgrade (+50% damage)
            if (hasUpgrade('biggerBullets')) {
                damage *= 1.5;
            }

            return Math.ceil(damage);
        }

        // Power-up system
        let powerUps = [];
        let activePowerUp = null;
        let powerUpTimer = 0;
        const POWERUP_TYPES = {
            shield: { color: '#0ff', duration: 8000, name: 'SHIELD', symbol: '' },
            rapidFire: { color: '#ff0', duration: 6000, name: 'RAPID FIRE', symbol: '' },
            spreadShot: { color: '#f0f', duration: 5000, name: 'SPREAD SHOT', symbol: '' },
            bomb: { color: '#f80', duration: 0, name: 'BOMB', symbol: '' },
            slowMotion: { color: '#88f', duration: 5000, name: 'SLOW-MO', symbol: '' },
            doublePoints: { color: '#0f0', duration: 10000, name: '2X POINTS', symbol: '2' },
            extraLife: { color: '#f55', duration: 0, name: 'EXTRA LIFE', symbol: '' },
            magnet: { color: '#fa0', duration: 8000, name: 'MAGNET', symbol: '' }
        };
        const POWERUP_DROP_CHANCE = 0.18;
        let doublePointsActive = false;
        let magnetActive = false;

        // Barrier system (destructible shields)
        let barriers = [];
        const BARRIER_SEGMENT_SIZE = 8;
        const BARRIER_ROWS = 4;
        const BARRIER_COLS = 6;

        function initBarriers() {
            barriers = [];
            const barrierWidth = BARRIER_COLS * BARRIER_SEGMENT_SIZE;
            const barrierCount = 4;
            const spacing = (canvas.width - barrierCount * barrierWidth) / (barrierCount + 1);

            for (let b = 0; b < barrierCount; b++) {
                const barrierX = spacing + b * (barrierWidth + spacing);
                const barrierY = canvas.height - 150;
                const segments = [];

                for (let row = 0; row < BARRIER_ROWS; row++) {
                    for (let col = 0; col < BARRIER_COLS; col++) {
                        // Skip corners to create classic shape
                        if ((row === 0 && (col === 0 || col === BARRIER_COLS - 1)) ||
                            (row === BARRIER_ROWS - 1 && col >= 2 && col <= 3)) {
                            continue;
                        }
                        segments.push({
                            x: barrierX + col * BARRIER_SEGMENT_SIZE,
                            y: barrierY + row * BARRIER_SEGMENT_SIZE,
                            health: 3
                        });
                    }
                }
                barriers.push({ segments });
            }
        }

        function drawBarriers() {
            barriers.forEach(barrier => {
                barrier.segments.forEach(seg => {
                    if (seg.health <= 0) return;
                    // Color based on health
                    const colors = ['#300', '#060', '#0a0', '#0f0'];
                    ctx.fillStyle = colors[seg.health] || '#0f0';
                    ctx.fillRect(seg.x, seg.y, BARRIER_SEGMENT_SIZE - 1, BARRIER_SEGMENT_SIZE - 1);
                });
            });
        }

        function checkBarrierCollisions(bulletList, isEnemy) {
            const bulletsToRemove = new Set();

            bulletList.forEach((bullet, bi) => {
                barriers.forEach(barrier => {
                    barrier.segments.forEach(seg => {
                        if (seg.health <= 0 || bulletsToRemove.has(bi)) return;

                        // Check collision
                        const bx = bullet.x;
                        const by = bullet.y;
                        if (bx >= seg.x && bx <= seg.x + BARRIER_SEGMENT_SIZE &&
                            by >= seg.y && by <= seg.y + BARRIER_SEGMENT_SIZE) {
                            seg.health--;
                            bulletsToRemove.add(bi);

                            // Small particle effect
                            if (seg.health <= 0) {
                                createExplosion(seg.x + BARRIER_SEGMENT_SIZE/2, seg.y + BARRIER_SEGMENT_SIZE/2, '#0f0', 3);
                            }
                        }
                    });
                });
            });

            return bulletsToRemove;
        }

        // UFO special enemy
        let ufo = null;
        let ufoTimer = 0;
        const UFO_SPAWN_INTERVAL = 15000; // 15 seconds between potential UFO spawns
        const UFO_SPAWN_CHANCE = 0.5;
        const UFO_POINTS = [50, 100, 150, 200, 300];

        function spawnUFO() {
            if (ufo) return;
            const direction = Math.random() < 0.5 ? 1 : -1;
            ufo = {
                x: direction === 1 ? -60 : canvas.width + 10,
                y: 30,
                width: 50,
                height: 25,
                speed: 2 + level * 0.2,
                direction: direction,
                points: UFO_POINTS[Math.floor(Math.random() * UFO_POINTS.length)]
            };
        }

        function updateUFO() {
            // Check if we should spawn a UFO
            if (!ufo && Date.now() - ufoTimer > UFO_SPAWN_INTERVAL) {
                ufoTimer = Date.now();
                if (Math.random() < UFO_SPAWN_CHANCE) {
                    spawnUFO();
                }
            }

            if (!ufo) return;

            // Move UFO
            ufo.x += ufo.speed * ufo.direction;

            // Remove if off screen
            if ((ufo.direction === 1 && ufo.x > canvas.width + 10) ||
                (ufo.direction === -1 && ufo.x < -70)) {
                ufo = null;
            }
        }

        function drawUFO() {
            if (!ufo) return;

            // UFO body (classic flying saucer shape)
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.ellipse(ufo.x + ufo.width/2, ufo.y + ufo.height/2, ufo.width/2, ufo.height/3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Dome
            ctx.fillStyle = '#ff0';
            ctx.beginPath();
            ctx.ellipse(ufo.x + ufo.width/2, ufo.y + ufo.height/3, ufo.width/4, ufo.height/3, 0, Math.PI, Math.PI * 2);
            ctx.fill();

            // Lights (blinking)
            if (Math.floor(Date.now() / 200) % 2 === 0) {
                ctx.fillStyle = '#0ff';
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(ufo.x + 10 + i * 15, ufo.y + ufo.height/2 + 5, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function checkUFOCollision(bullet) {
            if (!ufo) return false;
            if (bullet.x > ufo.x && bullet.x < ufo.x + ufo.width &&
                bullet.y > ufo.y && bullet.y < ufo.y + ufo.height) {
                // UFO hit!
                createExplosion(ufo.x + ufo.width/2, ufo.y + ufo.height/2, '#f00', 15);
                playExplosionSound('boss');
                triggerScreenShake(6, 250);

                // Bonus points with combo
                const comboPoints = addComboKill(ufo.points);
                addScore(comboPoints);
                document.getElementById('scoreValue').textContent = score;
                updateSessionStats('kill');
                updateSessionStats('score', score);
                dailyChallengeStats.ufosKilled++;
                announce('ufoKill');

                // Higher chance for power-up
                if (Math.random() < 0.5) {
                    powerUps.push({
                        x: ufo.x + ufo.width/2,
                        y: ufo.y + ufo.height/2,
                        type: Object.keys(POWERUP_TYPES)[Math.floor(Math.random() * Object.keys(POWERUP_TYPES).length)],
                        width: 25,
                        height: 25,
                        speed: 2
                    });
                }

                ufo = null;
                return true;
            }
            return false;
        }

        // Slow-motion effect
        let slowMotionFactor = 1;
        let slowMotionDuration = 0;
        let slowMotionStartTime = 0;
        let slowMotionTargetFactor = 1;

        function triggerSlowMotion(factor = 0.3, duration = 1000) {
            slowMotionFactor = factor;
            slowMotionTargetFactor = 1;
            slowMotionDuration = duration;
            slowMotionStartTime = Date.now();
        }

        function updateSlowMotion() {
            if (slowMotionDuration <= 0) {
                slowMotionFactor = 1;
                return;
            }

            const elapsed = Date.now() - slowMotionStartTime;
            if (elapsed >= slowMotionDuration) {
                slowMotionDuration = 0;
                slowMotionFactor = 1;
                return;
            }

            // Start at slow speed, quickly ramp up to normal in last 30% of duration
            const progress = elapsed / slowMotionDuration;
            if (progress > 0.7) {
                // Ramp up in final 30%
                const rampProgress = (progress - 0.7) / 0.3;
                slowMotionFactor = slowMotionFactor + (1 - slowMotionFactor) * rampProgress * 0.3;
            }
        }

        // ==========================================
        // BULLET TIME KILL-CAM
        // ==========================================
        let bulletTimeActive = false;
        let bulletTimeFocusX = 0;
        let bulletTimeFocusY = 0;
        let bulletTimeStartTime = 0;
        let bulletTimeDuration = 600;  // Shorter duration

        function triggerBulletTimeKillCam(x, y) {
            bulletTimeActive = true;
            bulletTimeFocusX = x;
            bulletTimeFocusY = y;
            bulletTimeStartTime = Date.now();

            // Trigger slow motion (less extreme - 50% speed instead of 15%)
            triggerSlowMotion(0.5, bulletTimeDuration);

            // Screen shake for impact
            triggerScreenShake(10, 300);

            // Play dramatic sound
            if (audioContext) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
                gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                osc.start();
                osc.stop(audioContext.currentTime + 0.5);
            }

            // Show dramatic text
            show3DRotatingText('WAVE CLEARED!', 2000);
        }

        function drawBulletTimeEffect() {
            if (!bulletTimeActive) return;

            const elapsed = Date.now() - bulletTimeStartTime;
            if (elapsed >= bulletTimeDuration) {
                bulletTimeActive = false;
                return;
            }

            const progress = elapsed / bulletTimeDuration;

            // Vignette effect - dark edges focusing on kill location
            const vignetteRadius = canvas.width * (0.8 - progress * 0.3);
            const gradient = ctx.createRadialGradient(
                bulletTimeFocusX, bulletTimeFocusY, 0,
                bulletTimeFocusX, bulletTimeFocusY, vignetteRadius
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(0.8, `rgba(0, 0, 0, ${0.4 * (1 - progress)})`);
            gradient.addColorStop(1, `rgba(0, 0, 0, ${0.7 * (1 - progress)})`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Radial lines emanating from kill point (speed lines)
            ctx.strokeStyle = `rgba(255, 200, 100, ${0.3 * (1 - progress)})`;
            ctx.lineWidth = 2;
            const numLines = 16;
            for (let i = 0; i < numLines; i++) {
                const angle = (i / numLines) * Math.PI * 2;
                const innerRadius = 50 + progress * 50;
                const outerRadius = 150 + progress * 100;
                ctx.beginPath();
                ctx.moveTo(
                    bulletTimeFocusX + Math.cos(angle) * innerRadius,
                    bulletTimeFocusY + Math.sin(angle) * innerRadius
                );
                ctx.lineTo(
                    bulletTimeFocusX + Math.cos(angle) * outerRadius,
                    bulletTimeFocusY + Math.sin(angle) * outerRadius
                );
                ctx.stroke();
            }

            // Pulsing ring at kill location
            const ringRadius = 30 + progress * 100;
            ctx.strokeStyle = `rgba(255, 255, 0, ${0.5 * (1 - progress)})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(bulletTimeFocusX, bulletTimeFocusY, ringRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Chrome aberration effect on edges
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = `rgba(255, 0, 0, ${0.05 * (1 - progress)})`;
            ctx.fillRect(0, 0, 3, canvas.height);
            ctx.fillStyle = `rgba(0, 255, 255, ${0.05 * (1 - progress)})`;
            ctx.fillRect(canvas.width - 3, 0, 3, canvas.height);
            ctx.globalCompositeOperation = 'source-over';
        }

        // Screen shake effect
        let shakeIntensity = 0;
        let shakeDuration = 0;
        let shakeStartTime = 0;

        function triggerScreenShake(intensity = 5, duration = 200) {
            shakeIntensity = intensity;
            shakeDuration = duration;
            shakeStartTime = Date.now();
        }

        function applyScreenShake() {
            if (shakeDuration <= 0) return { x: 0, y: 0 };

            const elapsed = Date.now() - shakeStartTime;
            if (elapsed >= shakeDuration) {
                shakeDuration = 0;
                return { x: 0, y: 0 };
            }

            // Decrease intensity over time
            const progress = 1 - (elapsed / shakeDuration);
            const currentIntensity = shakeIntensity * progress;

            return {
                x: (Math.random() - 0.5) * currentIntensity * 2,
                y: (Math.random() - 0.5) * currentIntensity * 2
            };
        }

        // Chromatic aberration effect (on player damage)
        function triggerChromaticAberration() {
            const canvas = document.getElementById('gameCanvas');
            if (canvas) {
                canvas.classList.add('chromatic-aberration');
                setTimeout(() => {
                    canvas.classList.remove('chromatic-aberration');
                }, 100);
            }
        }

        // Screen flash effect (on big kills/events)
        function triggerScreenFlash(color = '#fff') {
            const flash = document.getElementById('screenFlash');
            if (flash) {
                flash.style.background = color;
                flash.classList.remove('active');
                void flash.offsetWidth; // Force reflow
                flash.classList.add('active');
                setTimeout(() => {
                    flash.classList.remove('active');
                }, 150);
            }
        }

        // Boss system
        let currentBoss = null;
        const BOSS_LEVELS = [5, 10, 15, 20, 25];

        // Pause and Mute functions
        function togglePause() {
            if (!gameRunning && !gamePaused) return;

            if (gamePaused) {
                // Resume game
                setUIState('playing');
                document.getElementById('pauseBtn').textContent = '';
                requestAnimationFrame(gameLoop);
            } else {
                // Pause game
                setUIState('paused');
                document.getElementById('pauseScreen').classList.remove('hidden');
                document.getElementById('pauseBtn').textContent = '';
                syncPauseVolumeSliders();
            }

            // Update mobile controls visibility based on pause state
            updateMobileControlsVisibility();
        }

        function syncPauseVolumeSliders() {
            const sfxSlider = document.getElementById('pauseSfxVolume');
            const musicSlider = document.getElementById('pauseMusicVolume');
            const sfxValue = document.getElementById('pauseSfxValue');
            const musicValue = document.getElementById('pauseMusicValue');

            if (sfxSlider) {
                sfxSlider.value = sfxVolume;
                if (sfxValue) sfxValue.textContent = sfxVolume + '%';
            }
            if (musicSlider) {
                musicSlider.value = musicVolumeLevel;
                if (musicValue) musicValue.textContent = musicVolumeLevel + '%';
            }
        }

        function updateSfxVolume(value) {
            sfxVolume = parseInt(value);
            const sfxValue = document.getElementById('pauseSfxValue');
            if (sfxValue) sfxValue.textContent = sfxVolume + '%';
            // Play a sample sound to preview volume
            playSelectSound();
        }

        function updateMusicVolume(value) {
            musicVolumeLevel = parseInt(value);
            const musicValue = document.getElementById('pauseMusicValue');
            if (musicValue) musicValue.textContent = musicVolumeLevel + '%';
            // Update current music volume
            if (gameMusic && gameMusic.gain) {
                gameMusic.gain.gain.setValueAtTime(musicVolumeLevel / 100, audioContext.currentTime);
            }
        }

        function restartFromPause() {
            // Close pause menu
            gamePaused = false;
            document.getElementById('pauseScreen').classList.add('hidden');
            document.getElementById('pauseBtn').textContent = '';

            // Reset current level state but keep the level number
            enemies = [];
            bullets = [];
            enemyBullets = [];
            powerUps = [];
            explosions = [];
            currentBoss = null;

            // Reset player position
            player.x = canvas.width / 2 - player.width / 2;
            player.y = canvas.height - 100;

            // Reset player 2 if active
            if (twoPlayerMode && player2) {
                player2.x = canvas.width / 2 - player2.width / 2 + 50;
                player2.y = canvas.height - 100;
            }

            // Respawn enemies for current level
            spawnEnemies();

            // Continue game
            requestAnimationFrame(gameLoop);
            playSelectSound();
        }

        function quitToMenu() {
            // Stop game music
            stopMusic();

            // Reset game state
            enemies = [];
            bullets = [];
            enemyBullets = [];
            powerUps = [];
            particles = [];
            currentBoss = null;

            // Show start screen (setUIState handles hiding pause, setting gameRunning/gamePaused)
            backToMenu();
            playSelectSound();
        }

        function toggleMute() {
            soundMuted = !soundMuted;
            const muteBtn = document.getElementById('muteBtn');
            if (muteBtn) {
                muteBtn.textContent = soundMuted ? '' : '';
                muteBtn.classList.toggle('muted', soundMuted);
            }
            // Also update menu sound button
            const menuSoundBtn = document.getElementById('menuSoundBtn');
            if (menuSoundBtn) {
                const iconSpan = menuSoundBtn.querySelector('.btn-icon');
                if (iconSpan) iconSpan.textContent = soundMuted ? '' : '';
                menuSoundBtn.classList.toggle('active', !soundMuted);
            }
        }

        function toggleSound() {
            toggleMute();
        }

        // Power-up functions
        function spawnPowerUp(x, y) {
            if (Math.random() > POWERUP_DROP_CHANCE) return;
            const types = Object.keys(POWERUP_TYPES);
            const type = types[Math.floor(Math.random() * types.length)];
            powerUps.push({
                x: x,
                y: y,
                type: type,
                width: 25,
                height: 25,
                speed: 2
            });
        }

        function activatePowerUp(type) {
            const pu = POWERUP_TYPES[type];

            // Track power-up for daily challenge
            updateDailyChallengeProgress('powerups', 1);
            // Track lifetime stats
            updateLifetimeStat('powerUpsCollected', 1, 'add');

            // Instant effect power-ups (no duration)
            if (type === 'bomb') {
                // Bomb kills all enemies on screen - each kill adds to combo
                enemies.forEach(enemy => {
                    createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#f80', 8);
                    const comboPoints = addComboKill(enemy.points);
                    addScore(comboPoints);
                });
                enemies = [];
                playExplosionSound('boss');
                triggerScreenShake(10, 400);
                document.getElementById('scoreValue').textContent = score;
                return;
            }

            if (type === 'extraLife') {
                // Extra life - add one life (max 5)
                if (lives < 5) {
                    lives++;
                    updateLivesDisplay();
                    announce('powerUp');
                }
                return;
            }

            // Duration-based power-ups
            activePowerUp = type;
            const duration = hasUpgrade('longerPowerups') ? Math.floor(pu.duration * 1.5) : pu.duration;
            powerUpTimer = Date.now() + duration;
            document.getElementById('powerupIndicator').textContent = pu.name + ' ACTIVE';
            document.getElementById('powerupIndicator').style.color = pu.color;
            document.getElementById('powerupIndicator').classList.remove('hidden');
            announce('powerUp');

            if (type === 'rapidFire') {
                shootCooldown = 80;
            } else if (type === 'slowMotion') {
                triggerSlowMotion(0.4, duration);
            } else if (type === 'doublePoints') {
                doublePointsActive = true;
            } else if (type === 'magnet') {
                magnetActive = true;
            }
        }

        function updatePowerUps() {
            // Update falling power-ups
            powerUps = powerUps.filter(pu => {
                pu.y += pu.speed;
                // Check collision with player
                if (pu.x < player.x + player.width && pu.x + pu.width > player.x &&
                    pu.y < player.y + player.height && pu.y + pu.height > player.y) {
                    activatePowerUp(pu.type);
                    playLevelUpSound();
                    updateSessionStats('powerUp');
                    dailyChallengeStats.powerupsCollected++;

                    // Visual feedback: Floating power-up text
                    const puInfo = POWERUP_TYPES[pu.type];
                    if (puInfo) {
                        showFloatingText(player.x + player.width / 2, player.y, '+' + puInfo.name, 'powerup');
                        // Colorful particle burst effect
                        createPowerUpParticles(pu.x + pu.width / 2, pu.y + pu.height / 2, puInfo.color);
                    }

                    return false;
                }
                return pu.y < canvas.height;
            });

            // Check active power-up timer
            if (activePowerUp && powerUpTimer < Date.now()) {
                if (activePowerUp === 'rapidFire') {
                    shootCooldown = 200;
                } else if (activePowerUp === 'doublePoints') {
                    doublePointsActive = false;
                } else if (activePowerUp === 'magnet') {
                    magnetActive = false;
                }
                activePowerUp = null;
                document.getElementById('powerupIndicator').classList.add('hidden');
            }

            // Magnet effect - attract power-ups towards player
            if (magnetActive) {
                powerUps.forEach(pu => {
                    const dx = (player.x + player.width / 2) - (pu.x + pu.width / 2);
                    const dy = (player.y + player.height / 2) - (pu.y + pu.height / 2);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 200) {
                        pu.x += dx * 0.05;
                        pu.y += dy * 0.05;
                    }
                });
            }
        }

        function drawPowerUps() {
            powerUps.forEach(pu => {
                const puType = POWERUP_TYPES[pu.type];
                const color = puType.color;

                // Glow effect
                ctx.shadowColor = color;
                ctx.shadowBlur = 15;

                // Pulsing animation
                const pulse = 1 + Math.sin(Date.now() / 200) * 0.1;
                const size = pu.width * pulse;

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(pu.x + pu.width/2, pu.y + pu.height/2, size/2, 0, Math.PI * 2);
                ctx.fill();

                // Inner circle
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.beginPath();
                ctx.arc(pu.x + pu.width/2, pu.y + pu.height/2, size/3, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;

                // Symbol
                ctx.font = '14px Inter, system-ui, Arial, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(puType.symbol, pu.x + pu.width/2, pu.y + pu.height/2);
            });
        }

        // Boss type definitions
        const BOSS_TYPES = {
            guardian: {
                name: 'GUARDIAN',
                color: '#f00',
                eyeColor: '#ff0',
                width: 150,
                height: 80,
                baseHealth: 50,
                patterns: ['single', 'spread', 'aimed']
            },
            destroyer: {
                name: 'DESTROYER',
                color: '#f0f',
                eyeColor: '#0ff',
                width: 180,
                height: 90,
                baseHealth: 70,
                patterns: ['laser', 'spiral', 'wave']
            },
            mothership: {
                name: 'MOTHERSHIP',
                color: '#0f0',
                eyeColor: '#f00',
                width: 200,
                height: 100,
                baseHealth: 100,
                patterns: ['spawn', 'barrage', 'bombs']
            }
        };

        // Boss functions
        function spawnBoss() {
            // Determine boss type based on level
            let bossType;
            if (level >= 15) {
                bossType = 'mothership';
            } else if (level >= 10) {
                bossType = 'destroyer';
            } else {
                bossType = 'guardian';
            }

            const bossData = BOSS_TYPES[bossType];
            currentBoss = {
                x: canvas.width / 2 - bossData.width / 2,
                y: -bossData.height,
                targetY: 50,
                width: bossData.width,
                height: bossData.height,
                health: bossData.baseHealth + level * 10,
                maxHealth: bossData.baseHealth + level * 10,
                direction: 1,
                speed: 2 + level * 0.2,
                shootTimer: 0,
                pattern: 0,
                patternTimer: 0,
                type: bossType,
                phase: 1,
                entering: true,
                laserCharging: false,
                laserTimer: 0,
                spawnTimer: 0,
                angle: 0
            };
            document.getElementById('bossHealth').classList.remove('hidden');
            document.getElementById('bossName').textContent = bossData.name;
            updateBossHealthBar();
            announce('bossAppear');

            // 3D Boss entrance effects
            show3DRotatingText(' BOSS ', 2500);
            show3DScrollText([
                '- WARNING -',
                bossData.name.toUpperCase(),
                'APPROACHING',
                '',
                'PREPARE FOR BATTLE!'
            ], 4000);

            // Start intense boss music
            startBossMusic();
        }

        // Endless mode functions
        function updateEndlessMode() {
            if (!endlessMode) return;

            // Update timer display
            const elapsed = Math.floor((Date.now() - endlessStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            document.getElementById('endlessTimer').textContent = ` ${minutes}:${seconds}`;
            document.getElementById('endlessWave').textContent = `Wave ${endlessWave}`;

            // Spawn new enemies continuously
            if (Date.now() - endlessSpawnTimer > endlessSpawnInterval) {
                spawnEndlessWave();
                endlessSpawnTimer = Date.now();
            }

            // Increase difficulty over time
            if (elapsed > 0 && elapsed % 30 === 0) {
                endlessSpawnInterval = Math.max(1000, endlessSpawnInterval - 100);
            }
        }

        function spawnEndlessWave() {
            const numEnemies = Math.min(3 + Math.floor(endlessWave / 2), 8);

            for (let i = 0; i < numEnemies; i++) {
                const x = Math.random() * (canvas.width - 40);
                const types = ['basic', 'basic', 'medium'];
                if (endlessWave >= 5) types.push('medium');
                if (endlessWave >= 10) types.push('medium');

                const type = types[Math.floor(Math.random() * types.length)];
                const enemyData = type === 'medium' ?
                    { width: 35, height: 25, points: 20, color: '#0f0' } :
                    { width: 30, height: 20, points: 10, color: '#ff0' };

                enemies.push({
                    x: x,
                    y: -30 - (i * 40),
                    width: enemyData.width,
                    height: enemyData.height,
                    type: type,
                    points: enemyData.points,
                    shootChance: 0.003 + endlessWave * 0.0005
                });
            }

            endlessWave++;
        }

        function updateBoss() {
            if (!currentBoss) return;

            // Entry animation
            if (currentBoss.entering) {
                currentBoss.y += 2;
                if (currentBoss.y >= currentBoss.targetY) {
                    currentBoss.y = currentBoss.targetY;
                    currentBoss.entering = false;
                }
                return;
            }

            // Determine phase based on health
            const healthPercent = currentBoss.health / currentBoss.maxHealth;
            currentBoss.phase = healthPercent > 0.5 ? 1 : healthPercent > 0.25 ? 2 : 3;
            const speedBoost = currentBoss.phase === 3 ? 1.5 : currentBoss.phase === 2 ? 1.2 : 1;

            // Movement
            currentBoss.x += currentBoss.speed * currentBoss.direction * speedBoost * slowMotionFactor;
            if (currentBoss.x <= 0 || currentBoss.x + currentBoss.width >= canvas.width) {
                currentBoss.direction *= -1;
            }

            // Update angle for spiral patterns
            currentBoss.angle += 0.05 * slowMotionFactor;

            // Shooting based on boss type and phase
            currentBoss.shootTimer++;
            currentBoss.patternTimer++;

            const bossData = BOSS_TYPES[currentBoss.type];
            const shootInterval = Math.max(15, 40 - currentBoss.phase * 10);

            if (currentBoss.shootTimer > shootInterval) {
                currentBoss.shootTimer = 0;
                const pattern = bossData.patterns[currentBoss.pattern % bossData.patterns.length];
                const centerX = currentBoss.x + currentBoss.width / 2;
                const bottomY = currentBoss.y + currentBoss.height;

                // Execute attack pattern
                if (pattern === 'single') {
                    enemyBullets.push({ x: centerX, y: bottomY, speed: 5 + currentBoss.phase });
                } else if (pattern === 'spread') {
                    for (let i = -2; i <= 2; i++) {
                        enemyBullets.push({
                            x: centerX,
                            y: bottomY,
                            speed: 4,
                            vx: i * 1.5,
                            vy: 4
                        });
                    }
                } else if (pattern === 'aimed') {
                    // Aim at player
                    const dx = (player.x + player.width / 2) - centerX;
                    const dy = (player.y + player.height / 2) - bottomY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    enemyBullets.push({
                        x: centerX,
                        y: bottomY,
                        speed: 6,
                        vx: (dx / dist) * 6,
                        vy: (dy / dist) * 6
                    });
                } else if (pattern === 'spiral') {
                    for (let i = 0; i < 4; i++) {
                        const angle = currentBoss.angle + (i * Math.PI / 2);
                        enemyBullets.push({
                            x: centerX,
                            y: bottomY,
                            speed: 4,
                            vx: Math.cos(angle) * 3,
                            vy: Math.sin(angle) * 3 + 2
                        });
                    }
                } else if (pattern === 'wave') {
                    for (let i = 0; i < 7; i++) {
                        const offset = Math.sin(currentBoss.patternTimer * 0.1 + i) * 30;
                        enemyBullets.push({ x: centerX + offset, y: bottomY, speed: 3 });
                    }
                } else if (pattern === 'laser') {
                    // Laser beam - multiple fast bullets in a line
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            if (currentBoss) {
                                enemyBullets.push({
                                    x: currentBoss.x + currentBoss.width / 2,
                                    y: currentBoss.y + currentBoss.height,
                                    speed: 8,
                                    isLaser: true
                                });
                            }
                        }, i * 50);
                    }
                } else if (pattern === 'spawn') {
                    // Spawn minions
                    if (enemies.length < 5) {
                        enemies.push({
                            x: centerX - 20,
                            y: bottomY,
                            width: 30,
                            height: 20,
                            type: 'basic',
                            points: 15,
                            health: 1,
                            speedMultiplier: 1.5
                        });
                    }
                } else if (pattern === 'barrage') {
                    // Barrage of bullets
                    for (let i = 0; i < 10; i++) {
                        const angle = (i / 10) * Math.PI - Math.PI / 2;
                        enemyBullets.push({
                            x: centerX,
                            y: bottomY,
                            speed: 3,
                            vx: Math.cos(angle) * 3,
                            vy: Math.sin(angle) * 3 + 2
                        });
                    }
                } else if (pattern === 'bombs') {
                    // Drop bombs that explode
                    enemyBullets.push({
                        x: centerX,
                        y: bottomY,
                        speed: 2,
                        isBomb: true,
                        timer: 60
                    });
                }

                currentBoss.pattern++;
                playEnemyShootSound();
            }
        }

        function drawBoss() {
            if (!currentBoss) return;

            const bossData = BOSS_TYPES[currentBoss.type];
            const cx = currentBoss.x + currentBoss.width / 2;
            const cy = currentBoss.y + currentBoss.height / 2;

            ctx.save();

            // Glow effect based on phase
            const glowIntensity = currentBoss.phase === 3 ? 25 : currentBoss.phase === 2 ? 15 : 10;
            ctx.shadowColor = bossData.color;
            ctx.shadowBlur = glowIntensity;

            // Phase color shift
            let bodyColor = bossData.color;
            if (currentBoss.phase === 3) {
                bodyColor = '#f00'; // Red when enraged
            } else if (currentBoss.phase === 2) {
                bodyColor = bossData.color.replace('0', '8'); // Brighter
            }

            if (currentBoss.type === 'guardian') {
                // Guardian - Skull-like appearance
                ctx.fillStyle = bodyColor;
                // Main body
                ctx.beginPath();
                ctx.ellipse(cx, cy, currentBoss.width / 2.2, currentBoss.height / 2.2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Horns
                ctx.beginPath();
                ctx.moveTo(currentBoss.x + 20, currentBoss.y + 30);
                ctx.lineTo(currentBoss.x - 10, currentBoss.y - 20);
                ctx.lineTo(currentBoss.x + 40, currentBoss.y + 20);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(currentBoss.x + currentBoss.width - 20, currentBoss.y + 30);
                ctx.lineTo(currentBoss.x + currentBoss.width + 10, currentBoss.y - 20);
                ctx.lineTo(currentBoss.x + currentBoss.width - 40, currentBoss.y + 20);
                ctx.fill();

                // Eyes
                ctx.fillStyle = bossData.eyeColor;
                ctx.beginPath();
                ctx.arc(cx - 30, cy - 10, 12, 0, Math.PI * 2);
                ctx.arc(cx + 30, cy - 10, 12, 0, Math.PI * 2);
                ctx.fill();

                // Mouth
                ctx.fillStyle = '#000';
                ctx.fillRect(cx - 25, cy + 15, 50, 15);
                for (let i = 0; i < 5; i++) {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(cx - 20 + i * 10, cy + 15, 5, 15);
                }

            } else if (currentBoss.type === 'destroyer') {
                // Destroyer - Mechanical look
                ctx.fillStyle = bodyColor;
                // Main body - hexagonal
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                    const x = cx + Math.cos(angle) * currentBoss.width / 2.2;
                    const y = cy + Math.sin(angle) * currentBoss.height / 2.2;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();

                // Core
                ctx.fillStyle = bossData.eyeColor;
                ctx.beginPath();
                ctx.arc(cx, cy, 25, 0, Math.PI * 2);
                ctx.fill();

                // Rotating parts
                ctx.strokeStyle = bodyColor;
                ctx.lineWidth = 4;
                for (let i = 0; i < 3; i++) {
                    const angle = currentBoss.angle * 2 + (i * Math.PI * 2 / 3);
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * 50, cy + Math.sin(angle) * 40);
                    ctx.stroke();
                }

                // Cannons
                ctx.fillStyle = '#555';
                ctx.fillRect(currentBoss.x + 10, currentBoss.y + currentBoss.height - 20, 20, 25);
                ctx.fillRect(currentBoss.x + currentBoss.width - 30, currentBoss.y + currentBoss.height - 20, 20, 25);

            } else if (currentBoss.type === 'mothership') {
                // Mothership - UFO style
                ctx.fillStyle = bodyColor;
                // Dome
                ctx.beginPath();
                ctx.ellipse(cx, cy - 15, 50, 35, 0, Math.PI, 0);
                ctx.fill();

                // Body
                ctx.beginPath();
                ctx.ellipse(cx, cy + 10, currentBoss.width / 2, 30, 0, 0, Math.PI * 2);
                ctx.fill();

                // Lights around edge
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + currentBoss.angle;
                    const lx = cx + Math.cos(angle) * (currentBoss.width / 2 - 15);
                    const ly = cy + 10 + Math.sin(angle) * 20;
                    ctx.fillStyle = i % 2 === 0 ? '#ff0' : '#0ff';
                    ctx.beginPath();
                    ctx.arc(lx, ly, 6, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Central eye
                ctx.fillStyle = bossData.eyeColor;
                ctx.beginPath();
                ctx.arc(cx, cy + 25, 15, 0, Math.PI * 2);
                ctx.fill();

                // Beam effect when spawning
                if (currentBoss.pattern % 3 === 0 && enemies.length < 5) {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(cx - 20, cy + currentBoss.height / 2);
                    ctx.lineTo(cx + 20, cy + currentBoss.height / 2);
                    ctx.lineTo(cx + 40, canvas.height);
                    ctx.lineTo(cx - 40, canvas.height);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            ctx.restore();
        }

        function updateBossHealthBar() {
            if (!currentBoss) return;
            const percent = (currentBoss.health / currentBoss.maxHealth) * 100;
            document.getElementById('bossHealthFill').style.width = percent + '%';
        }

        function damageBoss(damage) {
            if (!currentBoss) return false;
            currentBoss.health -= damage;
            updateBossHealthBar();
            playEnemyHitSound(); // Hit feedback

            if (currentBoss.health <= 0) {
                // Boss defeated
                createExplosion(currentBoss.x + currentBoss.width/2, currentBoss.y + currentBoss.height/2, '#f00', 30);
                score += 500 + level * 100;
                document.getElementById('scoreValue').textContent = score;
                playExplosionSound('boss');
                triggerScreenShake(12, 500);
                triggerSlowMotion(0.2, 1500);
                triggerScreenFlash('rgba(255, 255, 255, 0.5)');
                triggerChromaticAberration();
                announce('bossDefeat');

                // Stop boss music and play victory fanfare
                stopBossMusic();
                playVictoryFanfare();

                // Track boss defeated without losing life for daily challenge
                if (dailyChallengeStats.livesLostThisRound === 0) {
                    dailyChallengeStats.bossesDefeatedNoLives++;
                    checkDailyChallenge();
                }

                // Spawn power-up from boss (guaranteed)
                powerUps.push({
                    x: currentBoss.x + currentBoss.width/2,
                    y: currentBoss.y + currentBoss.height/2,
                    type: Object.keys(POWERUP_TYPES)[Math.floor(Math.random() * Object.keys(POWERUP_TYPES).length)],
                    width: 25,
                    height: 25,
                    speed: 2
                });

                currentBoss = null;
                document.getElementById('bossHealth').classList.add('hidden');

                // Track boss kill for achievements
                updateSessionStats('bossKill');
                // Track for daily challenges
                updateDailyChallengeProgress('bosses', 1);
                // Track lifetime stats
                updateLifetimeStat('bossKills', 1, 'add');

                // Handle Boss Rush mode differently
                if (bossRushMode) {
                    onBossRushBossDefeated();
                    return true;
                }

                // Level up and spawn next wave
                level++;
                document.getElementById('levelValue').textContent = level;
                playLevelUpSound();
                updateSessionStats('level', level);
                initEnemies();
                return true;
            }
            return false;
        }

        // Global Highscore system using JSONBlob
        const JSONBLOB_ID = '019bc699-3ad3-72d4-b829-0b138c882139';
        const JSONBLOB_URL = `https://jsonblob.com/api/jsonBlob/${JSONBLOB_ID}`;
        const CORS_PROXY = 'https://api.codetabs.com/v1/proxy?quest=';
        const MAX_HIGHSCORES = 10;
        const LOCAL_STORAGE_KEY = 'spaceInvadersHighscores';
        let cachedHighscores = [];
        let highscoresLoaded = false;
        let highscoreViewMode = 'alltime'; // 'alltime' or 'weekly'

        // Get ISO week number from a date
        function getWeekNumber(d) {
            const date = new Date(d);
            date.setHours(0, 0, 0, 0);
            date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
            const week1 = new Date(date.getFullYear(), 0, 4);
            return {
                year: date.getFullYear(),
                week: 1 + Math.round(((date - week1) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7)
            };
        }

        // Get current week identifier
        function getCurrentWeek() {
            const { year, week } = getWeekNumber(new Date());
            return `${year}-W${week.toString().padStart(2, '0')}`;
        }

        // Load from localStorage as fallback
        function loadLocalHighscores() {
            try {
                const data = localStorage.getItem(LOCAL_STORAGE_KEY);
                return data ? JSON.parse(data) : [];
            } catch (e) {
                return [];
            }
        }

        // Save to localStorage as backup
        function saveLocalHighscores(highscores) {
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(highscores));
            } catch (e) {}
        }

        async function fetchHighscores() {
            // First load local as fallback
            cachedHighscores = loadLocalHighscores();

            try {
                const response = await fetch(CORS_PROXY + JSONBLOB_URL);
                if (response.ok) {
                    const data = await response.json();
                    if (data.highscores && data.highscores.length > 0) {
                        // Merge server and local highscores
                        const merged = [...data.highscores, ...cachedHighscores];
                        // Remove duplicates (same name + score)
                        const unique = merged.filter((item, index, self) =>
                            index === self.findIndex(t => t.name === item.name && t.score === item.score)
                        );
                        unique.sort((a, b) => b.score - a.score);
                        cachedHighscores = unique.slice(0, MAX_HIGHSCORES);
                        saveLocalHighscores(cachedHighscores);
                    }
                }
            } catch (e) {
                // Fallback to local highscores
            }

            highscoresLoaded = true;
            return cachedHighscores;
        }

        function getHighscores() {
            return cachedHighscores;
        }

        async function saveHighscore(name, newScore) {
            // Add new score with week tracking
            cachedHighscores.push({
                name: name,
                score: newScore,
                date: Date.now(),
                week: getCurrentWeek()
            });
            cachedHighscores.sort((a, b) => b.score - a.score);
            cachedHighscores = cachedHighscores.slice(0, MAX_HIGHSCORES);

            // Always save locally first
            saveLocalHighscores(cachedHighscores);

            // Try to save to server
            let serverSaved = false;
            try {
                const response = await fetch(JSONBLOB_URL, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({ highscores: cachedHighscores })
                });
                if (response.ok) {
                    serverSaved = true;
                    console.log('Highscore saved to server successfully');
                } else {
                    console.warn('Server returned error:', response.status);
                }
            } catch (e) {
                console.warn('Could not save to server:', e.message);
            }

            // Show feedback to user
            if (!serverSaved) {
                console.log('Highscore saved locally (server unavailable)');
            }

            return cachedHighscores;
        }

        function isHighscore(newScore) {
            if (cachedHighscores.length < MAX_HIGHSCORES) return true;
            return newScore > cachedHighscores[cachedHighscores.length - 1].score;
        }

        function renderHighscores(containerId, currentScore = null) {
            const container = document.getElementById(containerId);
            const currentWeek = getCurrentWeek();

            if (!highscoresLoaded) {
                container.innerHTML = '<h3> GLOBAL HIGHSCORES </h3><p style="text-align:center;opacity:0.7;">Loading...</p>';
                return;
            }

            // Filter scores based on view mode
            let displayScores = cachedHighscores;
            if (highscoreViewMode === 'weekly') {
                displayScores = cachedHighscores.filter(entry => entry.week === currentWeek);
            }

            // Create tabs HTML
            let html = `
                <div class="highscore-tabs">
                    <button class="highscore-tab ${highscoreViewMode === 'alltime' ? 'active' : ''}"
                            onclick="setHighscoreView('alltime', '${containerId}')">
                         All Time
                    </button>
                    <button class="highscore-tab ${highscoreViewMode === 'weekly' ? 'active' : ''}"
                            onclick="setHighscoreView('weekly', '${containerId}')">
                         This Week
                    </button>
                </div>
            `;

            const title = highscoreViewMode === 'weekly' ? 'WEEKLY LEADERBOARD' : 'GLOBAL HIGHSCORES';

            if (displayScores.length === 0) {
                html += `<h3> ${title} </h3><p style="text-align:center;color:#0ff;font-family:'Orbitron',sans-serif;font-size:14px;padding:20px 10px;text-shadow:0 0 10px rgba(0,255,255,0.5);">${highscoreViewMode === 'weekly' ? 'No scores this week - be the first!' : 'No highscores yet - be the first!'}</p>`;
                container.innerHTML = html;
                return;
            }

            html += `<h3> ${title} </h3>`;
            html += `<div class="highscore-scroll-wrapper">`;
            html += `<div class="highscore-entries">`;
            displayScores.slice(0, MAX_HIGHSCORES).forEach((entry, index) => {
                const isCurrent = currentScore !== null && entry.score === currentScore && entry.name === playerName;
                html += `
                    <div class="highscore-entry ${isCurrent ? 'current' : ''}">
                        <span class="highscore-rank">${index + 1}.</span>
                        <span class="highscore-name">${entry.name}</span>
                        <span class="highscore-score">${entry.score}</span>
                    </div>
                `;
            });
            html += `</div></div>`;
            container.innerHTML = html;
        }

        function setHighscoreView(mode, containerId) {
            highscoreViewMode = mode;
            renderHighscores(containerId);
        }

        // Player
        const player = {
            x: canvas.width / 2 - 25,
            y: canvas.height - 70,
            width: 50,
            height: 40,
            speed: 7,
            color: '#0ff'
        };

        // Two-player mode
        let twoPlayerMode = false;
        let player2Lives = 3;
        let player2Active = false;
        const player2 = {
            x: canvas.width / 2 + 25,
            y: canvas.height - 70,
            width: 50,
            height: 40,
            speed: 7,
            color: '#f0f'
        };

        // Game objects
        let bullets = [];
        let enemyBullets = [];
        let enemies = [];
        let particles = [];
        let stars = [];

        // Controls
        const keys = {
            left: false,
            right: false,
            up: false,
            down: false,
            space: false
        };
        let canShoot = true;

        // Player 2 Controls (WASD + Q)
        const keys2 = {
            left: false,
            right: false,
            up: false,
            down: false,
            shoot: false
        };
        let canShoot2 = true;
        let shootCooldown = 200;

        // Gamepad support
        let gamepadConnected = false;
        let gamepad2Connected = false;
        let lastPausePress = 0;

        function pollGamepads() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];

            // Player 1 gamepad (first connected)
            const gp1 = gamepads[0];
            if (gp1) {
                gamepadConnected = true;
                // Left stick or D-pad
                const deadzone = 0.3;
                keys.left = gp1.axes[0] < -deadzone || gp1.buttons[14]?.pressed;
                keys.right = gp1.axes[0] > deadzone || gp1.buttons[15]?.pressed;
                keys.up = gp1.axes[1] < -deadzone || gp1.buttons[12]?.pressed;
                keys.down = gp1.axes[1] > deadzone || gp1.buttons[13]?.pressed;
                // A/X button or triggers for shooting
                keys.space = gp1.buttons[0]?.pressed || gp1.buttons[7]?.pressed;
                // Start button for pause (with debounce)
                if (gp1.buttons[9]?.pressed && Date.now() - lastPausePress > 300) {
                    lastPausePress = Date.now();
                    togglePause();
                }
            }

            // Player 2 gamepad (second connected)
            const gp2 = gamepads[1];
            if (gp2 && twoPlayerMode) {
                gamepad2Connected = true;
                const deadzone = 0.3;
                keys2.left = gp2.axes[0] < -deadzone || gp2.buttons[14]?.pressed;
                keys2.right = gp2.axes[0] > deadzone || gp2.buttons[15]?.pressed;
                keys2.up = gp2.axes[1] < -deadzone || gp2.buttons[12]?.pressed;
                keys2.down = gp2.axes[1] > deadzone || gp2.buttons[13]?.pressed;
                keys2.shoot = gp2.buttons[0]?.pressed || gp2.buttons[7]?.pressed;
            }
        }

        // Gamepad connection events
        window.addEventListener('gamepadconnected', (e) => {
            showShareToast(` Controller ${e.gamepad.index + 1} connected!`);
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            showShareToast(` Controller ${e.gamepad.index + 1} disconnected`);
            if (e.gamepad.index === 0) gamepadConnected = false;
            if (e.gamepad.index === 1) gamepad2Connected = false;
        });

        // Enemy settings
        let enemyDirection = 1;
        let enemySpeed = 1;
        let enemyDropAmount = 30;
        let enemyShootChance = 0.002;

        // Background elements
        let asteroids = [];
        let nebulaClouds = [];

        // Parallax star layers configuration (optimized)
        const STAR_LAYERS = [
            { count: 40, minSize: 0.5, maxSize: 1, speed: 0.2, color: '#446', twinkle: false },      // Far distant stars
            { count: 30, minSize: 0.8, maxSize: 1.5, speed: 0.5, color: '#668', twinkle: false },    // Mid-far stars
            { count: 20, minSize: 1, maxSize: 2, speed: 1, color: '#88a', twinkle: false },          // Mid stars
            { count: 12, minSize: 1.5, maxSize: 2.5, speed: 1.8, color: '#aac', twinkle: true },     // Mid-close stars
            { count: 8, minSize: 2, maxSize: 3.5, speed: 3, color: '#fff', twinkle: true }           // Close bright stars
        ];

        let starLayers = [];
        let shootingStars = [];

        // ==========================================
        // 3D EFFECTS SYSTEM
        // ==========================================

        // 3D Grid Floor (Mode 7 style)
        const GRID_3D = {
            enabled: true,
            horizonY: 0.65,          // Where horizon starts (% of canvas height)
            lineCount: 20,           // Horizontal lines
            verticalLines: 30,       // Vertical lines
            scrollSpeed: 3,          // Scroll speed
            color: 'rgba(0, 255, 255, 0.15)',
            glowColor: 'rgba(0, 255, 255, 0.4)',
            offset: 0
        };

        function draw3DGrid() {
            if (!GRID_3D.enabled) return;

            const horizonY = canvas.height * GRID_3D.horizonY;
            const bottomY = canvas.height;
            const gridHeight = bottomY - horizonY;

            ctx.save();

            // Draw horizontal lines with perspective
            for (let i = 0; i <= GRID_3D.lineCount; i++) {
                const t = i / GRID_3D.lineCount;
                // Exponential spacing for perspective effect
                const perspectiveT = Math.pow(t, 2.5);
                const y = horizonY + perspectiveT * gridHeight;

                // Lines get more opaque and thicker as they get closer
                const alpha = 0.05 + t * 0.2;
                const lineWidth = 0.5 + t * 1.5;

                ctx.beginPath();
                ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                ctx.lineWidth = lineWidth;
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw vertical lines with perspective (converging to center horizon)
            const centerX = canvas.width / 2;
            const scrollOffset = (GRID_3D.offset % 100) / 100;

            for (let i = -GRID_3D.verticalLines; i <= GRID_3D.verticalLines; i++) {
                const baseOffset = (i + scrollOffset) / GRID_3D.verticalLines;

                // Calculate where line hits bottom of screen
                const bottomX = centerX + baseOffset * canvas.width * 1.5;

                // Skip lines that are off screen
                if (bottomX < -50 || bottomX > canvas.width + 50) continue;

                // Line converges toward center at horizon
                const horizonX = centerX + baseOffset * 50;

                const alpha = 0.1 - Math.abs(baseOffset) * 0.08;
                if (alpha <= 0) continue;

                ctx.beginPath();
                ctx.strokeStyle = `rgba(0, 255, 255, ${Math.max(0.02, alpha)})`;
                ctx.lineWidth = 1;
                ctx.moveTo(horizonX, horizonY);
                ctx.lineTo(bottomX, bottomY);
                ctx.stroke();
            }

            // Horizon glow line
            const gradient = ctx.createLinearGradient(0, horizonY - 5, 0, horizonY + 10);
            gradient.addColorStop(0, 'transparent');
            gradient.addColorStop(0.5, GRID_3D.glowColor);
            gradient.addColorStop(1, 'transparent');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, horizonY - 5, canvas.width, 15);

            ctx.restore();

            // Update scroll offset
            GRID_3D.offset += GRID_3D.scrollSpeed;
        }

        // 3D Warp/Hyperspace effect
        let warpActive = false;
        let warpStars = [];
        let warpIntensity = 0;

        function initWarpEffect() {
            warpStars = [];
            for (let i = 0; i < 150; i++) {
                warpStars.push({
                    x: (Math.random() - 0.5) * 2,
                    y: (Math.random() - 0.5) * 2,
                    z: Math.random() * 1000,
                    speed: 5 + Math.random() * 15
                });
            }
        }

        function triggerWarpEffect(duration = 1500) {
            warpActive = true;
            warpIntensity = 0;

            const startTime = Date.now();
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;

                if (progress < 0.3) {
                    warpIntensity = progress / 0.3;
                } else if (progress < 0.7) {
                    warpIntensity = 1;
                } else {
                    warpIntensity = 1 - (progress - 0.7) / 0.3;
                }

                if (elapsed < duration) {
                    requestAnimationFrame(animate);
                } else {
                    warpActive = false;
                    warpIntensity = 0;
                }
            };
            animate();
        }

        // Level up screen flash effect
        function triggerLevelUpFlash() {
            const flash = document.createElement('div');
            flash.className = 'level-up-flash';
            document.body.appendChild(flash);

            // Remove after animation completes
            setTimeout(() => flash.remove(), 600);
        }

        function drawWarpEffect() {
            if (!warpActive || warpIntensity <= 0) return;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.save();

            warpStars.forEach(star => {
                // Update z position
                star.z -= star.speed * warpIntensity * 2;
                if (star.z <= 1) {
                    star.z = 1000;
                    star.x = (Math.random() - 0.5) * 2;
                    star.y = (Math.random() - 0.5) * 2;
                }

                // Project to 2D
                const scale = 500 / star.z;
                const x = centerX + star.x * scale * canvas.width;
                const y = centerY + star.y * scale * canvas.height;

                // Previous position for trail
                const prevZ = star.z + star.speed * warpIntensity * 2;
                const prevScale = 500 / prevZ;
                const prevX = centerX + star.x * prevScale * canvas.width;
                const prevY = centerY + star.y * prevScale * canvas.height;

                // Draw star trail
                const alpha = Math.min(1, (1000 - star.z) / 500) * warpIntensity;
                const trailLength = Math.min(100, 1000 / star.z) * warpIntensity;

                const gradient = ctx.createLinearGradient(prevX, prevY, x, y);
                gradient.addColorStop(0, `rgba(100, 150, 255, 0)`);
                gradient.addColorStop(1, `rgba(200, 220, 255, ${alpha})`);

                ctx.beginPath();
                ctx.strokeStyle = gradient;
                ctx.lineWidth = Math.max(1, 3 - star.z / 400);
                ctx.moveTo(prevX, prevY);
                ctx.lineTo(x, y);
                ctx.stroke();

                // Bright point at end
                ctx.beginPath();
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.arc(x, y, Math.max(1, 2 - star.z / 500), 0, Math.PI * 2);
                ctx.fill();
            });

            // Central glow
            const glowGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 100);
            glowGradient.addColorStop(0, `rgba(150, 200, 255, ${0.3 * warpIntensity})`);
            glowGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = glowGradient;
            ctx.fillRect(centerX - 100, centerY - 100, 200, 200);

            ctx.restore();
        }

        // 3D Scroll Text (Star Wars style)
        let scrollText3D = {
            active: false,
            text: [],
            offset: 0,
            speed: 1
        };

        function show3DScrollText(lines, duration = 5000) {
            scrollText3D.active = true;
            scrollText3D.text = lines;
            scrollText3D.offset = 0;

            const startTime = Date.now();
            const animate = () => {
                const elapsed = Date.now() - startTime;
                scrollText3D.offset = elapsed * 0.05;

                if (elapsed < duration) {
                    requestAnimationFrame(animate);
                } else {
                    scrollText3D.active = false;
                }
            };
            animate();
        }

        function draw3DScrollText() {
            if (!scrollText3D.active) return;

            const centerX = canvas.width / 2;
            const startY = canvas.height * 0.9;
            const vanishY = canvas.height * 0.2;

            ctx.save();

            scrollText3D.text.forEach((line, index) => {
                const baseY = startY - scrollText3D.offset + index * 40;

                // Skip if above vanish point
                if (baseY < vanishY) return;

                // Calculate perspective
                const progress = (startY - baseY) / (startY - vanishY);
                const scale = 1 - progress * 0.7;
                const y = baseY;

                // Fade out as it approaches horizon
                const alpha = Math.max(0, 1 - progress * 1.2);

                if (alpha <= 0 || scale <= 0.1) return;

                ctx.save();
                ctx.translate(centerX, y);
                ctx.scale(scale, scale * 0.6); // Squash vertically for 3D effect

                ctx.font = `bold 24px 'Orbitron', sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Glow effect
                ctx.shadowColor = 'rgba(255, 200, 50, 0.8)';
                ctx.shadowBlur = 20;
                ctx.fillStyle = `rgba(255, 220, 100, ${alpha})`;
                ctx.fillText(line, 0, 0);

                // Solid text on top
                ctx.shadowBlur = 0;
                ctx.fillStyle = `rgba(255, 255, 200, ${alpha})`;
                ctx.fillText(line, 0, 0);

                ctx.restore();
            });

            ctx.restore();
        }

        // 3D Rotating text announcement
        let rotating3DText = {
            active: false,
            text: '',
            rotation: 0,
            scale: 0,
            alpha: 0
        };

        function show3DRotatingText(text, duration = 2000) {
            rotating3DText.active = true;
            rotating3DText.text = text;
            rotating3DText.rotation = -Math.PI / 2;
            rotating3DText.scale = 0;
            rotating3DText.alpha = 0;

            const startTime = Date.now();
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;

                if (progress < 0.3) {
                    // Zoom in and rotate
                    const t = progress / 0.3;
                    rotating3DText.scale = t * 1.2;
                    rotating3DText.rotation = -Math.PI / 2 + t * Math.PI / 2;
                    rotating3DText.alpha = t;
                } else if (progress < 0.7) {
                    // Hold
                    rotating3DText.scale = 1.2 - (progress - 0.3) * 0.5;
                    rotating3DText.rotation = 0;
                    rotating3DText.alpha = 1;
                } else {
                    // Zoom out
                    const t = (progress - 0.7) / 0.3;
                    rotating3DText.scale = 1 + t * 2;
                    rotating3DText.alpha = 1 - t;
                }

                if (elapsed < duration) {
                    requestAnimationFrame(animate);
                } else {
                    rotating3DText.active = false;
                }
            };
            animate();
        }

        function draw3DRotatingText() {
            if (!rotating3DText.active) return;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(rotating3DText.scale, rotating3DText.scale);

            // Apply 3D rotation (fake with skew)
            const skew = Math.sin(rotating3DText.rotation) * 0.3;
            ctx.transform(1, skew, 0, 1, 0, 0);

            ctx.font = `bold 48px 'Orbitron', sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Multiple layers for 3D depth
            for (let i = 5; i >= 0; i--) {
                const offset = i * 2;
                const layerAlpha = rotating3DText.alpha * (1 - i * 0.15);

                ctx.fillStyle = i === 0
                    ? `rgba(255, 255, 255, ${layerAlpha})`
                    : `rgba(0, 150, 255, ${layerAlpha * 0.3})`;

                ctx.fillText(rotating3DText.text, offset, offset);
            }

            // Glow
            ctx.shadowColor = 'rgba(0, 200, 255, 0.8)';
            ctx.shadowBlur = 30;
            ctx.fillStyle = `rgba(255, 255, 255, ${rotating3DText.alpha})`;
            ctx.fillText(rotating3DText.text, 0, 0);

            ctx.restore();
        }

        // Initialize 3D effects
        initWarpEffect();

        // Initialize multi-layer parallax stars
        function initStars() {
            stars = []; // Keep for compatibility
            starLayers = [];
            shootingStars = [];

            STAR_LAYERS.forEach((layerConfig, layerIndex) => {
                const layer = [];
                for (let i = 0; i < layerConfig.count; i++) {
                    layer.push(createStar(layerConfig, layerIndex));
                }
                starLayers.push(layer);
            });
        }

        function createStar(layerConfig, layerIndex) {
            const colors = ['#fff', '#ffd', '#ddf', '#fdf', '#dff', '#ffd'];
            const useVariedColor = layerIndex >= 3 && Math.random() > 0.7;

            return {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: layerConfig.minSize + Math.random() * (layerConfig.maxSize - layerConfig.minSize),
                baseSize: 0,
                speed: layerConfig.speed * (0.8 + Math.random() * 0.4),
                color: useVariedColor ? colors[Math.floor(Math.random() * colors.length)] : layerConfig.color,
                twinkle: layerConfig.twinkle,
                twinklePhase: Math.random() * Math.PI * 2,
                twinkleSpeed: 0.02 + Math.random() * 0.03,
                pulse: Math.random() > 0.95, // Some stars pulse
                pulsePhase: Math.random() * Math.PI * 2
            };
        }

        function createShootingStar() {
            if (shootingStars.length >= 3) return;
            if (Math.random() > 0.002) return; // Rare occurrence

            shootingStars.push({
                x: Math.random() * canvas.width,
                y: -10,
                length: 50 + Math.random() * 100,
                speed: 8 + Math.random() * 12,
                angle: Math.PI / 4 + (Math.random() - 0.5) * 0.3,
                life: 1,
                decay: 0.015 + Math.random() * 0.01
            });
        }

        // Initialize asteroids
        function initAsteroids() {
            asteroids = [];
            for (let i = 0; i < 5; i++) {
                asteroids.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 15 + 10,
                    speedX: (Math.random() - 0.5) * 0.5,
                    speedY: Math.random() * 0.3 + 0.1,
                    rotation: 0,
                    rotationSpeed: (Math.random() - 0.5) * 0.02,
                    vertices: Math.floor(Math.random() * 4) + 6
                });
            }
        }

        // Initialize nebula clouds
        function initNebula() {
            nebulaClouds = [];
            for (let i = 0; i < 3; i++) {
                nebulaClouds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.5,
                    size: Math.random() * 150 + 100,
                    color: ['#301030', '#103030', '#303010'][i % 3],
                    speed: Math.random() * 0.1 + 0.05,
                    alpha: Math.random() * 0.1 + 0.05
                });
            }
        }

        // Draw nebula clouds (behind everything)
        function drawNebula() {
            nebulaClouds.forEach(cloud => {
                ctx.globalAlpha = cloud.alpha;
                const gradient = ctx.createRadialGradient(
                    cloud.x, cloud.y, 0,
                    cloud.x, cloud.y, cloud.size
                );
                gradient.addColorStop(0, cloud.color);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        // Update nebula
        function updateNebula() {
            nebulaClouds.forEach(cloud => {
                cloud.y += cloud.speed * slowMotionFactor;
                if (cloud.y > canvas.height + cloud.size) {
                    cloud.y = -cloud.size;
                    cloud.x = Math.random() * canvas.width;
                }
            });
        }

        // Draw asteroids
        function drawAsteroids() {
            ctx.fillStyle = '#444';
            asteroids.forEach(asteroid => {
                ctx.save();
                ctx.translate(asteroid.x, asteroid.y);
                ctx.rotate(asteroid.rotation);

                // Draw irregular polygon
                ctx.beginPath();
                for (let i = 0; i < asteroid.vertices; i++) {
                    const angle = (i / asteroid.vertices) * Math.PI * 2;
                    const variance = 0.7 + Math.sin(i * 2) * 0.3;
                    const x = Math.cos(angle) * asteroid.size * variance;
                    const y = Math.sin(angle) * asteroid.size * variance;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();

                // Highlight
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.arc(-asteroid.size * 0.2, -asteroid.size * 0.2, asteroid.size * 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            });
        }

        // Player trail system
        let playerTrail = [];
        const MAX_TRAIL_LENGTH = 10;

        function updatePlayerTrail() {
            // Add current position to trail
            playerTrail.unshift({
                x: player.x + player.width / 2,
                y: player.y + player.height / 2,
                alpha: 1
            });

            // Limit trail length
            if (playerTrail.length > MAX_TRAIL_LENGTH) {
                playerTrail.pop();
            }

            // Fade out trail
            playerTrail.forEach((point, i) => {
                point.alpha = 1 - (i / MAX_TRAIL_LENGTH);
            });
        }

        function drawPlayerTrail() {
            if (playerTrail.length < 2) return;

            const trail = TRAIL_STYLES[selectedTrail] || TRAIL_STYLES.classic;
            ctx.lineCap = 'round';

            for (let i = 1; i < playerTrail.length; i++) {
                const prev = playerTrail[i - 1];
                const curr = playerTrail[i];
                const progress = i / playerTrail.length;
                let color;

                if (trail.rainbow) {
                    // Rainbow: cycle through colors
                    const hue = (Date.now() / 10 + i * 30) % 360;
                    color = `hsla(${hue}, 100%, 50%, ${curr.alpha * 0.6})`;
                } else if (trail.electric) {
                    // Electric: flickering white/blue
                    const flicker = Math.random() > 0.3 ? 1 : 0.5;
                    const r = Math.floor(10 + Math.random() * 100);
                    const g = Math.floor(170 + Math.random() * 85);
                    const b = 255;
                    color = `rgba(${r}, ${g}, ${b}, ${curr.alpha * 0.7 * flicker})`;
                } else if (trail.starfield) {
                    // Galaxy: purple with sparkles
                    const sparkle = Math.random() > 0.9 ? 1 : 0.6;
                    color = `rgba(170, 80, 255, ${curr.alpha * 0.5 * sparkle})`;
                } else {
                    // Standard gradient trail
                    const c1 = trail.color1;
                    const c2 = trail.color2;
                    // Parse hex colors
                    const r1 = parseInt(c1.slice(1,2), 16) * 17;
                    const g1 = parseInt(c1.slice(2,3), 16) * 17;
                    const b1 = parseInt(c1.slice(3,4), 16) * 17;
                    const r2 = parseInt(c2.slice(1,2), 16) * 17;
                    const g2 = parseInt(c2.slice(2,3), 16) * 17;
                    const b2 = parseInt(c2.slice(3,4), 16) * 17;
                    // Interpolate
                    const r = Math.floor(r1 + (r2 - r1) * progress);
                    const g = Math.floor(g1 + (g2 - g1) * progress);
                    const b = Math.floor(b1 + (b2 - b1) * progress);
                    color = `rgba(${r}, ${g}, ${b}, ${curr.alpha * 0.5})`;
                }

                ctx.strokeStyle = color;
                ctx.lineWidth = (MAX_TRAIL_LENGTH - i) * 1.5;

                ctx.beginPath();
                ctx.moveTo(prev.x, prev.y);
                ctx.lineTo(curr.x, curr.y);
                ctx.stroke();

                // Extra effects for special trails
                if (trail.electric && Math.random() > 0.7) {
                    // Draw spark
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(curr.x + (Math.random() - 0.5) * 10, curr.y + (Math.random() - 0.5) * 10, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                if (trail.starfield && Math.random() > 0.8) {
                    // Draw star sparkle
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(curr.x + (Math.random() - 0.5) * 8, curr.y + (Math.random() - 0.5) * 8, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Update asteroids
        function updateAsteroids() {
            asteroids.forEach(asteroid => {
                asteroid.x += asteroid.speedX * slowMotionFactor;
                asteroid.y += asteroid.speedY * slowMotionFactor;
                asteroid.rotation += asteroid.rotationSpeed * slowMotionFactor;

                // Wrap around screen
                if (asteroid.y > canvas.height + asteroid.size) {
                    asteroid.y = -asteroid.size;
                    asteroid.x = Math.random() * canvas.width;
                }
                if (asteroid.x < -asteroid.size) asteroid.x = canvas.width + asteroid.size;
                if (asteroid.x > canvas.width + asteroid.size) asteroid.x = -asteroid.size;
            });
        }

        // Initialize enemies
        function initEnemies() {
            enemies = [];
            const rows = Math.min(5, 4 + Math.floor(level / 2));
            const cols = Math.min(10, 8 + Math.floor(level / 3));
            const enemyWidth = 40;
            const enemyHeight = 30;
            const padding = 15;
            const totalWidth = cols * (enemyWidth + padding);
            const startX = Math.max(10, (canvas.width - totalWidth) / 2);

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    // Determine enemy type based on row and level
                    let type;
                    if (row === 0) {
                        // Top row - special enemies at higher levels
                        if (level >= 5 && Math.random() < 0.3) {
                            type = 'tank';
                        } else if (level >= 3 && Math.random() < 0.4) {
                            type = 'bomber';
                        } else {
                            type = 'boss';
                        }
                    } else if (row === 1) {
                        // Second row
                        if (level >= 4 && Math.random() < 0.3) {
                            type = 'zigzag';
                        } else if (level >= 6 && Math.random() < 0.2) {
                            type = 'speeder';
                        } else {
                            type = 'medium';
                        }
                    } else {
                        // Other rows
                        if (level >= 3 && Math.random() < 0.15) {
                            type = 'speeder';
                        } else if (level >= 4 && Math.random() < 0.1) {
                            type = 'zigzag';
                        } else {
                            type = 'basic';
                        }
                    }

                    const typeData = ENEMY_TYPES[type];
                    enemies.push({
                        x: startX + col * (enemyWidth + padding),
                        y: 60 + row * (enemyHeight + padding),
                        width: enemyWidth,
                        height: enemyHeight,
                        type: type,
                        points: typeData.points,
                        health: typeData.health,
                        animFrame: 0,
                        animTimer: 0,
                        zigzagTimer: Math.random() * Math.PI * 2, // Random phase for zigzag
                        speedMultiplier: type === 'speeder' ? 2 : 1
                    });
                }
            }

            enemySpeed = 1 + (level * 0.3);
            enemyShootChance = 0.002 + (level * 0.001);
        }

        // Draw player ship with selected skin
        function drawPlayer() {
            ctx.save();

            // Get current skin colors
            const skin = SHIP_SKINS[selectedSkin] || SHIP_SKINS.classic;
            const colors = skin.colors;

            // Determine body color (handle special effects)
            let bodyColor = colors.body;
            if (colors.rainbow) {
                // Animated rainbow gradient
                const time = Date.now() / 500;
                const gradient = ctx.createLinearGradient(
                    player.x, player.y,
                    player.x + player.width, player.y + player.height
                );
                gradient.addColorStop(0, `hsl(${(time * 60) % 360}, 100%, 50%)`);
                gradient.addColorStop(0.25, `hsl(${(time * 60 + 90) % 360}, 100%, 50%)`);
                gradient.addColorStop(0.5, `hsl(${(time * 60 + 180) % 360}, 100%, 50%)`);
                gradient.addColorStop(0.75, `hsl(${(time * 60 + 270) % 360}, 100%, 50%)`);
                gradient.addColorStop(1, `hsl(${(time * 60 + 360) % 360}, 100%, 50%)`);
                bodyColor = gradient;
            } else if (colors.gradient) {
                const gradient = ctx.createLinearGradient(
                    player.x, player.y,
                    player.x + player.width, player.y + player.height
                );
                gradient.addColorStop(0, '#50f');
                gradient.addColorStop(0.5, '#f0f');
                gradient.addColorStop(1, '#0ff');
                bodyColor = gradient;
            }

            // Apply glow effect for special skins
            if (colors.glow) {
                ctx.shadowColor = colors.glow;
                ctx.shadowBlur = 15;
            } else if (colors.rainbow || colors.gradient) {
                ctx.shadowColor = colors.rainbow ? '#fff' : '#f0f';
                ctx.shadowBlur = 12;
            }

            // Ship body
            // Draw main ship body
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.moveTo(player.x + player.width / 2, player.y);
            ctx.lineTo(player.x + player.width, player.y + player.height);
            ctx.lineTo(player.x + player.width - 10, player.y + player.height - 10);
            ctx.lineTo(player.x + player.width / 2, player.y + player.height - 5);
            ctx.lineTo(player.x + 10, player.y + player.height - 10);
            ctx.lineTo(player.x, player.y + player.height);
            ctx.closePath();
            ctx.fill();

            // Reset shadow for other elements
            ctx.shadowBlur = 0;

            // 3D Lighting: Specular highlight on top of ship
            const highlightGradient = ctx.createLinearGradient(
                player.x, player.y,
                player.x + player.width, player.y + player.height / 2
            );
            highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            highlightGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
            highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = highlightGradient;
            ctx.beginPath();
            ctx.moveTo(player.x + player.width / 2, player.y);
            ctx.lineTo(player.x + player.width * 0.75, player.y + player.height * 0.4);
            ctx.lineTo(player.x + player.width / 2, player.y + player.height * 0.3);
            ctx.lineTo(player.x + player.width * 0.25, player.y + player.height * 0.4);
            ctx.closePath();
            ctx.fill();

            // 3D Rim lighting (edge glow on sides)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(player.x + player.width / 2, player.y);
            ctx.lineTo(player.x + player.width, player.y + player.height);
            ctx.stroke();

            ctx.strokeStyle = 'rgba(100, 200, 255, 0.25)';
            ctx.beginPath();
            ctx.moveTo(player.x + player.width / 2, player.y);
            ctx.lineTo(player.x, player.y + player.height);
            ctx.stroke();

            // Metallic panel lines
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(player.x + player.width / 2, player.y + 8);
            ctx.lineTo(player.x + player.width * 0.7, player.y + player.height * 0.6);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(player.x + player.width / 2, player.y + 8);
            ctx.lineTo(player.x + player.width * 0.3, player.y + player.height * 0.6);
            ctx.stroke();

            // Cockpit with 3D glass effect
            const cockpitGradient = ctx.createRadialGradient(
                player.x + player.width / 2 - 2, player.y + 13, 1,
                player.x + player.width / 2, player.y + 15, 6
            );
            cockpitGradient.addColorStop(0, '#fff');
            cockpitGradient.addColorStop(0.3, colors.cockpit);
            cockpitGradient.addColorStop(1, 'rgba(0, 50, 100, 0.8)');

            ctx.fillStyle = cockpitGradient;
            ctx.beginPath();
            ctx.arc(player.x + player.width / 2, player.y + 15, 6, 0, Math.PI * 2);
            ctx.fill();

            // Cockpit reflection
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(player.x + player.width / 2 - 2, player.y + 13, 2, 0, Math.PI * 2);
            ctx.fill();

            // Engine glow with animated flicker and 3D depth (logo-style dramatic flames)
            const flicker = 0.8 + Math.sin(Date.now() / 50) * 0.2;
            const flameHeight = 25 + Math.sin(Date.now() / 30) * 5;

            // Outer orange flame (like in logo)
            ctx.globalAlpha = flicker * 0.8;
            const outerFlameGradient = ctx.createLinearGradient(
                player.x + player.width / 2, player.y + player.height,
                player.x + player.width / 2, player.y + player.height + flameHeight + 10
            );
            outerFlameGradient.addColorStop(0, '#ff6600');
            outerFlameGradient.addColorStop(0.4, '#ff9900');
            outerFlameGradient.addColorStop(0.7, '#ffcc00');
            outerFlameGradient.addColorStop(1, 'rgba(255, 255, 0, 0)');

            ctx.fillStyle = outerFlameGradient;
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.moveTo(player.x + 8, player.y + player.height);
            ctx.lineTo(player.x + player.width / 2, player.y + player.height + flameHeight + Math.sin(Date.now() / 25) * 3);
            ctx.lineTo(player.x + player.width - 8, player.y + player.height);
            ctx.closePath();
            ctx.fill();

            // Middle yellow flame
            ctx.globalAlpha = flicker;
            const midFlameGradient = ctx.createLinearGradient(
                player.x + player.width / 2, player.y + player.height,
                player.x + player.width / 2, player.y + player.height + flameHeight
            );
            midFlameGradient.addColorStop(0, '#ffcc00');
            midFlameGradient.addColorStop(0.5, '#ffff00');
            midFlameGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = midFlameGradient;
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(player.x + 15, player.y + player.height);
            ctx.lineTo(player.x + player.width / 2, player.y + player.height + flameHeight * 0.8 + Math.sin(Date.now() / 20) * 2);
            ctx.lineTo(player.x + player.width - 15, player.y + player.height);
            ctx.closePath();
            ctx.fill();

            // Inner white-hot core
            ctx.globalAlpha = flicker * 0.9;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(player.x + 20, player.y + player.height);
            ctx.lineTo(player.x + player.width / 2, player.y + player.height + flameHeight * 0.5 + Math.sin(Date.now() / 15) * 1.5);
            ctx.lineTo(player.x + player.width - 20, player.y + player.height);
            ctx.closePath();
            ctx.fill();

            // Red engine pods (like in logo)
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#f00';
            ctx.fillStyle = '#cc0000';
            ctx.beginPath();
            ctx.arc(player.x + 12, player.y + player.height - 5, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(player.x + player.width - 12, player.y + player.height - 5, 5, 0, Math.PI * 2);
            ctx.fill();

            // "P1" label above ship (only in 2-player mode)
            if (twoPlayerMode) {
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 10px Orbitron, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('P1', player.x + player.width / 2, player.y - 5);
            }

            ctx.globalAlpha = 1;
            ctx.restore();
        }

        // Enemy type definitions - Classic Space Invaders style from logo
        const ENEMY_TYPES = {
            basic: { color: '#0f0', eye: '#fff', points: 10, health: 1, style: 'crab' },      // Green crab alien
            medium: { color: '#f44', eye: '#fff', points: 20, health: 1, style: 'squid' },    // Red squid alien
            boss: { color: '#f0f', eye: '#fff', points: 30, health: 1, style: 'squid' },
            zigzag: { color: '#0ff', eye: '#f00', points: 25, health: 1, style: 'crab' },
            tank: { color: '#888', eye: '#f00', points: 50, health: 3, style: 'tank' },
            speeder: { color: '#f80', eye: '#fff', points: 15, health: 1, style: 'speeder' },
            bomber: { color: '#f00', eye: '#ff0', points: 35, health: 2, style: 'bomber' }
        };

        // Classic pixel-art Space Invaders sprites (8-bit style from logo)
        function drawPixelArt(x, y, pixelSize, pattern, color) {
            ctx.fillStyle = color;
            pattern.forEach((row, rowIndex) => {
                row.forEach((pixel, colIndex) => {
                    if (pixel) {
                        ctx.fillRect(
                            x + colIndex * pixelSize,
                            y + rowIndex * pixelSize,
                            pixelSize,
                            pixelSize
                        );
                    }
                });
            });
        }

        // Classic crab alien pattern (green one from logo) - Frame 1
        const CRAB_ALIEN_1 = [
            [0,0,1,0,0,0,0,0,1,0,0],
            [0,0,0,1,0,0,0,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,0,0],
            [0,1,1,0,1,1,1,0,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1],
            [1,0,1,1,1,1,1,1,1,0,1],
            [1,0,1,0,0,0,0,0,1,0,1],
            [0,0,0,1,1,0,1,1,0,0,0],
        ];

        // Classic crab alien pattern - Frame 2 (legs out)
        const CRAB_ALIEN_2 = [
            [0,0,1,0,0,0,0,0,1,0,0],
            [1,0,0,1,0,0,0,1,0,0,1],
            [1,0,1,1,1,1,1,1,1,0,1],
            [1,1,1,0,1,1,1,0,1,1,1],
            [0,1,1,1,1,1,1,1,1,1,0],
            [0,0,1,1,1,1,1,1,1,0,0],
            [0,0,1,0,0,0,0,0,1,0,0],
            [0,1,0,0,0,0,0,0,0,1,0],
        ];

        // Classic squid/octopus alien pattern (red one from logo) - Frame 1
        const SQUID_ALIEN_1 = [
            [0,0,0,0,1,1,0,0,0,0],
            [0,0,0,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,0,0],
            [0,1,1,0,1,1,0,1,1,0],
            [0,1,1,1,1,1,1,1,1,0],
            [0,0,0,1,0,0,1,0,0,0],
            [0,0,1,0,1,1,0,1,0,0],
            [0,1,0,1,0,0,1,0,1,0],
        ];

        // Classic squid/octopus alien pattern - Frame 2 (tentacles in)
        const SQUID_ALIEN_2 = [
            [0,0,0,0,1,1,0,0,0,0],
            [0,0,0,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,0,0],
            [0,1,1,0,1,1,0,1,1,0],
            [0,1,1,1,1,1,1,1,1,0],
            [0,0,1,1,0,0,1,1,0,0],
            [0,1,1,0,0,0,0,1,1,0],
            [0,0,1,0,0,0,0,1,0,0],
        ];

        // Animation frame selector (switches every 500ms)
        function getAlienFrame() {
            return Math.floor(Date.now() / 500) % 2;
        }

        // Get the right sprite based on animation frame
        function getCrabAlien() {
            return getAlienFrame() === 0 ? CRAB_ALIEN_1 : CRAB_ALIEN_2;
        }

        function getSquidAlien() {
            return getAlienFrame() === 0 ? SQUID_ALIEN_1 : SQUID_ALIEN_2;
        }

        // Keep backwards compatibility
        const CRAB_ALIEN = CRAB_ALIEN_1;
        const SQUID_ALIEN = SQUID_ALIEN_1;

        // 3D Shadow system
        const SHADOW_CONFIG = {
            offsetX: 4,
            offsetY: 6,
            blur: 8,
            color: 'rgba(0, 0, 0, 0.4)',
            enabled: true
        };

        // Draw shadow for any object
        function drawShadow(x, y, width, height, shape = 'rect') {
            if (!SHADOW_CONFIG.enabled) return;

            ctx.save();
            ctx.fillStyle = SHADOW_CONFIG.color;
            ctx.filter = `blur(${SHADOW_CONFIG.blur}px)`;

            const sx = x + SHADOW_CONFIG.offsetX;
            const sy = y + SHADOW_CONFIG.offsetY;

            if (shape === 'circle') {
                ctx.beginPath();
                ctx.ellipse(sx + width / 2, sy + height / 2, width / 2, height / 3, 0, 0, Math.PI * 2);
                ctx.fill();
            } else if (shape === 'ship') {
                ctx.beginPath();
                ctx.moveTo(sx + width / 2, sy);
                ctx.lineTo(sx + width, sy + height);
                ctx.lineTo(sx, sy + height);
                ctx.closePath();
                ctx.fill();
            } else {
                ctx.fillRect(sx, sy, width, height);
            }

            ctx.filter = 'none';
            ctx.restore();
        }

        // Draw shadow for player ship
        function drawPlayerShadow() {
            if (!SHADOW_CONFIG.enabled) return;

            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
            ctx.filter = `blur(${SHADOW_CONFIG.blur}px)`;

            const sx = player.x + SHADOW_CONFIG.offsetX;
            const sy = player.y + SHADOW_CONFIG.offsetY + 5;

            ctx.beginPath();
            ctx.moveTo(sx + player.width / 2, sy);
            ctx.lineTo(sx + player.width, sy + player.height);
            ctx.lineTo(sx + player.width - 10, sy + player.height - 10);
            ctx.lineTo(sx + player.width / 2, sy + player.height - 5);
            ctx.lineTo(sx + 10, sy + player.height - 10);
            ctx.lineTo(sx, sy + player.height);
            ctx.closePath();
            ctx.fill();

            ctx.filter = 'none';
            ctx.restore();
        }

        // Draw player 2 ship (distinct purple/magenta design)
        function drawPlayer2() {
            if (!twoPlayerMode || !player2Active) return;

            ctx.save();

            // Purple/magenta color scheme for Player 2
            const bodyColor = '#f0f';
            const cockpitColor = '#fff';
            const engineColor = '#a0f';

            // Glow effect
            ctx.shadowColor = '#f0f';
            ctx.shadowBlur = 12;

            // Ship body
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.moveTo(player2.x + player2.width / 2, player2.y);
            ctx.lineTo(player2.x + player2.width, player2.y + player2.height);
            ctx.lineTo(player2.x + player2.width - 10, player2.y + player2.height - 10);
            ctx.lineTo(player2.x + player2.width / 2, player2.y + player2.height - 5);
            ctx.lineTo(player2.x + 10, player2.y + player2.height - 10);
            ctx.lineTo(player2.x, player2.y + player2.height);
            ctx.closePath();
            ctx.fill();

            ctx.shadowBlur = 0;

            // Cockpit (white dome)
            ctx.fillStyle = cockpitColor;
            ctx.beginPath();
            ctx.ellipse(
                player2.x + player2.width / 2,
                player2.y + player2.height * 0.35,
                8, 6, 0, 0, Math.PI * 2
            );
            ctx.fill();

            // Engine flames (animated)
            const flameHeight = 8 + Math.sin(Date.now() / 50) * 4;
            const gradient = ctx.createLinearGradient(
                player2.x + player2.width / 2,
                player2.y + player2.height,
                player2.x + player2.width / 2,
                player2.y + player2.height + flameHeight
            );
            gradient.addColorStop(0, engineColor);
            gradient.addColorStop(0.5, '#f0f');
            gradient.addColorStop(1, 'rgba(255, 0, 255, 0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(player2.x + player2.width / 2 - 8, player2.y + player2.height - 5);
            ctx.lineTo(player2.x + player2.width / 2, player2.y + player2.height + flameHeight);
            ctx.lineTo(player2.x + player2.width / 2 + 8, player2.y + player2.height - 5);
            ctx.closePath();
            ctx.fill();

            // "P2" label above ship
            ctx.fillStyle = '#f0f';
            ctx.font = 'bold 10px Orbitron, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('P2', player2.x + player2.width / 2, player2.y - 5);

            ctx.restore();
        }

        // Draw shadow for player 2
        function drawPlayer2Shadow() {
            if (!twoPlayerMode || !player2Active || !SHADOW_CONFIG.enabled) return;

            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
            ctx.filter = `blur(${SHADOW_CONFIG.blur}px)`;

            const sx = player2.x + SHADOW_CONFIG.offsetX;
            const sy = player2.y + SHADOW_CONFIG.offsetY + 5;

            ctx.beginPath();
            ctx.moveTo(sx + player2.width / 2, sy);
            ctx.lineTo(sx + player2.width, sy + player2.height);
            ctx.lineTo(sx + player2.width - 10, sy + player2.height - 10);
            ctx.lineTo(sx + player2.width / 2, sy + player2.height - 5);
            ctx.lineTo(sx + 10, sy + player2.height - 10);
            ctx.lineTo(sx, sy + player2.height);
            ctx.closePath();
            ctx.fill();

            ctx.filter = 'none';
            ctx.restore();
        }

        // Draw shadow for enemy
        function drawEnemyShadow(enemy) {
            if (!SHADOW_CONFIG.enabled) return;

            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.filter = `blur(${SHADOW_CONFIG.blur - 2}px)`;

            const sx = enemy.x + SHADOW_CONFIG.offsetX;
            const sy = enemy.y + SHADOW_CONFIG.offsetY;

            if (enemy.type === 'boss') {
                ctx.beginPath();
                ctx.ellipse(sx + enemy.width / 2, sy + enemy.height / 2, enemy.width / 2.5, enemy.height / 4, 0, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.beginPath();
                ctx.ellipse(sx + enemy.width / 2, sy + enemy.height / 2, enemy.width / 2, enemy.height / 3, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.filter = 'none';
            ctx.restore();
        }

        // Draw shadow for boss
        function drawBossShadow(boss) {
            if (!SHADOW_CONFIG.enabled || !boss) return;

            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.filter = `blur(${SHADOW_CONFIG.blur + 4}px)`;

            const sx = boss.x + SHADOW_CONFIG.offsetX * 2;
            const sy = boss.y + SHADOW_CONFIG.offsetY * 2;

            ctx.beginPath();
            ctx.ellipse(sx + boss.width / 2, sy + boss.height / 2, boss.width / 2, boss.height / 3, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.filter = 'none';
            ctx.restore();
        }

        // Draw shadow for bullet
        function drawBulletShadow(bullet, isEnemy = false) {
            if (!SHADOW_CONFIG.enabled) return;

            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
            ctx.filter = `blur(3px)`;

            const sx = bullet.x + 2;
            const sy = bullet.y + 3;

            ctx.beginPath();
            ctx.ellipse(sx, sy, 3, 2, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.filter = 'none';
            ctx.restore();
        }

        // Draw shadow for powerup
        function drawPowerupShadow(powerup) {
            if (!SHADOW_CONFIG.enabled) return;

            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
            ctx.filter = `blur(5px)`;

            const sx = powerup.x + SHADOW_CONFIG.offsetX;
            const sy = powerup.y + SHADOW_CONFIG.offsetY;

            ctx.beginPath();
            ctx.ellipse(sx + 12, sy + 12, 12, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.filter = 'none';
            ctx.restore();
        }

        // Draw enemy with perspective effects
        function drawEnemy(enemy) {
            const typeData = ENEMY_TYPES[enemy.type] || ENEMY_TYPES.basic;
            const mainColor = typeData.color;
            const eyeColor = typeData.eye;

            ctx.save();

            // Calculate perspective scale based on Y position (depth effect)
            // Enemies at top (far) are smaller, enemies at bottom (near) are larger
            const depthFactor = 0.7 + (enemy.y / canvas.height) * 0.5; // Range: 0.7 to 1.2
            const perspectiveScale = Math.min(1.2, Math.max(0.7, depthFactor));

            // Calculate alpha based on depth (far enemies slightly faded)
            const depthAlpha = 0.6 + (enemy.y / canvas.height) * 0.4; // Range: 0.6 to 1.0

            // Add subtle hover animation
            const hoverOffset = Math.sin(Date.now() / 200 + enemy.x * 0.1) * 2;

            // Apply transformations for perspective
            const centerX = enemy.x + enemy.width / 2;
            const centerY = enemy.y + enemy.height / 2 + hoverOffset;

            ctx.translate(centerX, centerY);
            ctx.scale(perspectiveScale, perspectiveScale);
            ctx.translate(-centerX, -centerY);

            ctx.globalAlpha = depthAlpha;

            // Glow for special enemies (enhanced based on depth)
            if (['zigzag', 'tank', 'speeder', 'bomber'].includes(enemy.type)) {
                ctx.shadowColor = mainColor;
                ctx.shadowBlur = 10 * perspectiveScale;
            }

            // Body - use classic pixel-art sprites from logo
            ctx.fillStyle = mainColor;
            const style = typeData.style || 'basic';

            if (style === 'squid' || enemy.type === 'boss' || enemy.type === 'medium') {
                // Classic squid/octopus alien (red style from logo) - ANIMATED
                const sprite = getSquidAlien();
                const pixelSize = Math.max(3, Math.floor(enemy.width / 10));
                const spriteWidth = sprite[0].length * pixelSize;
                const spriteHeight = sprite.length * pixelSize;
                const offsetX = enemy.x + (enemy.width - spriteWidth) / 2;
                const offsetY = enemy.y + (enemy.height - spriteHeight) / 2;

                // Add glow effect
                ctx.shadowColor = mainColor;
                ctx.shadowBlur = 8;
                drawPixelArt(offsetX, offsetY, pixelSize, sprite, mainColor);
                ctx.shadowBlur = 0;

            } else if (style === 'crab' || enemy.type === 'basic' || enemy.type === 'zigzag') {
                // Classic crab alien (green style from logo) - ANIMATED
                const sprite = getCrabAlien();
                const pixelSize = Math.max(3, Math.floor(enemy.width / 11));
                const spriteWidth = sprite[0].length * pixelSize;
                const spriteHeight = sprite.length * pixelSize;
                const offsetX = enemy.x + (enemy.width - spriteWidth) / 2;
                const offsetY = enemy.y + (enemy.height - spriteHeight) / 2;

                // Add glow effect
                ctx.shadowColor = mainColor;
                ctx.shadowBlur = 8;
                drawPixelArt(offsetX, offsetY, pixelSize, sprite, mainColor);
                ctx.shadowBlur = 0;

            } else if (enemy.type === 'zigzag') {
                // Lightning bolt shape
                ctx.beginPath();
                ctx.moveTo(enemy.x + enemy.width * 0.3, enemy.y);
                ctx.lineTo(enemy.x + enemy.width * 0.7, enemy.y);
                ctx.lineTo(enemy.x + enemy.width * 0.4, enemy.y + enemy.height * 0.5);
                ctx.lineTo(enemy.x + enemy.width * 0.8, enemy.y + enemy.height * 0.5);
                ctx.lineTo(enemy.x + enemy.width * 0.3, enemy.y + enemy.height);
                ctx.lineTo(enemy.x + enemy.width * 0.5, enemy.y + enemy.height * 0.5);
                ctx.lineTo(enemy.x + enemy.width * 0.2, enemy.y + enemy.height * 0.5);
                ctx.closePath();
                ctx.fill();
            } else if (enemy.type === 'tank') {
                // Tank - larger, armored look
                ctx.fillRect(enemy.x + 2, enemy.y + 5, enemy.width - 4, enemy.height - 10);
                ctx.fillStyle = '#555';
                ctx.fillRect(enemy.x + 5, enemy.y, enemy.width - 10, 8);
                ctx.fillRect(enemy.x + 5, enemy.y + enemy.height - 8, enemy.width - 10, 8);
                // Health indicator
                if (enemy.health > 1) {
                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(enemy.x + 5, enemy.y - 5, (enemy.width - 10) * (enemy.health / 3), 3);
                }
            } else if (enemy.type === 'speeder') {
                // Sleek, fast looking
                ctx.beginPath();
                ctx.moveTo(enemy.x + enemy.width / 2, enemy.y);
                ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height * 0.7);
                ctx.lineTo(enemy.x + enemy.width / 2, enemy.y + enemy.height);
                ctx.lineTo(enemy.x, enemy.y + enemy.height * 0.7);
                ctx.closePath();
                ctx.fill();
                // Speed trail
                ctx.fillStyle = 'rgba(255, 136, 0, 0.3)';
                ctx.fillRect(enemy.x + 10, enemy.y + enemy.height, enemy.width - 20, 10);
            } else if (enemy.type === 'bomber') {
                // Round bomber with bomb underneath
                ctx.beginPath();
                ctx.arc(enemy.x + enemy.width / 2, enemy.y + enemy.height / 3, enemy.width / 3, 0, Math.PI * 2);
                ctx.fill();
                // Bomb
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(enemy.x + enemy.width / 2, enemy.y + enemy.height * 0.8, 8, 0, Math.PI * 2);
                ctx.fill();
                // Fuse
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(enemy.x + enemy.width / 2, enemy.y + enemy.height * 0.8 - 8);
                ctx.lineTo(enemy.x + enemy.width / 2 + 5, enemy.y + enemy.height * 0.8 - 12);
                ctx.stroke();
            } else {
                // Basic alien
                ctx.fillRect(enemy.x + 3, enemy.y + 3, enemy.width - 6, enemy.height - 6);
            }

            // Eyes (skip for pixel-art aliens which have their own design)
            if (!['basic', 'medium', 'boss', 'zigzag', 'speeder'].includes(enemy.type)) {
                ctx.shadowBlur = 0;
                ctx.fillStyle = eyeColor;
                const eyeY = enemy.y + enemy.height / 2.5;
                ctx.beginPath();
                ctx.arc(enemy.x + enemy.width / 3, eyeY, 3, 0, Math.PI * 2);
                ctx.arc(enemy.x + enemy.width * 2 / 3, eyeY, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        // Draw bullet
        function drawBullet(bullet, isEnemy = false) {
            if (isEnemy) {
                ctx.fillStyle = '#f00';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
                ctx.fill();
            } else {
                const weapon = bullet.weapon ? WEAPONS[bullet.weapon] : WEAPONS.laser;
                ctx.fillStyle = weapon.color;

                if (bullet.weapon === 'missile') {
                    // Missile: larger with trail
                    ctx.beginPath();
                    ctx.moveTo(bullet.x, bullet.y - 10);
                    ctx.lineTo(bullet.x + 4, bullet.y + 10);
                    ctx.lineTo(bullet.x - 4, bullet.y + 10);
                    ctx.closePath();
                    ctx.fill();
                    // Flame trail
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.moveTo(bullet.x - 3, bullet.y + 10);
                    ctx.lineTo(bullet.x, bullet.y + 18);
                    ctx.lineTo(bullet.x + 3, bullet.y + 10);
                    ctx.closePath();
                    ctx.fill();
                } else if (bullet.weapon === 'plasma') {
                    // Plasma: glowing orb
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Laser: default
                    ctx.fillRect(bullet.x - 2, bullet.y, weapon.width, weapon.height);
                }
            }
        }

        // Draw multi-layer parallax stars with effects
        function drawStars() {
            const time = Date.now();

            // Draw each star layer (back to front)
            starLayers.forEach((layer, layerIndex) => {
                layer.forEach(star => {
                    ctx.save();

                    // Calculate twinkle/pulse effect
                    let alpha = 1;
                    let currentSize = star.size;

                    if (star.twinkle) {
                        alpha = 0.5 + Math.sin(star.twinklePhase) * 0.5;
                    }

                    if (star.pulse) {
                        currentSize = star.size * (0.8 + Math.sin(star.pulsePhase) * 0.4);
                    }

                    // Brighter stars get glow effect
                    if (layerIndex >= 3 && currentSize > 2) {
                        ctx.shadowColor = star.color;
                        ctx.shadowBlur = currentSize * 3;
                    }

                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = star.color;

                    // Draw star shape based on size
                    if (currentSize > 2.5 && layerIndex >= 4) {
                        // Draw a 4-point star for brightest stars
                        drawStarShape(star.x, star.y, currentSize, star.color);
                    } else {
                        // Simple circle for smaller stars
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, currentSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.restore();
                });
            });

            // Draw shooting stars
            shootingStars.forEach(ss => {
                ctx.save();
                ctx.globalAlpha = ss.life;

                // Create gradient for tail
                const tailX = ss.x - Math.cos(ss.angle) * ss.length;
                const tailY = ss.y - Math.sin(ss.angle) * ss.length;

                const gradient = ctx.createLinearGradient(tailX, tailY, ss.x, ss.y);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                gradient.addColorStop(0.7, 'rgba(200, 220, 255, 0.5)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 1)');

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(tailX, tailY);
                ctx.lineTo(ss.x, ss.y);
                ctx.stroke();

                // Bright head
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(ss.x, ss.y, 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            });
        }

        // Draw a 4-point star shape
        function drawStarShape(x, y, size, color) {
            ctx.fillStyle = color;
            ctx.beginPath();

            const spikes = 4;
            const outerRadius = size;
            const innerRadius = size * 0.4;

            for (let i = 0; i < spikes * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i * Math.PI) / spikes - Math.PI / 2;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius;

                if (i === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }

            ctx.closePath();
            ctx.fill();
        }

        // Logo-style sparkle stars (lens flare effect)
        const sparkles = [];
        const SPARKLE_COUNT = 15;

        function initSparkles() {
            sparkles.length = 0;
            for (let i = 0; i < SPARKLE_COUNT; i++) {
                sparkles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: 8 + Math.random() * 20,
                    baseSize: 8 + Math.random() * 20,
                    twinkleSpeed: 0.02 + Math.random() * 0.03,
                    twinklePhase: Math.random() * Math.PI * 2,
                    rotationSpeed: 0.01 + Math.random() * 0.02,
                    rotation: Math.random() * Math.PI,
                    color: ['#fff', '#adf', '#ffd', '#dff'][Math.floor(Math.random() * 4)],
                    speed: 0.2 + Math.random() * 0.3
                });
            }
        }

        function drawSparkle(x, y, size, rotation, color, alpha = 1) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(x, y);
            ctx.rotate(rotation);

            // Outer glow
            ctx.shadowColor = color;
            ctx.shadowBlur = size * 0.8;

            // Main 4-point star rays
            const rayLength = size;
            const rayWidth = size * 0.15;

            ctx.fillStyle = color;

            // Vertical ray
            ctx.beginPath();
            ctx.moveTo(0, -rayLength);
            ctx.lineTo(rayWidth, 0);
            ctx.lineTo(0, rayLength);
            ctx.lineTo(-rayWidth, 0);
            ctx.closePath();
            ctx.fill();

            // Horizontal ray
            ctx.beginPath();
            ctx.moveTo(-rayLength, 0);
            ctx.lineTo(0, rayWidth);
            ctx.lineTo(rayLength, 0);
            ctx.lineTo(0, -rayWidth);
            ctx.closePath();
            ctx.fill();

            // Diagonal rays (smaller)
            ctx.rotate(Math.PI / 4);
            const diagLength = rayLength * 0.5;
            const diagWidth = rayWidth * 0.7;

            ctx.globalAlpha = alpha * 0.6;

            ctx.beginPath();
            ctx.moveTo(0, -diagLength);
            ctx.lineTo(diagWidth, 0);
            ctx.lineTo(0, diagLength);
            ctx.lineTo(-diagWidth, 0);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(-diagLength, 0);
            ctx.lineTo(0, diagWidth);
            ctx.lineTo(diagLength, 0);
            ctx.lineTo(0, -diagWidth);
            ctx.closePath();
            ctx.fill();

            // Bright center
            ctx.globalAlpha = alpha;
            ctx.shadowBlur = size * 0.5;
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);
            ctx.fill();

            // White hot core
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.1, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function updateSparkles() {
            sparkles.forEach(sparkle => {
                // Twinkle animation
                sparkle.twinklePhase += sparkle.twinkleSpeed;
                sparkle.size = sparkle.baseSize * (0.5 + Math.sin(sparkle.twinklePhase) * 0.5);

                // Slow rotation
                sparkle.rotation += sparkle.rotationSpeed;

                // Drift slowly downward
                sparkle.y += sparkle.speed;
                if (sparkle.y > canvas.height + sparkle.size) {
                    sparkle.y = -sparkle.size;
                    sparkle.x = Math.random() * canvas.width;
                }
            });
        }

        function drawSparkles() {
            sparkles.forEach(sparkle => {
                const alpha = 0.3 + Math.sin(sparkle.twinklePhase) * 0.7;
                if (alpha > 0.2) {
                    drawSparkle(sparkle.x, sparkle.y, sparkle.size, sparkle.rotation, sparkle.color, alpha);
                }
            });
        }

        // Initialize sparkles
        initSparkles();

        // Update parallax stars
        function updateStars() {
            const slowFactor = typeof slowMotionFactor !== 'undefined' ? slowMotionFactor : 1;

            // Update each layer
            starLayers.forEach((layer, layerIndex) => {
                const layerConfig = STAR_LAYERS[layerIndex];

                layer.forEach(star => {
                    // Move star down with parallax speed
                    star.y += star.speed * slowFactor;

                    // Update twinkle phase
                    if (star.twinkle) {
                        star.twinklePhase += star.twinkleSpeed;
                    }

                    // Update pulse phase
                    if (star.pulse) {
                        star.pulsePhase += 0.05;
                    }

                    // Reset star when it goes off screen
                    if (star.y > canvas.height + 5) {
                        star.y = -5;
                        star.x = Math.random() * canvas.width;
                        star.twinklePhase = Math.random() * Math.PI * 2;
                    }
                });
            });

            // Create and update shooting stars
            createShootingStar();

            shootingStars.forEach(ss => {
                ss.x += Math.cos(ss.angle) * ss.speed * slowFactor;
                ss.y += Math.sin(ss.angle) * ss.speed * slowFactor;
                ss.life -= ss.decay;
            });

            // Remove dead shooting stars
            shootingStars = shootingStars.filter(ss => ss.life > 0 && ss.y < canvas.height + 50);
        }

        // Create explosion particles (optimized for performance)
        function createExplosion(x, y, color, count = 8) {
            // Stricter particle limit for better performance
            if (particles.length > 80) return;

            // Reduced particle count for better performance
            const actualCount = Math.min(count, 8);

            // Screen shake for larger explosions - juicy feel!
            if (count >= 8) {
                triggerScreenShake(Math.min(count / 2, 8), 150);
            } else if (count >= 5) {
                triggerScreenShake(3, 100);
            }

            // Main debris particles only
            for (let i = 0; i < actualCount; i++) {
                const angle = (Math.PI * 2 / actualCount) * i + Math.random() * 0.3;
                const speed = 2 + Math.random() * 3;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    color: color,
                    size: 2 + Math.random() * 2,
                    type: 'debris',
                    decay: 0.04
                });
            }

            // Only add sparks for larger explosions
            if (count >= 6) {
                for (let i = 0; i < 3; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 3 + Math.random() * 3;
                    particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 0.6,
                        color: '#ff0',
                        size: 1.5,
                        type: 'spark',
                        decay: 0.06
                    });
                }
            }
        }

        // Create power-up collection particles - colorful burst effect
        function createPowerUpParticles(x, y, color) {
            const colors = [color, '#fff', '#ff0', '#0ff', '#f0f'];

            // Ring of particles expanding outward
            for (let i = 0; i < 12; i++) {
                const angle = (Math.PI * 2 / 12) * i;
                const speed = 4 + Math.random() * 2;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: 3 + Math.random() * 2,
                    type: 'powerup',
                    decay: 0.03
                });
            }

            // Sparkle particles rising up
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 30,
                    y: y,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -3 - Math.random() * 3,
                    life: 1,
                    color: '#fff',
                    size: 2,
                    type: 'sparkle',
                    decay: 0.025
                });
            }
        }

        // Confetti celebration for new highscore
        function launchConfetti() {
            const colors = ['#ff0', '#0ff', '#f0f', '#0f0', '#f80', '#08f', '#fff'];
            const confettiCount = 150;
            const container = document.body;

            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti-piece';
                confetti.style.cssText = `
                    position: fixed;
                    width: ${Math.random() * 10 + 5}px;
                    height: ${Math.random() * 10 + 5}px;
                    background: ${colors[Math.floor(Math.random() * colors.length)]};
                    left: ${Math.random() * 100}vw;
                    top: -20px;
                    opacity: 1;
                    pointer-events: none;
                    z-index: 10000;
                    border-radius: ${Math.random() > 0.5 ? '50%' : '0'};
                    transform: rotate(${Math.random() * 360}deg);
                `;

                container.appendChild(confetti);

                // Animate falling
                const duration = Math.random() * 3000 + 2000;
                const endX = (Math.random() - 0.5) * 200;
                const rotation = Math.random() * 720 - 360;

                confetti.animate([
                    { transform: `translateY(0) translateX(0) rotate(0deg)`, opacity: 1 },
                    { transform: `translateY(100vh) translateX(${endX}px) rotate(${rotation}deg)`, opacity: 0.7 }
                ], {
                    duration: duration,
                    easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                }).onfinish = () => confetti.remove();
            }
        }

        // Update and draw particles (optimized)
        function updateParticles() {
            particles = particles.filter(p => p.life > 0);

            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= p.decay || 0.04;
                p.vx *= 0.95;
                p.vy *= 0.95;

                // Add gravity to debris
                if (p.type === 'debris') {
                    p.vy += 0.08;
                }

                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;

                // Simple square particles for performance
                const size = p.size * p.life;
                ctx.fillRect(p.x - size/2, p.y - size/2, size, size);
            });
            ctx.globalAlpha = 1;
        }

        // Update player
        function updatePlayer() {
            // Horizontal movement
            if (keys.left && player.x > 0) {
                player.x -= player.speed;
                checkTutorialAction('move');
            }
            if (keys.right && player.x < canvas.width - player.width) {
                player.x += player.speed;
                checkTutorialAction('move');
            }
            // Vertical movement (limited to bottom half of screen)
            const minY = canvas.height * 0.4; // Can't go above 40% of screen
            const maxY = canvas.height - player.height - 10;
            if (keys.up && player.y > minY) {
                player.y -= player.speed;
                checkTutorialAction('move');
            }
            if (keys.down && player.y < maxY) {
                player.y += player.speed;
                checkTutorialAction('move');
            }
            if (keys.space && canShoot) {
                const weapon = WEAPONS[currentWeapon];
                const bulletBase = {
                    x: player.x + player.width / 2,
                    y: player.y,
                    speed: weapon.speed,
                    angle: 0,
                    weapon: currentWeapon,
                    damage: calculateWeaponDamage(weapon, currentWeapon),
                    penetrating: weapon.penetrating,
                    splash: weapon.splash
                };

                if (activePowerUp === 'spreadShot') {
                    // Spread shot: 3 bullets in a fan pattern
                    bullets.push({ ...bulletBase, angle: 0 });
                    bullets.push({ ...bulletBase, x: bulletBase.x - 10, angle: -0.15 });
                    bullets.push({ ...bulletBase, x: bulletBase.x + 10, angle: 0.15 });
                } else {
                    bullets.push(bulletBase);
                }
                playShootSound();
                dailyChallengeStats.shotsFired++;
                checkTutorialAction('shoot');
                canShoot = false;
                setTimeout(() => canShoot = true, shootCooldown);
            }
        }

        // Update player 2 (2-player mode)
        function updatePlayer2() {
            if (!twoPlayerMode || !player2Active) return;

            // Horizontal movement
            if (keys2.left && player2.x > 0) {
                player2.x -= player2.speed;
            }
            if (keys2.right && player2.x < canvas.width - player2.width) {
                player2.x += player2.speed;
            }
            // Vertical movement (limited to bottom half of screen)
            const minY = canvas.height * 0.4;
            const maxY = canvas.height - player2.height - 10;
            if (keys2.up && player2.y > minY) {
                player2.y -= player2.speed;
            }
            if (keys2.down && player2.y < maxY) {
                player2.y += player2.speed;
            }
            if (keys2.shoot && canShoot2) {
                const weapon = WEAPONS[currentWeapon];
                const bulletBase = {
                    x: player2.x + player2.width / 2,
                    y: player2.y,
                    speed: weapon.speed,
                    angle: 0,
                    weapon: currentWeapon,
                    damage: calculateWeaponDamage(weapon, currentWeapon),
                    penetrating: weapon.penetrating,
                    splash: weapon.splash,
                    fromPlayer2: true
                };
                bullets.push(bulletBase);
                playShootSound();
                canShoot2 = false;
                setTimeout(() => canShoot2 = true, shootCooldown);
            }
        }

        // Update bullets
        function updateBullets() {
            bullets = bullets.filter(b => b.y > 0 && b.x > 0 && b.x < canvas.width);
            bullets.forEach(b => {
                b.y -= b.speed * slowMotionFactor;
                if (b.angle) {
                    b.x += Math.sin(b.angle) * b.speed * slowMotionFactor;
                }
            });

            enemyBullets = enemyBullets.filter(b => b.y < canvas.height && b.y > -50 && b.x > -50 && b.x < canvas.width + 50);
            enemyBullets.forEach(b => {
                // Handle directional bullets (vx/vy)
                if (b.vx !== undefined && b.vy !== undefined) {
                    b.x += b.vx * slowMotionFactor;
                    b.y += b.vy * slowMotionFactor;
                } else {
                    b.y += b.speed * slowMotionFactor;
                }

                // Handle bomb bullets
                if (b.isBomb) {
                    b.timer--;
                    if (b.timer <= 0) {
                        // Explode into more bullets
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            enemyBullets.push({
                                x: b.x,
                                y: b.y,
                                speed: 3,
                                vx: Math.cos(angle) * 3,
                                vy: Math.sin(angle) * 3
                            });
                        }
                        b.y = canvas.height + 100; // Remove this bullet
                        createExplosion(b.x, b.y, '#f80', 10);
                    }
                }
            });
        }

        // Update enemies
        function updateEnemies() {
            // In endless mode, don't use level-based progression
            if (endlessMode) {
                // Just update existing enemies
            } else if (enemies.length === 0 && !currentBoss) {
                level++;
                document.getElementById('levelValue').textContent = level;
                playLevelUpSound();
                announce('levelUp');
                updateSessionStats('level', level);
                // Track for daily challenge
                updateDailyChallengeProgress('level', level);

                // Trigger 3D warp effect for level transition
                triggerWarpEffect(1200);

                // Trigger screen flash effect
                triggerLevelUpFlash();

                // Show 3D rotating level text
                show3DRotatingText(`LEVEL ${level}`, 2000);

                // Roguelike mode: show upgrade selection
                if (roguelikeMode && level > 1) {
                    setTimeout(() => showRoguelikeUpgradeModal(), 500);
                }

                // Don't spawn enemies if it's a boss level - boss will spawn in game loop
                if (!BOSS_LEVELS.includes(level)) {
                    initEnemies();
                }
                return;
            }

            let hitEdge = false;

            enemies.forEach(enemy => {
                // Base horizontal movement
                const speedMult = enemy.speedMultiplier || 1;
                enemy.x += enemySpeed * enemyDirection * slowMotionFactor * speedMult;

                // Special movements based on type
                if (enemy.type === 'zigzag') {
                    // Zigzag movement - sine wave pattern
                    enemy.zigzagTimer = (enemy.zigzagTimer || 0) + 0.1 * slowMotionFactor;
                    enemy.x += Math.sin(enemy.zigzagTimer) * 2 * slowMotionFactor;
                } else if (enemy.type === 'bomber') {
                    // Bomber slowly descends
                    enemy.y += 0.2 * slowMotionFactor;
                }

                if (enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) {
                    hitEdge = true;
                }

                // Enemy shooting (limit to max 10 enemy bullets)
                let shootChance = enemyShootChance;
                if (enemy.type === 'bomber') shootChance *= 2; // Bombers shoot more
                if (enemy.type === 'speeder') shootChance *= 1.5; // Speeders shoot more too

                if (Math.random() < shootChance && enemyBullets.length < 10) {
                    enemyBullets.push({
                        x: enemy.x + enemy.width / 2,
                        y: enemy.y + enemy.height,
                        speed: 4 + level * 0.5
                    });
                    playEnemyShootSound();
                }
            });

            if (hitEdge) {
                enemyDirection *= -1;
                enemies.forEach(enemy => {
                    enemy.y += enemyDropAmount;
                });
            }
        }

        // Check collisions
        function checkCollisions() {
            const bulletsToRemove = new Set();
            const enemiesToRemove = new Set();
            const enemyBulletsToRemove = new Set();

            // Bullets hitting enemies
            bullets.forEach((bullet, bi) => {
                const isPenetrating = bullet.penetrating || false;
                const splashRadius = bullet.splash || 0;
                const damage = bullet.damage || 1;

                enemies.forEach((enemy, ei) => {
                    // Skip if bullet already removed (unless penetrating) or enemy already removed
                    if ((!isPenetrating && bulletsToRemove.has(bi)) || enemiesToRemove.has(ei)) return;

                    if (bullet.x > enemy.x && bullet.x < enemy.x + enemy.width &&
                        bullet.y > enemy.y && bullet.y < enemy.y + enemy.height) {

                        // Handle enemy health (for tanks and bombers)
                        enemy.health = (enemy.health || 1) - damage;

                        const typeData = ENEMY_TYPES[enemy.type] || ENEMY_TYPES.basic;
                        const color = typeData.color;

                        if (enemy.health <= 0) {
                            // Enemy destroyed
                            createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, color, 8);
                            playExplosionSound(enemy.type === 'tank' ? 'boss' : enemy.type);

                            // Add combo bonus
                            const comboPoints = addComboKill(enemy.points * damage);
                            score += comboPoints;
                            document.getElementById('scoreValue').textContent = score;

                            // Screen flash on multi-kills
                            if (comboCount >= 3) {
                                triggerScreenFlash('rgba(255, 200, 0, 0.2)');
                            }
                            if (comboCount >= 5) {
                                triggerScreenFlash('rgba(255, 100, 0, 0.3)');
                            }

                            // Track stats for achievements
                            updateSessionStats('kill');
                            updateSessionStats('combo', comboCount);
                            updateSessionStats('score', score);

                            // Track for daily challenges
                            updateDailyChallengeProgress('kills', 1);
                            updateDailyChallengeProgress('score', score);
                            updateDailyChallengeProgress('combo', comboCount);

                            // Track lifetime stats
                            updateLifetimeStat('totalKills', 1, 'add');
                            updateLifetimeStat('bestCombo', comboCount, 'max');

                            // Earn coins (more for special enemies)
                            addCoins(Math.floor(enemy.points / 2));

                            // Chance to spawn power-up
                            spawnPowerUp(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);

                            enemiesToRemove.add(ei);

                            // Visual feedback: Hit flash on kill
                            createHitFlash(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 50);

                            // FTUE: Auto-complete tutorial on first kill
                            onFirstKill();

                            // BULLET TIME KILL-CAM: Trigger when last enemy in wave is killed
                            if (!endlessMode && !bossRushMode && !currentBoss &&
                                enemies.length - enemiesToRemove.size === 0) {
                                triggerBulletTimeKillCam(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                            }
                        } else {
                            // Enemy hit but not destroyed (tank)
                            createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, '#888', 4);
                            playEnemyHitSound();
                            dailyChallengeStats.shotsHit++;

                            // Visual feedback: Smaller hit flash for non-kill
                            createHitFlash(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 30);
                        }

                        // Only remove bullet if not penetrating
                        if (!isPenetrating) {
                            bulletsToRemove.add(bi);
                        }

                        // Splash damage for missiles
                        if (splashRadius > 0) {
                            const hitX = enemy.x + enemy.width / 2;
                            const hitY = enemy.y + enemy.height / 2;
                            enemies.forEach((nearEnemy, nei) => {
                                if (enemiesToRemove.has(nei)) return;
                                const dist = Math.hypot(nearEnemy.x + nearEnemy.width/2 - hitX, nearEnemy.y + nearEnemy.height/2 - hitY);
                                if (dist < splashRadius) {
                                    createExplosion(nearEnemy.x + nearEnemy.width / 2, nearEnemy.y + nearEnemy.height / 2, '#f80', 6);
                                    const splashPoints = addComboKill(nearEnemy.points);
                                    score += splashPoints;
                                    updateSessionStats('kill');
                                    dailyChallengeStats.killsInTime++;
                                    spawnPowerUp(nearEnemy.x + nearEnemy.width / 2, nearEnemy.y + nearEnemy.height / 2);
                                    enemiesToRemove.add(nei);
                                }
                            });
                            document.getElementById('scoreValue').textContent = score;
                        }
                    }
                });

                // Bullets hitting boss
                if (currentBoss && !bulletsToRemove.has(bi) &&
                    bullet.x > currentBoss.x && bullet.x < currentBoss.x + currentBoss.width &&
                    bullet.y > currentBoss.y && bullet.y < currentBoss.y + currentBoss.height) {
                    damageBoss(damage);
                    if (!isPenetrating) {
                        bulletsToRemove.add(bi);
                    }
                    createExplosion(bullet.x, bullet.y, '#ff0', 3);
                }
            });

            // Enemy bullets hitting player 1
            enemyBullets.forEach((bullet, bi) => {
                if (!enemyBulletsToRemove.has(bi) &&
                    bullet.x > player.x && bullet.x < player.x + player.width &&
                    bullet.y > player.y && bullet.y < player.y + player.height) {

                    // Shield protects player
                    if (activePowerUp === 'shield') {
                        createExplosion(bullet.x, bullet.y, '#0ff', 5);
                        enemyBulletsToRemove.add(bi);
                    } else {
                        createExplosion(player.x + player.width / 2, player.y + player.height / 2, '#0ff', 12);
                        playPlayerHitSound();
                        triggerScreenShake(8, 300);
                        triggerChromaticAberration();
                        triggerScreenFlash('rgba(255, 0, 0, 0.3)');

                        lives--;
                        updateLivesDisplay();
                        enemyBulletsToRemove.add(bi);
                        updateSessionStats('damage');
                        dailyChallengeStats.livesLostThisRound++;

                        if (lives === 1) {
                            announce('lowHealth');
                        }

                        if (lives <= 0) {
                            // In 2-player mode, check if both players are dead
                            if (twoPlayerMode && player2Active) {
                                // P1 is dead but P2 still alive
                            } else if (twoPlayerMode && !player2Active && player2Lives <= 0) {
                                // Both players dead
                                gameOver();
                            } else if (!twoPlayerMode) {
                                gameOver();
                            }
                        }
                    }
                }

                // Enemy bullets hitting player 2
                if (twoPlayerMode && player2Active && !enemyBulletsToRemove.has(bi) &&
                    bullet.x > player2.x && bullet.x < player2.x + player2.width &&
                    bullet.y > player2.y && bullet.y < player2.y + player2.height) {

                    createExplosion(player2.x + player2.width / 2, player2.y + player2.height / 2, '#f0f', 12);
                    playPlayerHitSound();
                    triggerScreenShake(8, 300);
                    triggerChromaticAberration();
                    triggerScreenFlash('rgba(255, 0, 255, 0.3)');

                    player2Lives--;
                    updatePlayer2LivesDisplay();
                    enemyBulletsToRemove.add(bi);

                    if (player2Lives <= 0) {
                        player2Active = false;
                        createExplosion(player2.x + player2.width / 2, player2.y + player2.height / 2, '#f0f', 20);
                        // Check if both players are dead
                        if (lives <= 0) {
                            gameOver();
                        }
                    }
                }
            });

            // Check UFO collisions
            bullets.forEach((bullet, bi) => {
                if (!bulletsToRemove.has(bi) && checkUFOCollision(bullet)) {
                    if (!bullet.penetrating) {
                        bulletsToRemove.add(bi);
                    }
                }
            });

            // Check barrier collisions
            const barrierBulletsToRemove = checkBarrierCollisions(bullets, false);
            const barrierEnemyBulletsToRemove = checkBarrierCollisions(enemyBullets, true);

            // Merge barrier collision results
            barrierBulletsToRemove.forEach(i => bulletsToRemove.add(i));
            barrierEnemyBulletsToRemove.forEach(i => enemyBulletsToRemove.add(i));

            // Remove marked objects (in reverse order to preserve indices)
            bullets = bullets.filter((_, i) => !bulletsToRemove.has(i));
            enemies = enemies.filter((_, i) => !enemiesToRemove.has(i));
            enemyBullets = enemyBullets.filter((_, i) => !enemyBulletsToRemove.has(i));

            // Enemies reaching player
            enemies.forEach(enemy => {
                if (enemy.y + enemy.height >= player.y) {
                    gameOver();
                }
            });
        }

        // Update lives display
        function updateLivesDisplay() {
            const hearts = ''.repeat(lives);
            document.getElementById('livesValue').textContent = hearts || '';
        }

        // Update player 2 lives display
        function updatePlayer2LivesDisplay() {
            const hearts = ''.repeat(player2Lives);
            const element = document.getElementById('lives2Value');
            if (element) {
                element.textContent = hearts || '';
            }
        }

        // Game over
        async function gameOver(isVictory = false) {
            stopMusic();

            // Save ghost recording if enabled
            finishGhostRecording();

            // Play different sound for victory vs game over
            if (isVictory) {
                playVictoryFanfare();
            } else {
                playGameOverSound();
            }

            // End AI demo mode if active
            if (aiDemoMode) {
                aiDemoMode = false;
                document.getElementById('demoOverlay').classList.add('hidden');
            }

            // End Boss Rush mode if active
            if (bossRushMode) {
                bossRushMode = false;
                document.getElementById('bossRushDisplay').classList.add('hidden');
            }

            // End Roguelike mode if active
            if (roguelikeMode) {
                roguelikeMode = false;
                document.getElementById('roguelikeModal').classList.add('hidden');
                currentRoguelikeUpgradeOptions = [];
                gamePaused = false;
            }

            // Hide mobile controls and reset touch state
            resetTouchControls();
            updateMobileControlsVisibility();

            // Final score update for achievements
            updateSessionStats('score', score);

            // Track lifetime stats at game end
            updateLifetimeStat('highScore', score, 'max');
            updateLifetimeStat('highLevel', level, 'max');
            // Only add playtime if gameStartTime was properly set (not 0)
            if (gameStartTime > 0) {
                const playTime = Math.floor((Date.now() - gameStartTime) / 1000);
                // Sanity check: only add if playtime is reasonable (less than 24 hours)
                if (playTime > 0 && playTime < 86400) {
                    updateLifetimeStat('totalPlayTime', playTime, 'add');
                }
            }

            // Check accuracy challenge at game over
            if (dailyChallenge && dailyChallenge.id === 'accuracy' &&
                dailyChallengeStats.shotsFired > 0 && !dailyChallengeCompleted) {
                const accuracy = Math.round((dailyChallengeStats.shotsHit / dailyChallengeStats.shotsFired) * 100);
                if (accuracy >= dailyChallenge.goal) {
                    completeDailyChallenge();
                }
            }

            // Check for new highscore
            const isNew = isHighscore(score);

            // Update UI immediately
            document.getElementById('playerNameDisplay').textContent = playerName;
            document.getElementById('finalScore').textContent = score;

            // Update title based on victory or defeat
            if (isVictory) {
                document.getElementById('gameOverTitle').textContent = ' VICTORY! ';
                document.getElementById('gameOverSubtitle').textContent = 'All bosses have been vanquished!';
            } else {
                document.getElementById('gameOverTitle').textContent = ' GAME OVER ';
                document.getElementById('gameOverSubtitle').textContent = 'The aliens have won this battle...';
            }

            // Calculate and display game stats
            const timePlayed = Math.floor((Date.now() - gameStartTime) / 1000);
            const timeMinutes = Math.floor(timePlayed / 60).toString().padStart(2, '0');
            const timeSeconds = (timePlayed % 60).toString().padStart(2, '0');
            const accuracy = dailyChallengeStats.shotsFired > 0
                ? Math.round((dailyChallengeStats.shotsHit / dailyChallengeStats.shotsFired) * 100)
                : 0;

            document.getElementById('statKills').textContent = sessionStats.totalKills;
            document.getElementById('statAccuracy').textContent = accuracy + '%';
            document.getElementById('statMaxCombo').textContent = sessionStats.maxCombo + 'x';
            document.getElementById('statTime').textContent = `${timeMinutes}:${timeSeconds}`;
            document.getElementById('statPowerups').textContent = sessionStats.powerUpsCollected;
            document.getElementById('statLevel').textContent = level;

            // Show endless mode stats
            if (endlessMode) {
                const elapsed = Math.floor((Date.now() - endlessStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const seconds = (elapsed % 60).toString().padStart(2, '0');
                document.getElementById('survivalTime').textContent = `${minutes}:${seconds}`;
                document.getElementById('finalWave').textContent = endlessWave;
                document.getElementById('endlessSurvival').classList.remove('hidden');
            } else {
                document.getElementById('endlessSurvival').classList.add('hidden');
            }

            if (isNew && score > 0) {
                document.getElementById('newHighscoreMsg').classList.remove('hidden');
                announce('newHighscore');
                // Celebrate with confetti!
                setTimeout(() => launchConfetti(), 300);
            } else if (isVictory) {
                document.getElementById('newHighscoreMsg').classList.add('hidden');
                // Victory doesn't need a specific announce - fanfare is already playing
            } else {
                document.getElementById('newHighscoreMsg').classList.add('hidden');
                announce('gameOver');
            }

            // Save highscore to server
            if (score > 0) {
                await saveHighscore(playerName, score);
            }

            // Check and save achievements
            checkAchievements();
            renderAchievementBadges();

            renderHighscores('gameOverHighscores', score);
            setUIState('gameover');
        }

        // Draw shield effect around player
        function drawShield() {
            if (activePowerUp !== 'shield') return;
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100) * 0.3;
            ctx.beginPath();
            ctx.arc(player.x + player.width / 2, player.y + player.height / 2, player.width / 1.5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        // Main game loop
        let lastChallengeTimeUpdate = 0;
        function gameLoop() {
            // Always keep the loop running, but skip updates when paused
            if (!gameRunning) return;

            if (gamePaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            // Poll gamepads for input
            pollGamepads();

            // Update AI if in demo mode
            updateAI();

            // Track survival time for daily challenge (every second)
            const survivalTime = Math.floor((Date.now() - gameStartTime) / 1000);
            if (survivalTime > lastChallengeTimeUpdate) {
                lastChallengeTimeUpdate = survivalTime;
                updateDailyChallengeProgress('time', survivalTime);
            }

            try {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Apply screen shake
                const shake = applyScreenShake();
                ctx.save();
                ctx.translate(shake.x, shake.y);

                // Update slow motion
                updateSlowMotion();

                // Update dynamic music intensity
                updateMusicIntensity();

                // Update
                updateNebula();
                updateAsteroids();
                updateStars();
                updateSparkles();
                updatePlayer();
                updatePlayer2();
                updatePlayerTrail();

                // Ghost race recording and playback
                recordGhostFrame();
                updateGhostPlayback();
                updateBullets();
                updateEnemies();
                updatePowerUps();
                updateBoss();
                updateUFO();
                updateCombo();
                checkCollisions();
                checkDailyChallenge();
                updateEndlessMode();

                // Check for boss spawn (only when no enemies and no current boss, not in endless mode)
                if (!endlessMode && enemies.length === 0 && !currentBoss && BOSS_LEVELS.includes(level)) {
                    spawnBoss();
                }

                // Draw background layers
                drawNebula();
                drawAsteroids();
                drawStars();
                drawSparkles();

                // Draw 3D grid floor
                draw3DGrid();

                // Draw warp effect (hyperspace)
                drawWarpEffect();

                // Draw shadows first (3D depth effect)
                bullets.forEach(b => drawBulletShadow(b));
                enemyBullets.forEach(b => drawBulletShadow(b, true));
                enemies.forEach(e => drawEnemyShadow(e));
                if (currentBoss) drawBossShadow(currentBoss);
                powerUps.forEach(p => drawPowerupShadow(p));
                drawPlayerShadow();
                drawPlayer2Shadow();

                // Draw actual objects
                bullets.forEach(b => drawBullet(b));
                enemyBullets.forEach(b => drawBullet(b, true));

                enemies.forEach(e => drawEnemy(e));
                drawBoss();
                drawUFO();
                drawBarriers();
                drawPowerUps();
                drawGhost();
                drawPlayerTrail();
                drawPlayer();
                drawPlayer2();
                drawShield();
                updateParticles();

                // Draw 3D text effects (on top of everything)
                draw3DScrollText();
                draw3DRotatingText();

                // Draw bullet time kill-cam effect
                drawBulletTimeEffect();

                // Restore context after shake
                ctx.restore();
            } catch (error) {
                // Game loop error - continue
            }

            requestAnimationFrame(gameLoop);
        }

        // Start game
        async function startGame(isEndless = false, isTwoPlayer = false) {
            // Stop menu music before starting game music
            stopSplashMusic();

            await initAudio();
            initMusic();
            initAmbientSounds();

            // Get player name
            const nameInput = document.getElementById('playerName');
            playerName = nameInput.value.trim() || 'Gamer';

            // Set game mode
            endlessMode = isEndless;
            twoPlayerMode = isTwoPlayer;

            // Reset roguelike if not in roguelike mode
            if (!roguelikeMode) {
                resetRoguelikeUpgrades();
            }

            resetGame();
            setUIState('playing');
            gameStartTime = Date.now();
            announce('gameStart');

            // Initialize ghost race
            startGhostRecording();
            startGhostPlayback();

            // Track lifetime stats
            updateLifetimeStat('gamesPlayed', 1, 'add');

            // Show/hide endless mode UI
            if (endlessMode) {
                document.getElementById('endlessTimer').classList.remove('hidden');
                document.getElementById('endlessWave').classList.remove('hidden');
                document.getElementById('levelValue').parentElement.style.display = 'none';
                endlessStartTime = Date.now();
                endlessWave = 1;
                endlessSpawnTimer = Date.now();
                endlessSpawnInterval = 3000;
            } else {
                document.getElementById('endlessTimer').classList.add('hidden');
                document.getElementById('endlessWave').classList.add('hidden');
                document.getElementById('levelValue').parentElement.style.display = '';
            }

            // Show/hide 2-player UI
            const p2LivesDisplay = document.getElementById('player2Lives');
            if (twoPlayerMode && p2LivesDisplay) {
                p2LivesDisplay.classList.remove('hidden');
            } else if (p2LivesDisplay) {
                p2LivesDisplay.classList.add('hidden');
            }

            // Show mobile controls on touch devices
            updateMobileControlsVisibility();

            requestAnimationFrame(gameLoop);
        }

        // Restart game
        async function restartGame() {
            // Refresh highscores from server
            await fetchHighscores();
            resetGame();
            setUIState('playing');
            initMusic();
            updateMobileControlsVisibility();
            requestAnimationFrame(gameLoop);
        }

        // Back to main menu
        async function backToMenu() {
            // Stop any running game
            stopMusic();

            // Reset modes
            aiDemoMode = false;
            endlessMode = false;
            twoPlayerMode = false;
            bossRushMode = false;

            // Set UI state to menu (this hides game over, shows menu, hides in-game elements)
            setUIState('menu');

            // Refresh highscores
            await fetchHighscores();
            renderHighscores('startHighscores');

            // Update pilot profile with latest stats
            updatePilotProfile();

            // Focus on name input
            const nameInput = document.getElementById('playerName');
            if (nameInput) {
                nameInput.focus();
            }
        }

        // ==========================================
        // GARAGE MODE
        // ==========================================
        let garageTab = 'skins';
        let garageAnimationFrame = null;
        let garageShipRotation = 0;

        function openGarage() {
            playSelectSound();
            showScreenTransition('garage', () => {
                try {
                    setUIState('garage');
                    document.getElementById('garageCoins').textContent = totalCoins;

                    // Update equipped display
                    updateEquippedDisplay();

                    // Render items
                    renderGarageItems();

                    // Start ship animation
                    startGarageAnimation();
                } catch(e) {
                    console.error('Error opening garage:', e);
                }
            });
        }

        function closeGarage() {
            playSelectSound();
            showScreenTransition('menu', () => {
                setUIState('menu');

                // Stop animation
                if (garageAnimationFrame) {
                    cancelAnimationFrame(garageAnimationFrame);
                    garageAnimationFrame = null;
                }
            });
        }

        function switchGarageTab(tab) {
            garageTab = tab;

            // Update tab buttons
            document.querySelectorAll('.garage-tab').forEach(t => t.classList.remove('active'));
            document.getElementById('garage' + tab.charAt(0).toUpperCase() + tab.slice(1) + 'Tab').classList.add('active');

            renderGarageItems();
            playSelectSound();
        }

        function renderGarageItems() {
            const container = document.getElementById('garageItems');
            let html = '';

            if (garageTab === 'skins') {
                Object.keys(SHIP_SKINS).forEach(key => {
                    const skin = SHIP_SKINS[key];
                    const owned = ownedSkins.includes(key);
                    const isSelected = selectedSkin === key;

                    html += `
                        <div class="garage-item ${isSelected ? 'selected' : ''} ${!owned ? 'locked' : ''}"
                             onclick="${owned ? `garageSelectSkin('${key}')` : `garageBuySkin('${key}')`}">
                            <div class="garage-item-icon"></div>
                            <div class="garage-item-name">${skin.name}</div>
                            <div class="garage-item-price ${owned ? 'owned' : ''}">${owned ? (isSelected ? ' EQUIPPED' : 'OWNED') : ' ' + skin.price}</div>
                        </div>
                    `;
                });
            } else if (garageTab === 'trails') {
                Object.keys(TRAIL_STYLES).forEach(key => {
                    const trail = TRAIL_STYLES[key];
                    const owned = ownedTrails.includes(key);
                    const isSelected = selectedTrail === key;

                    html += `
                        <div class="garage-item ${isSelected ? 'selected' : ''} ${!owned ? 'locked' : ''}"
                             onclick="${owned ? `garageSelectTrail('${key}')` : `garageBuyTrail('${key}')`}">
                            <div class="garage-item-icon" style="background: linear-gradient(135deg, ${trail.color1}, ${trail.color2}); width: 40px; height: 40px; border-radius: 50%; margin: 0 auto 10px;"></div>
                            <div class="garage-item-name">${trail.name}</div>
                            <div class="garage-item-price ${owned ? 'owned' : ''}">${owned ? (isSelected ? ' EQUIPPED' : 'OWNED') : ' ' + trail.price}</div>
                        </div>
                    `;
                });
            } else if (garageTab === 'weapons') {
                const weaponIcons = { laser: '', missile: '', plasma: '' };
                Object.keys(WEAPONS).forEach(key => {
                    const weapon = WEAPONS[key];
                    const isSelected = currentWeapon === key;
                    const level = weaponUpgradeLevels[key] || 0;
                    const upgradeData = WEAPON_UPGRADES[key];
                    const maxLevel = upgradeData.upgrades.length;
                    const isMaxed = level >= maxLevel;
                    const nextUpgrade = isMaxed ? null : upgradeData.upgrades[level];
                    const canAfford = nextUpgrade ? totalCoins >= nextUpgrade.price : false;

                    html += `
                        <div class="garage-item ${isSelected ? 'selected' : ''}"
                             onclick="garageSelectWeapon('${key}')">
                            <div class="garage-item-icon">${weaponIcons[key] || ''}</div>
                            <div class="garage-item-name">${weapon.name}</div>
                            <div class="garage-item-price owned">LVL ${level}/${maxLevel}</div>
                            ${isMaxed ?
                                '<div class="garage-upgrade-btn maxed">MAXED</div>' :
                                `<div class="garage-upgrade-btn ${canAfford ? '' : 'disabled'}"
                                     onclick="event.stopPropagation(); garageUpgradeWeapon('${key}')">
                                     ${nextUpgrade.price}
                                </div>`
                            }
                        </div>
                    `;
                });
            } else if (garageTab === 'upgrades') {
                Object.keys(SHOP_ITEMS).forEach(key => {
                    const item = SHOP_ITEMS[key];
                    const owned = ownedUpgrades.includes(key);

                    html += `
                        <div class="garage-item ${owned ? 'selected' : ''}"
                             onclick="${owned ? '' : `garageBuyUpgrade('${key}')`}">
                            <div class="garage-item-icon">${owned ? '' : ''}</div>
                            <div class="garage-item-name">${item.name}</div>
                            <div class="garage-item-price ${owned ? 'owned' : ''}">${owned ? ' OWNED' : ' ' + item.price}</div>
                        </div>
                    `;
                });
            }

            container.innerHTML = html;
        }

        function garageSelectSkin(key) {
            selectedSkin = key;
            saveShopData();
            renderGarageItems();
            updateEquippedDisplay();
            playSelectSound();
        }

        function garageBuySkin(key) {
            const skin = SHIP_SKINS[key];
            if (totalCoins >= skin.price) {
                totalCoins -= skin.price;
                ownedSkins.push(key);
                selectedSkin = key;
                saveShopData();
                document.getElementById('garageCoins').textContent = totalCoins;
                updateCoinsDisplay();
                renderGarageItems();
                updateEquippedDisplay();
                playLevelUpSound();
            }
        }

        function garageSelectTrail(key) {
            selectedTrail = key;
            saveShopData();
            renderGarageItems();
            updateEquippedDisplay();
            playSelectSound();
        }

        function garageBuyTrail(key) {
            const trail = TRAIL_STYLES[key];
            if (totalCoins >= trail.price) {
                totalCoins -= trail.price;
                ownedTrails.push(key);
                selectedTrail = key;
                saveShopData();
                document.getElementById('garageCoins').textContent = totalCoins;
                updateCoinsDisplay();
                renderGarageItems();
                updateEquippedDisplay();
                playLevelUpSound();
            }
        }

        function garageSelectWeapon(key) {
            currentWeapon = key;
            selectWeapon(key);
            renderGarageItems();
            updateEquippedDisplay();
            playSelectSound();
        }

        function garageUpgradeWeapon(key) {
            const upgradeData = WEAPON_UPGRADES[key];
            const currentLevel = weaponUpgradeLevels[key] || 0;

            if (currentLevel >= upgradeData.upgrades.length) return;

            const nextUpgrade = upgradeData.upgrades[currentLevel];
            if (totalCoins < nextUpgrade.price) return;

            totalCoins -= nextUpgrade.price;
            weaponUpgradeLevels[key] = currentLevel + 1;

            saveShopData();
            document.getElementById('garageCoins').textContent = totalCoins;
            updateCoinsDisplay();
            applyWeaponUpgrades();
            renderGarageItems();
            updateEquippedDisplay();
            playLevelUpSound();
            showShareToast(`${upgradeData.name} upgraded to level ${currentLevel + 1}!`);
        }

        function garageBuyUpgrade(key) {
            const item = SHOP_ITEMS[key];
            if (totalCoins >= item.price && !ownedUpgrades.includes(key)) {
                totalCoins -= item.price;
                ownedUpgrades.push(key);
                saveShopData();
                document.getElementById('garageCoins').textContent = totalCoins;
                updateCoinsDisplay();
                renderGarageItems();
                playLevelUpSound();
            }
        }

        function updateEquippedDisplay() {
            const skinData = SHIP_SKINS[selectedSkin];
            const trailData = TRAIL_STYLES[selectedTrail];
            const weaponData = WEAPONS[currentWeapon];

            document.getElementById('equippedSkin').textContent = skinData ? skinData.name : 'Classic';
            document.getElementById('equippedTrail').textContent = trailData ? trailData.name : 'Classic';
            document.getElementById('equippedWeapon').textContent = weaponData ? weaponData.name : 'Laser';
            document.getElementById('garageShipName').textContent = (skinData ? skinData.name : 'Classic').toUpperCase() + ' FIGHTER';

            // Get ship base stats
            const shipStats = skinData?.stats || { speed: 50, damage: 50, fireRate: 50, defense: 50 };

            // Calculate upgrade bonuses
            const speedBonus = hasUpgrade('fasterShip') ? 15 : 0;
            const damageBonus = hasUpgrade('biggerBullets') ? 15 : 0;
            const defenseBonus = hasUpgrade('extraLife') ? 15 : (hasUpgrade('startShield') ? 10 : 0);
            const weaponDamageBonus = (weaponUpgradeLevels[currentWeapon] || 0) * 3;
            const weaponFireRateBonus = (weaponUpgradeLevels[currentWeapon] || 0) * 5;

            // Calculate final stats (capped at 100)
            const finalSpeed = Math.min(100, shipStats.speed + speedBonus);
            const finalDamage = Math.min(100, shipStats.damage + damageBonus + weaponDamageBonus);
            const finalFireRate = Math.min(100, shipStats.fireRate + weaponFireRateBonus);
            const finalDefense = Math.min(100, shipStats.defense + defenseBonus);

            document.getElementById('statSpeed').style.width = finalSpeed + '%';
            document.getElementById('statDamage').style.width = finalDamage + '%';
            document.getElementById('statFireRate').style.width = finalFireRate + '%';
            document.getElementById('statDefense').style.width = finalDefense + '%';
        }

        // Get current ship stats for gameplay
        function getShipStats() {
            const skinData = SHIP_SKINS[selectedSkin];
            const shipStats = skinData?.stats || { speed: 50, damage: 50, fireRate: 50, defense: 50 };

            const speedBonus = hasUpgrade('fasterShip') ? 15 : 0;
            const damageBonus = hasUpgrade('biggerBullets') ? 15 : 0;
            const defenseBonus = hasUpgrade('extraLife') ? 15 : (hasUpgrade('startShield') ? 10 : 0);

            return {
                speed: Math.min(100, shipStats.speed + speedBonus),
                damage: Math.min(100, shipStats.damage + damageBonus),
                fireRate: Math.min(100, shipStats.fireRate),
                defense: Math.min(100, shipStats.defense + defenseBonus)
            };
        }

        function startGarageAnimation() {
            const canvas = document.getElementById('garageCanvas');
            const ctx = canvas.getContext('2d');
            let time = 0;

            // Helper to convert hex to RGB
            function hexToRgb(hex) {
                if (!hex) return { r: 128, g: 128, b: 128 };
                hex = hex.replace('#', '');
                if (hex.length === 3) {
                    hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
                }
                const num = parseInt(hex, 16);
                return {
                    r: (num >> 16) & 255,
                    g: (num >> 8) & 255,
                    b: num & 255
                };
            }

            // Helper to create rgba color with alpha
            function colorWithAlpha(hex, alpha) {
                const rgb = hexToRgb(hex);
                return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
            }

            // Helper to lighten/darken colors
            function shadeColor(color, percent) {
                if (!color) return 'rgb(128, 128, 128)';
                const rgb = hexToRgb(color);
                const r = Math.min(255, Math.max(0, rgb.r + percent));
                const g = Math.min(255, Math.max(0, rgb.g + percent));
                const b = Math.min(255, Math.max(0, rgb.b + percent));
                return `rgb(${r}, ${g}, ${b})`;
            }

            function animate() {
                time += 0.016;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw starfield background with depth
                for (let i = 0; i < 80; i++) {
                    const depth = (i % 3) + 1;
                    const speed = 20 / depth;
                    const x = (i * 73 + time * speed) % canvas.width;
                    const y = (i * 47 + i * 13) % canvas.height;
                    const size = 0.5 + (3 - depth) * 0.5;
                    const alpha = 0.3 + (3 - depth) * 0.2;
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }

                const shipX = canvas.width / 2;
                const shipY = canvas.height / 2 + Math.sin(time * 2) * 8;
                const scale = 4.5;
                const tilt = Math.sin(time * 1.5) * 0.05;

                const skin = SHIP_SKINS[selectedSkin] || SHIP_SKINS.classic;
                const colors = skin.colors;
                const baseColor = colors.body || '#0ff';

                ctx.save();
                ctx.translate(shipX, shipY);
                ctx.rotate(tilt);

                // Shadow under ship
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(5, 45 * scale, 25 * scale, 8 * scale, 0.2, 0, Math.PI * 2);
                ctx.fill();

                // Engine exhaust with particles
                const trail = TRAIL_STYLES[selectedTrail] || TRAIL_STYLES.classic;
                const engineHex = colors.engine || '#f80';
                for (let i = 0; i < 15; i++) {
                    const progress = (time * 3 + i * 0.2) % 1;
                    const y = 25 * scale + progress * 60;
                    const alpha = (1 - progress) * 0.6;
                    const spread = progress * 15;
                    let color;
                    if (trail.rainbow) {
                        const hue = (time * 100 + i * 30) % 360;
                        color = `hsla(${hue}, 100%, 60%, ${alpha})`;
                    } else {
                        color = colorWithAlpha(engineHex, alpha);
                    }
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(-6 * scale + Math.sin(time * 10 + i) * spread, y, 4 - progress * 3, 0, Math.PI * 2);
                    ctx.arc(6 * scale + Math.sin(time * 10 + i + 1) * spread, y, 4 - progress * 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Engine glow
                const engineGlow = ctx.createRadialGradient(0, 28 * scale, 0, 0, 28 * scale, 35 * scale);
                engineGlow.addColorStop(0, colorWithAlpha(engineHex, 1));
                engineGlow.addColorStop(0.3, colorWithAlpha(engineHex, 0.5));
                engineGlow.addColorStop(0.7, colorWithAlpha(engineHex, 0.15));
                engineGlow.addColorStop(1, 'transparent');
                ctx.fillStyle = engineGlow;
                ctx.beginPath();
                ctx.ellipse(0, 30 * scale, 18 * scale, 30 * scale, 0, 0, Math.PI * 2);
                ctx.fill();

                // Thruster housings
                ctx.fillStyle = '#222';
                ctx.fillRect(-8 * scale, 18 * scale, 4 * scale, 12 * scale);
                ctx.fillRect(4 * scale, 18 * scale, 4 * scale, 12 * scale);
                ctx.fillStyle = '#444';
                ctx.fillRect(-7.5 * scale, 19 * scale, 3 * scale, 10 * scale);
                ctx.fillRect(4.5 * scale, 19 * scale, 3 * scale, 10 * scale);

                // Main body with 3D gradient
                const bodyGrad = ctx.createLinearGradient(-15 * scale, 0, 15 * scale, 0);
                bodyGrad.addColorStop(0, shadeColor(baseColor, -40));
                bodyGrad.addColorStop(0.3, shadeColor(baseColor, 20));
                bodyGrad.addColorStop(0.5, shadeColor(baseColor, 40));
                bodyGrad.addColorStop(0.7, shadeColor(baseColor, 10));
                bodyGrad.addColorStop(1, shadeColor(baseColor, -50));

                ctx.fillStyle = bodyGrad;
                ctx.beginPath();
                ctx.moveTo(0, -22 * scale);
                ctx.quadraticCurveTo(-6 * scale, -10 * scale, -14 * scale, 15 * scale);
                ctx.lineTo(-10 * scale, 22 * scale);
                ctx.lineTo(-6 * scale, 18 * scale);
                ctx.lineTo(0, 20 * scale);
                ctx.lineTo(6 * scale, 18 * scale);
                ctx.lineTo(10 * scale, 22 * scale);
                ctx.lineTo(14 * scale, 15 * scale);
                ctx.quadraticCurveTo(6 * scale, -10 * scale, 0, -22 * scale);
                ctx.closePath();
                ctx.fill();

                // Body highlight edge
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Panel lines for detail
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-4 * scale, -15 * scale);
                ctx.lineTo(-8 * scale, 10 * scale);
                ctx.moveTo(4 * scale, -15 * scale);
                ctx.lineTo(8 * scale, 10 * scale);
                ctx.moveTo(-10 * scale, 5 * scale);
                ctx.lineTo(10 * scale, 5 * scale);
                ctx.stroke();

                // Wing accents
                ctx.fillStyle = shadeColor(baseColor, -30);
                ctx.beginPath();
                ctx.moveTo(-10 * scale, 10 * scale);
                ctx.lineTo(-14 * scale, 15 * scale);
                ctx.lineTo(-10 * scale, 18 * scale);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(10 * scale, 10 * scale);
                ctx.lineTo(14 * scale, 15 * scale);
                ctx.lineTo(10 * scale, 18 * scale);
                ctx.closePath();
                ctx.fill();

                // Cockpit with glass effect
                const cockpitColor = colors.cockpit || '#0af';
                const cockpitGrad = ctx.createRadialGradient(-2 * scale, -10 * scale, 0, 0, -5 * scale, 10 * scale);
                cockpitGrad.addColorStop(0, '#fff');
                cockpitGrad.addColorStop(0.3, cockpitColor);
                cockpitGrad.addColorStop(0.7, shadeColor(cockpitColor, -30));
                cockpitGrad.addColorStop(1, shadeColor(cockpitColor, -60));

                ctx.fillStyle = cockpitGrad;
                ctx.beginPath();
                ctx.ellipse(0, -5 * scale, 5 * scale, 10 * scale, 0, 0, Math.PI * 2);
                ctx.fill();

                // Cockpit frame
                ctx.strokeStyle = shadeColor(baseColor, -20);
                ctx.lineWidth = 3;
                ctx.stroke();

                // Cockpit reflection
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.ellipse(-2 * scale, -10 * scale, 2.5 * scale, 4 * scale, -0.4, 0, Math.PI * 2);
                ctx.fill();

                // Front detail/sensor
                ctx.fillStyle = colors.glow || baseColor;
                ctx.shadowColor = colors.glow || baseColor;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(0, -18 * scale, 2 * scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Side lights (animated)
                const pulseAlpha = 0.5 + Math.sin(time * 5) * 0.3;
                const weaponColor = currentWeapon === 'laser' ? '#0ff' : (currentWeapon === 'missile' ? '#f44' : '#a0f');
                ctx.fillStyle = weaponColor;
                ctx.shadowColor = weaponColor;
                ctx.shadowBlur = 15 + Math.sin(time * 5) * 5;
                ctx.globalAlpha = pulseAlpha + 0.5;
                ctx.beginPath();
                ctx.arc(-10 * scale, 3 * scale, 3, 0, Math.PI * 2);
                ctx.arc(10 * scale, 3 * scale, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;

                // Weapon mounts
                ctx.fillStyle = '#333';
                ctx.fillRect(-12 * scale, 0 * scale, 3 * scale, 8 * scale);
                ctx.fillRect(9 * scale, 0 * scale, 3 * scale, 8 * scale);
                ctx.fillStyle = '#555';
                ctx.fillRect(-11.5 * scale, 1 * scale, 2 * scale, 6 * scale);
                ctx.fillRect(9.5 * scale, 1 * scale, 2 * scale, 6 * scale);

                ctx.restore();
                garageAnimationFrame = requestAnimationFrame(animate);
            }

            animate();
        }

        // Ghost Race Mode
        let ghostRaceEnabled = false;
        let ghostRecording = [];
        let ghostPlayback = null;
        let ghostPlaybackIndex = 0;
        let ghostRecordFrame = 0;
        const GHOST_STORAGE_KEY = 'cosmicBlasterzGhost';
        const GHOST_RECORD_INTERVAL = 3; // Record every 3 frames for performance

        function loadGhostData() {
            try {
                const data = localStorage.getItem(GHOST_STORAGE_KEY);
                if (data) {
                    const parsed = JSON.parse(data);
                    return parsed;
                }
            } catch (e) {}
            return null;
        }

        function saveGhostData(recording, finalScore) {
            try {
                const data = {
                    recording: recording,
                    score: finalScore,
                    date: Date.now(),
                    playerName: playerName
                };
                localStorage.setItem(GHOST_STORAGE_KEY, JSON.stringify(data));
            } catch (e) {}
        }

        function startGhostRecording() {
            ghostRecording = [];
            ghostRecordFrame = 0;
        }

        function recordGhostFrame() {
            if (!ghostRaceEnabled) return;

            ghostRecordFrame++;
            if (ghostRecordFrame % GHOST_RECORD_INTERVAL !== 0) return;

            ghostRecording.push({
                x: player.x,
                y: player.y,
                score: score,
                level: level,
                frame: ghostRecordFrame
            });
        }

        function startGhostPlayback() {
            const ghostData = loadGhostData();
            if (ghostData && ghostData.recording) {
                ghostPlayback = ghostData;
                ghostPlaybackIndex = 0;
            } else {
                ghostPlayback = null;
            }
        }

        function updateGhostPlayback() {
            if (!ghostRaceEnabled || !ghostPlayback) return;

            // Find the ghost frame that matches our current recording frame
            while (ghostPlaybackIndex < ghostPlayback.recording.length - 1 &&
                   ghostPlayback.recording[ghostPlaybackIndex + 1].frame <= ghostRecordFrame) {
                ghostPlaybackIndex++;
            }
        }

        function drawGhost() {
            if (!ghostRaceEnabled || !ghostPlayback || ghostPlaybackIndex >= ghostPlayback.recording.length) return;

            const ghostFrame = ghostPlayback.recording[ghostPlaybackIndex];
            if (!ghostFrame) return;

            ctx.save();
            ctx.globalAlpha = 0.4;

            // Draw ghost ship outline
            const gx = ghostFrame.x;
            const gy = ghostFrame.y;

            // Outer glow
            ctx.shadowColor = '#888';
            ctx.shadowBlur = 15;

            // Ghost ship body
            ctx.fillStyle = 'rgba(150, 150, 150, 0.5)';
            ctx.beginPath();
            ctx.moveTo(gx + player.width / 2, gy);
            ctx.lineTo(gx + player.width, gy + player.height);
            ctx.lineTo(gx + player.width * 0.75, gy + player.height * 0.7);
            ctx.lineTo(gx + player.width / 2, gy + player.height * 0.85);
            ctx.lineTo(gx + player.width * 0.25, gy + player.height * 0.7);
            ctx.lineTo(gx, gy + player.height);
            ctx.closePath();
            ctx.fill();

            // "GHOST" label
            ctx.shadowBlur = 0;
            ctx.font = '10px Orbitron';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.textAlign = 'center';
            ctx.fillText('GHOST', gx + player.width / 2, gy - 8);

            // Ghost score comparison
            const scoreDiff = score - ghostFrame.score;
            const diffColor = scoreDiff >= 0 ? '#0f0' : '#f00';
            const diffText = scoreDiff >= 0 ? `+${scoreDiff}` : `${scoreDiff}`;
            ctx.fillStyle = diffColor;
            ctx.font = 'bold 12px Orbitron';
            ctx.fillText(diffText, gx + player.width / 2, gy - 20);

            ctx.restore();
        }

        function finishGhostRecording() {
            if (!ghostRaceEnabled || ghostRecording.length === 0) return;

            // Only save if this is a new best score
            const existingGhost = loadGhostData();
            if (!existingGhost || score > existingGhost.score) {
                saveGhostData(ghostRecording, score);
            }
        }

        function toggleGhostRace() {
            ghostRaceEnabled = !ghostRaceEnabled;
            localStorage.setItem('ghostRaceEnabled', ghostRaceEnabled);
            updateGhostRaceButton();
        }

        function loadGhostRaceSetting() {
            try {
                const setting = localStorage.getItem('ghostRaceEnabled');
                ghostRaceEnabled = setting === 'true';
            } catch (e) {
                ghostRaceEnabled = false;
            }
            updateGhostRaceButton();
        }

        function updateGhostRaceButton() {
            const btn = document.getElementById('ghostRaceBtn');
            if (btn) {
                const ghostData = loadGhostData();
                const hasGhost = ghostData && ghostData.recording;
                if (ghostRaceEnabled && hasGhost) {
                    btn.innerHTML = `<span style="color:#0f0;"> Ghost ON</span><br><small>${ghostData.playerName}: ${ghostData.score}</small>`;
                } else if (hasGhost) {
                    btn.innerHTML = `<span> Ghost OFF</span><br><small>Best: ${ghostData.score}</small>`;
                } else {
                    btn.innerHTML = ' Ghost Race<br><small>No ghost yet</small>';
                }
                btn.classList.toggle('active', ghostRaceEnabled);
            }
        }

        // Initialize ghost race setting
        loadGhostRaceSetting();

        // Roguelike Mode
        let roguelikeMode = false;
        let roguelikeUpgrades = [];

        const ROGUELIKE_UPGRADES = [
            // Common upgrades
            { id: 'speed_boost', name: 'Thruster Boost', icon: '', desc: '+15% movement speed', rarity: 'common', effect: () => { player.speed *= 1.15; } },
            { id: 'damage_up', name: 'Weapon Amp', icon: '', desc: '+20% damage', rarity: 'common', effect: () => { roguelikeDamageBonus += 0.2; } },
            { id: 'fire_rate', name: 'Rapid Fire', icon: '', desc: '+25% fire rate', rarity: 'common', effect: () => { roguelikeFireRateBonus += 0.25; } },
            { id: 'armor', name: 'Hull Plating', icon: '', desc: 'Reduce incoming damage', rarity: 'common', effect: () => { roguelikeArmor += 0.1; } },

            // Rare upgrades
            { id: 'extra_life', name: 'Extra Life', icon: '', desc: '+1 life', rarity: 'rare', effect: () => { lives++; updateLivesDisplay(); } },
            { id: 'magnet', name: 'Power Magnet', icon: '', desc: 'Attract power-ups from further away', rarity: 'rare', effect: () => { roguelikeMagnetRange += 100; } },
            { id: 'double_coins', name: 'Greed Module', icon: '', desc: '2x coins this run', rarity: 'rare', effect: () => { roguelikeCoinMultiplier *= 2; } },
            { id: 'bullet_size', name: 'Big Bullets', icon: '', desc: '+50% bullet size', rarity: 'rare', effect: () => { roguelikeBulletSizeBonus += 0.5; } },

            // Epic upgrades
            { id: 'multi_shot', name: 'Multi-Shot', icon: '', desc: 'Fire 2 extra bullets', rarity: 'epic', effect: () => { roguelikeExtraBullets += 2; } },
            { id: 'homing', name: 'Homing Bullets', icon: '', desc: 'Bullets slightly track enemies', rarity: 'epic', effect: () => { roguelikeHoming = true; } },
            { id: 'regen', name: 'Auto-Repair', icon: '', desc: 'Slowly regenerate health', rarity: 'epic', effect: () => { roguelikeRegen = true; } },
            { id: 'crit', name: 'Critical Hit', icon: '', desc: '20% chance for 3x damage', rarity: 'epic', effect: () => { roguelikeCritChance += 0.2; } },

            // Legendary upgrades
            { id: 'invuln', name: 'Phase Shift', icon: '', desc: '1 second invulnerability after hit', rarity: 'legendary', effect: () => { roguelikeInvulnTime = 60; } },
            { id: 'nuke', name: 'Screen Clear', icon: '', desc: 'Start each level with a free bomb', rarity: 'legendary', effect: () => { roguelikeStartBomb = true; } },
            { id: 'vampiric', name: 'Life Steal', icon: '', desc: '5% chance to heal on kill', rarity: 'legendary', effect: () => { roguelikeVampiric = true; } }
        ];

        // Roguelike upgrade stats
        let roguelikeDamageBonus = 0;
        let roguelikeFireRateBonus = 0;
        let roguelikeArmor = 0;
        let roguelikeMagnetRange = 0;
        let roguelikeCoinMultiplier = 1;
        let roguelikeBulletSizeBonus = 0;
        let roguelikeExtraBullets = 0;
        let roguelikeHoming = false;
        let roguelikeRegen = false;
        let roguelikeCritChance = 0;
        let roguelikeInvulnTime = 0;
        let roguelikeStartBomb = false;
        let roguelikeVampiric = false;
        let roguelikeRegenTimer = 0;

        function resetRoguelikeUpgrades() {
            roguelikeUpgrades = [];
            roguelikeDamageBonus = 0;
            roguelikeFireRateBonus = 0;
            roguelikeArmor = 0;
            roguelikeMagnetRange = 0;
            roguelikeCoinMultiplier = 1;
            roguelikeBulletSizeBonus = 0;
            roguelikeExtraBullets = 0;
            roguelikeHoming = false;
            roguelikeRegen = false;
            roguelikeCritChance = 0;
            roguelikeInvulnTime = 0;
            roguelikeStartBomb = false;
            roguelikeVampiric = false;
            roguelikeRegenTimer = 0;
            currentRoguelikeUpgradeOptions = [];
            player.speed = 7; // Reset to default
        }

        function getRandomUpgrades(count = 3) {
            // Weight by rarity
            const weights = { common: 50, rare: 30, epic: 15, legendary: 5 };
            const weighted = [];

            ROGUELIKE_UPGRADES.forEach(upgrade => {
                // Don't offer upgrades already at max or already chosen (for some)
                if (roguelikeUpgrades.includes(upgrade.id) &&
                    ['homing', 'regen', 'vampiric', 'nuke'].includes(upgrade.id)) {
                    return; // Skip one-time upgrades already chosen
                }
                for (let i = 0; i < weights[upgrade.rarity]; i++) {
                    weighted.push(upgrade);
                }
            });

            // Shuffle and pick
            const shuffled = weighted.sort(() => Math.random() - 0.5);
            const selected = [];
            const usedIds = new Set();

            for (const upgrade of shuffled) {
                if (!usedIds.has(upgrade.id) && selected.length < count) {
                    selected.push(upgrade);
                    usedIds.add(upgrade.id);
                }
            }

            return selected;
        }

        // Current upgrades shown in modal (for keyboard selection)
        let currentRoguelikeUpgradeOptions = [];

        function showRoguelikeUpgradeModal() {
            if (!roguelikeMode) return;

            const modal = document.getElementById('roguelikeModal');
            const container = document.getElementById('upgradeCards');

            const upgrades = getRandomUpgrades(3);

            // Safety check: if no upgrades available, skip modal
            if (upgrades.length === 0) {
                return;
            }

            gamePaused = true;
            currentRoguelikeUpgradeOptions = upgrades; // Store for keyboard access

            container.innerHTML = upgrades.map((upgrade, index) => `
                <div class="upgrade-card upgrade-rarity-${upgrade.rarity}" data-upgrade-id="${upgrade.id}" data-upgrade-index="${index}">
                    <div class="upgrade-key-hint">${index + 1}</div>
                    <div class="upgrade-icon">${upgrade.icon}</div>
                    <div class="upgrade-name">${upgrade.name}</div>
                    <div class="upgrade-desc">${upgrade.desc}</div>
                </div>
            `).join('');

            // Add click event listeners to each card (more reliable than inline onclick)
            container.querySelectorAll('.upgrade-card').forEach(card => {
                card.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const upgradeId = this.getAttribute('data-upgrade-id');
                    if (upgradeId) {
                        selectRoguelikeUpgrade(upgradeId);
                    }
                });
            });

            modal.classList.remove('hidden');

            // Focus the modal for keyboard input
            modal.setAttribute('tabindex', '-1');
            modal.focus();
        }

        function selectRoguelikeUpgrade(upgradeId) {
            const modal = document.getElementById('roguelikeModal');
            if (modal.classList.contains('hidden')) return; // Already closed

            const upgrade = ROGUELIKE_UPGRADES.find(u => u.id === upgradeId);
            if (upgrade) {
                roguelikeUpgrades.push(upgradeId);
                upgrade.effect();
                playPowerUpSound();
            }

            modal.classList.add('hidden');
            currentRoguelikeUpgradeOptions = []; // Clear options
            gamePaused = false;
        }

        // Keyboard handler for roguelike upgrades (1, 2, 3 keys)
        function handleRoguelikeKeyboard(e) {
            const modal = document.getElementById('roguelikeModal');
            if (!modal || modal.classList.contains('hidden')) return false;

            const keyNum = parseInt(e.key);
            if (keyNum >= 1 && keyNum <= 3 && currentRoguelikeUpgradeOptions[keyNum - 1]) {
                e.preventDefault();
                e.stopPropagation();
                selectRoguelikeUpgrade(currentRoguelikeUpgradeOptions[keyNum - 1].id);
                return true;
            }
            return false;
        }

        async function startRoguelike() {
            roguelikeMode = true;
            resetRoguelikeUpgrades();
            await startGame(false, false);
        }

        // AI Demo Mode
        let aiDemoMode = false;
        let aiDecisionTimer = 0;
        let aiTargetX = 0;
        let aiDodgeDirection = 0;

        async function startAIDemo() {
            stopSplashMusic();
            await initAudio();
            initMusic();
            initAmbientSounds();

            playerName = 'AI Bot';
            endlessMode = false;
            twoPlayerMode = false;
            aiDemoMode = true;

            resetGame();
            setUIState('playing');
            document.getElementById('demoOverlay').classList.remove('hidden');
            gameStartTime = Date.now();

            document.getElementById('endlessTimer').classList.add('hidden');
            document.getElementById('endlessWave').classList.add('hidden');
            document.getElementById('levelValue').parentElement.style.display = '';

            updateMobileControlsVisibility();
            announce('gameStart');
            requestAnimationFrame(gameLoop);
        }

        function stopAIDemo() {
            if (!aiDemoMode) return;
            aiDemoMode = false;
            document.getElementById('demoOverlay').classList.add('hidden');
            // Reset keys
            keys.left = false;
            keys.right = false;
            keys.up = false;
            keys.down = false;
            keys.space = false;
        }

        function updateAI() {
            if (!aiDemoMode || !gameRunning || gamePaused) return;

            const now = Date.now();

            // Find nearest threat (enemy bullet)
            let nearestThreat = null;
            let nearestThreatDist = Infinity;
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;

            enemyBullets.forEach(b => {
                // Only consider bullets that are heading towards player area
                if (b.y > player.y - 150 && b.y < player.y + player.height) {
                    const dx = b.x - playerCenterX;
                    const dist = Math.abs(dx);
                    if (dist < nearestThreatDist && dist < 100) {
                        nearestThreatDist = dist;
                        nearestThreat = b;
                    }
                }
            });

            // Find best target (nearest enemy)
            let targetEnemy = null;
            let targetDist = Infinity;
            enemies.forEach(e => {
                const ex = e.x + e.width / 2;
                const dx = Math.abs(ex - playerCenterX);
                if (dx < targetDist) {
                    targetDist = dx;
                    targetEnemy = e;
                }
            });

            // Check for powerups
            let nearestPowerup = null;
            let powerupDist = Infinity;
            powerUps.forEach(p => {
                const px = p.x + p.width / 2;
                const py = p.y + p.height / 2;
                const dist = Math.sqrt(Math.pow(px - playerCenterX, 2) + Math.pow(py - playerCenterY, 2));
                if (dist < powerupDist && p.y > player.y - 200) {
                    powerupDist = dist;
                    nearestPowerup = p;
                }
            });

            // AI Decision making
            let targetX = canvas.width / 2; // Default to center

            // Priority 1: Dodge bullets
            if (nearestThreat && nearestThreatDist < 80) {
                const threatX = nearestThreat.x;
                // Move away from threat
                if (threatX < playerCenterX) {
                    targetX = playerCenterX + 100;
                } else {
                    targetX = playerCenterX - 100;
                }
                aiDodgeDirection = threatX < playerCenterX ? 1 : -1;
            }
            // Priority 2: Collect nearby powerups
            else if (nearestPowerup && powerupDist < 150) {
                targetX = nearestPowerup.x + nearestPowerup.width / 2;
            }
            // Priority 3: Position under enemies to shoot
            else if (targetEnemy) {
                targetX = targetEnemy.x + targetEnemy.width / 2;
                // Add some randomness
                targetX += (Math.random() - 0.5) * 30;
            }
            // Priority 4: Handle boss
            else if (currentBoss) {
                targetX = currentBoss.x + currentBoss.width / 2;
                // Weave side to side while shooting boss
                targetX += Math.sin(now / 500) * 100;
            }

            // Clamp target
            targetX = Math.max(player.width / 2, Math.min(canvas.width - player.width / 2, targetX));
            aiTargetX = targetX;

            // Move towards target
            const moveSpeed = 5;
            const dx = targetX - playerCenterX;

            keys.left = dx < -moveSpeed;
            keys.right = dx > moveSpeed;

            // Vertical movement - stay in lower area, dodge up when needed
            const idealY = canvas.height - 100;
            const dy = idealY - player.y;

            // Move up if bullet is very close
            if (nearestThreat && nearestThreat.y > player.y - 50) {
                keys.up = true;
                keys.down = false;
            } else {
                keys.up = player.y > idealY + 50;
                keys.down = player.y < idealY - 30;
            }

            // Shooting logic - shoot when enemies are roughly above
            const shouldShoot = enemies.some(e => {
                const ex = e.x + e.width / 2;
                return Math.abs(ex - playerCenterX) < 60;
            }) || (currentBoss && Math.abs(currentBoss.x + currentBoss.width / 2 - playerCenterX) < 150);

            keys.space = shouldShoot || enemies.length > 0 || currentBoss;
        }

        // Exit demo mode on any input
        function handleDemoExit(e) {
            if (aiDemoMode && gameRunning) {
                e.preventDefault();
                stopAIDemo();
                showShareToast('You have taken control! Good luck!');
            }
        }

        // ==========================================
        // BOSS RUSH MODE
        // ==========================================
        let bossRushMode = false;
        let bossRushCurrent = 0;
        const bossRushBosses = ['guardian', 'guardian', 'destroyer', 'destroyer', 'mothership'];

        async function startBossRush() {
            stopSplashMusic();
            await initAudio();
            initMusic();
            initAmbientSounds();

            const nameInput = document.getElementById('playerName');
            playerName = nameInput.value.trim() || 'Boss Slayer';
            endlessMode = false;
            twoPlayerMode = false;
            aiDemoMode = false;
            bossRushMode = true;
            bossRushCurrent = 0;

            resetGame();
            setUIState('playing');
            gameStartTime = Date.now();

            // Hide normal wave UI, show boss rush UI
            document.getElementById('endlessTimer').classList.add('hidden');
            document.getElementById('endlessWave').classList.add('hidden');
            document.getElementById('levelValue').parentElement.style.display = 'none';

            // Show boss rush display
            document.getElementById('bossRushDisplay').classList.remove('hidden');
            document.getElementById('bossRushCurrent').textContent = '1';
            document.getElementById('bossRushTotal').textContent = bossRushBosses.length;

            // Don't spawn normal enemies
            enemies = [];

            updateMobileControlsVisibility();
            announce('gameStart');

            // Show dramatic intro
            show3DScrollText([
                ' BOSS RUSH ',
                '',
                'DEFEAT ALL BOSSES',
                'TO WIN!',
                '',
                'GOOD LUCK...'
            ], 3000);

            // Spawn first boss after intro
            setTimeout(() => {
                if (gameRunning && bossRushMode) {
                    spawnBossRushBoss();
                }
            }, 3500);

            requestAnimationFrame(gameLoop);
        }

        function spawnBossRushBoss() {
            if (!bossRushMode || bossRushCurrent >= bossRushBosses.length) return;

            const bossType = bossRushBosses[bossRushCurrent];
            const bossData = BOSS_TYPES[bossType];

            // Scale difficulty based on boss number
            const difficultyMultiplier = 1 + (bossRushCurrent * 0.3);

            currentBoss = {
                x: canvas.width / 2 - bossData.width / 2,
                y: -bossData.height,
                targetY: 50,
                width: bossData.width,
                height: bossData.height,
                health: Math.floor(bossData.baseHealth * difficultyMultiplier),
                maxHealth: Math.floor(bossData.baseHealth * difficultyMultiplier),
                direction: 1,
                speed: 2 + bossRushCurrent * 0.5,
                shootTimer: 0,
                pattern: 0,
                patternTimer: 0,
                type: bossType,
                phase: 1,
                entering: true,
                laserCharging: false,
                laserTimer: 0,
                spawnTimer: 0,
                angle: 0
            };

            document.getElementById('bossHealth').classList.remove('hidden');
            document.getElementById('bossName').textContent = `${bossData.name} #${bossRushCurrent + 1}`;
            updateBossHealthBar();
            announce('bossAppear');

            show3DRotatingText(`BOSS ${bossRushCurrent + 1}/${bossRushBosses.length}`, 2000);
            startBossMusic();
        }

        function onBossRushBossDefeated() {
            bossRushCurrent++;
            document.getElementById('bossRushCurrent').textContent = bossRushCurrent + 1;

            if (bossRushCurrent >= bossRushBosses.length) {
                // Victory!
                bossRushMode = false;
                document.getElementById('bossRushDisplay').classList.add('hidden');

                show3DScrollText([
                    ' VICTORY! ',
                    '',
                    'ALL BOSSES DEFEATED!',
                    '',
                    `FINAL SCORE: ${score}`
                ], 5000);

                // Trigger game over with victory
                setTimeout(() => {
                    if (gameRunning) {
                        gameOver(true); // true = victory
                    }
                }, 5500);
            } else {
                // Spawn next boss after a short break
                show3DScrollText([
                    ' BOSS DEFEATED! ',
                    '',
                    `NEXT: BOSS ${bossRushCurrent + 1}/${bossRushBosses.length}`,
                    '',
                    'PREPARE YOURSELF!'
                ], 2500);

                setTimeout(() => {
                    if (gameRunning && bossRushMode) {
                        spawnBossRushBoss();
                    }
                }, 3000);
            }
        }

        // Reset game state
        function resetGame() {
            score = 0;
            // Apply difficulty and extra life upgrade
            const diff = getDifficulty();
            const baseLives = diff.playerLives;
            lives = hasUpgrade('extraLife') ? baseLives + 1 : baseLives;
            level = 1;
            bullets = [];
            enemyBullets = [];
            particles = [];
            powerUps = [];
            enemyDirection = 1;
            gamePaused = false;

            // Position players based on mode
            if (twoPlayerMode) {
                player.x = canvas.width / 3 - 25;
                player2.x = (canvas.width * 2 / 3) - 25;
                player2.y = canvas.height - 70;
                player2Lives = hasUpgrade('extraLife') ? baseLives + 1 : baseLives;
                player2Active = true;
                player2.speed = hasUpgrade('fasterShip') ? 8.4 : 7;
                // Reset player 2 keys
                keys2.left = false;
                keys2.right = false;
                keys2.up = false;
                keys2.down = false;
                keys2.shoot = false;
                canShoot2 = true;
                updatePlayer2LivesDisplay();
            } else {
                player.x = canvas.width / 2 - 25;
                player2Active = false;
            }

            // Apply ship speed upgrade
            player.speed = hasUpgrade('fasterShip') ? 8.4 : 7;

            // Reset power-ups
            activePowerUp = null;
            powerUpTimer = 0;
            shootCooldown = 200;
            document.getElementById('powerupIndicator').classList.add('hidden');

            // Apply start shield upgrade (after reset)
            if (hasUpgrade('startShield')) {
                activePowerUp = 'shield';
                powerUpTimer = Date.now() + 5000;
                document.getElementById('powerupIndicator').textContent = 'SHIELD ACTIVE';
                document.getElementById('powerupIndicator').style.color = '#0ff';
                document.getElementById('powerupIndicator').classList.remove('hidden');
            }

            // Reset combo
            comboCount = 0;
            comboTimer = 0;
            document.getElementById('comboDisplay').classList.remove('active');

            // Reset player trail
            playerTrail = [];

            // Reset session stats for achievements
            resetSessionStats();

            // Reset daily challenge stats
            resetDailyChallengeStats();

            // Reset weapon
            currentWeapon = 'laser';
            selectWeapon('laser');

            // Reset barriers
            initBarriers();

            // Reset UFO
            ufo = null;
            ufoTimer = Date.now();

            // Reset boss
            currentBoss = null;
            document.getElementById('bossHealth').classList.add('hidden');

            // Reset boss rush state
            bossRushCurrent = 0;
            document.getElementById('bossRushDisplay').classList.add('hidden');

            // Reset UI
            document.getElementById('pauseScreen').classList.add('hidden');
            document.getElementById('pauseBtn').textContent = '';

            document.getElementById('scoreValue').textContent = score;
            document.getElementById('levelValue').textContent = level;
            updateLivesDisplay();

            initEnemies();
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            // Handle roguelike upgrade selection with 1, 2, 3 keys
            if (handleRoguelikeKeyboard(e)) {
                return;
            }

            // Exit demo mode on any key press
            if (aiDemoMode && gameRunning) {
                handleDemoExit(e);
                return;
            }

            // Player 1 controls (Arrow keys + Space)
            if (e.key === 'ArrowLeft') keys.left = true;
            if (e.key === 'ArrowRight') keys.right = true;
            if (e.key === 'ArrowUp') {
                keys.up = true;
                e.preventDefault();
            }
            if (e.key === 'ArrowDown') {
                keys.down = true;
                e.preventDefault();
            }
            if (e.key === ' ') {
                keys.space = true;
                e.preventDefault();
            }

            // Player 2 controls (WASD + Q) - only in 2-player mode, otherwise WASD controls P1
            if (twoPlayerMode) {
                if (e.key === 'a' || e.key === 'A') keys2.left = true;
                if (e.key === 'd' || e.key === 'D') keys2.right = true;
                if (e.key === 'w' || e.key === 'W') {
                    keys2.up = true;
                    e.preventDefault();
                }
                if (e.key === 's' || e.key === 'S') {
                    keys2.down = true;
                    e.preventDefault();
                }
                if (e.key === 'q' || e.key === 'Q') {
                    keys2.shoot = true;
                    e.preventDefault();
                }
            } else {
                // Single player: WASD also controls player 1
                if (e.key === 'a' || e.key === 'A') keys.left = true;
                if (e.key === 'd' || e.key === 'D') keys.right = true;
                if (e.key === 'w' || e.key === 'W') {
                    keys.up = true;
                    e.preventDefault();
                }
                if (e.key === 's' || e.key === 'S') {
                    keys.down = true;
                    e.preventDefault();
                }
            }

            // Pause with P
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
            // Mute with M
            if (e.key === 'm' || e.key === 'M') {
                toggleMute();
            }
            // Weapon selection with 1, 2, 3
            if (e.key === '1') selectWeapon('laser');
            if (e.key === '2') selectWeapon('missile');
            if (e.key === '3') selectWeapon('plasma');
        });

        document.addEventListener('keyup', (e) => {
            // Player 1 controls
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
            if (e.key === 'ArrowUp') keys.up = false;
            if (e.key === 'ArrowDown') keys.down = false;
            if (e.key === ' ') keys.space = false;

            // Player 2 controls
            if (twoPlayerMode) {
                if (e.key === 'a' || e.key === 'A') keys2.left = false;
                if (e.key === 'd' || e.key === 'D') keys2.right = false;
                if (e.key === 'w' || e.key === 'W') keys2.up = false;
                if (e.key === 's' || e.key === 'S') keys2.down = false;
                if (e.key === 'q' || e.key === 'Q') keys2.shoot = false;
            } else {
                // Single player: WASD also controls player 1
                if (e.key === 'a' || e.key === 'A') keys.left = false;
                if (e.key === 'd' || e.key === 'D') keys.right = false;
                if (e.key === 'w' || e.key === 'W') keys.up = false;
                if (e.key === 's' || e.key === 'S') keys.down = false;
            }
        });

        // ==========================================
        // MOBILE TOUCH CONTROLS SYSTEM
        // ==========================================

        // Touch control state
        let isTouchDevice = false;
        let autoFireEnabled = false;
        let joystickActive = false;
        let joystickTouchId = null;
        let fireTouchId = null;

        // Joystick elements
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickStick = document.getElementById('joystickStick');
        const arrowUp = document.getElementById('arrowUp');
        const arrowDown = document.getElementById('arrowDown');
        const arrowLeft = document.getElementById('arrowLeft');
        const arrowRight = document.getElementById('arrowRight');
        const fireBtn = document.getElementById('fireBtn');
        const autoFireBtn = document.getElementById('autoFireBtn');
        const touchHint = document.getElementById('touchHint');

        // Joystick configuration
        const joystickConfig = {
            maxDistance: 45,    // Maximum stick travel distance
            deadzone: 10,       // Dead zone radius
            centerX: 65,        // Center X of joystick
            centerY: 65         // Center Y of joystick
        };

        // Detect touch device - only enable on actual mobile/tablet devices
        function detectTouchDevice() {
            // Strict mobile-only detection: only enable for phones and tablets
            const ua = navigator.userAgent;
            const isMobile = /Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
            const isIPad = /iPad/i.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            const isAndroidTablet = /Android/i.test(ua) && !/Mobile/i.test(ua);

            // Only enable on actual mobile devices, NOT on desktop with touch screens
            if (isMobile || isIPad || isAndroidTablet) {
                isTouchDevice = true;
                document.body.classList.add('touch-device');
                // Show hint briefly on first touch
                setTimeout(() => {
                    if (touchHint) {
                        touchHint.classList.add('visible');
                        setTimeout(() => touchHint.classList.remove('visible'), 4000);
                    }
                }, 1000);
            }
        }
        detectTouchDevice();

        // Haptic feedback helper
        function triggerHaptic(style = 'light') {
            if ('vibrate' in navigator) {
                switch(style) {
                    case 'light': navigator.vibrate(10); break;
                    case 'medium': navigator.vibrate(25); break;
                    case 'heavy': navigator.vibrate(50); break;
                    case 'double': navigator.vibrate([20, 30, 20]); break;
                }
            }
        }

        // Update joystick visual position
        function updateJoystickVisual(offsetX, offsetY) {
            if (!joystickStick) return;

            const x = joystickConfig.centerX + offsetX;
            const y = joystickConfig.centerY + offsetY;

            joystickStick.style.left = x + 'px';
            joystickStick.style.top = y + 'px';
            joystickStick.style.transform = 'translate(-50%, -50%)';
        }

        // Update direction arrow indicators
        function updateArrowIndicators(horizontal, vertical) {
            if (arrowLeft) arrowLeft.classList.toggle('active', horizontal < -0.3);
            if (arrowRight) arrowRight.classList.toggle('active', horizontal > 0.3);
            if (arrowUp) arrowUp.classList.toggle('active', vertical < -0.3);
            if (arrowDown) arrowDown.classList.toggle('active', vertical > 0.3);
        }

        // Reset joystick to center
        function resetJoystick() {
            joystickActive = false;
            joystickTouchId = null;
            keys.left = false;
            keys.right = false;
            keys.up = false;
            keys.down = false;

            if (joystickStick) {
                joystickStick.classList.remove('active');
                joystickStick.style.left = '50%';
                joystickStick.style.top = '50%';
                joystickStick.style.transform = 'translate(-50%, -50%)';
            }

            updateArrowIndicators(0, 0);
        }

        // Process joystick input
        function processJoystickInput(touchX, touchY) {
            if (!joystickContainer) return;

            const rect = joystickContainer.getBoundingClientRect();
            const centerX = rect.left + joystickConfig.centerX;
            const centerY = rect.top + joystickConfig.centerY;

            let deltaX = touchX - centerX;
            let deltaY = touchY - centerY;

            // Calculate distance from center
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            // Clamp to max distance
            if (distance > joystickConfig.maxDistance) {
                const ratio = joystickConfig.maxDistance / distance;
                deltaX *= ratio;
                deltaY *= ratio;
            }

            // Update visual
            updateJoystickVisual(deltaX, deltaY);

            // Calculate normalized values (-1 to 1)
            const normalizedX = deltaX / joystickConfig.maxDistance;
            const normalizedY = deltaY / joystickConfig.maxDistance;

            // Update arrow indicators
            updateArrowIndicators(normalizedX, normalizedY);

            // Apply deadzone and set keys
            if (distance > joystickConfig.deadzone) {
                keys.left = normalizedX < -0.3;
                keys.right = normalizedX > 0.3;
                keys.up = normalizedY < -0.3;
                keys.down = normalizedY > 0.3;
            } else {
                keys.left = false;
                keys.right = false;
                keys.up = false;
                keys.down = false;
            }
        }

        // Joystick touch events
        if (joystickContainer) {
            joystickContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (joystickTouchId === null) {
                    const touch = e.changedTouches[0];
                    joystickTouchId = touch.identifier;
                    joystickActive = true;
                    if (joystickStick) joystickStick.classList.add('active');
                    processJoystickInput(touch.clientX, touch.clientY);
                    triggerHaptic('light');
                }
            }, { passive: false });

            joystickContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (touch.identifier === joystickTouchId) {
                        processJoystickInput(touch.clientX, touch.clientY);
                        break;
                    }
                }
            }, { passive: false });

            joystickContainer.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouchId) {
                        resetJoystick();
                        break;
                    }
                }
            });

            joystickContainer.addEventListener('touchcancel', resetJoystick);
        }

        // Fire button events
        if (fireBtn) {
            fireBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (fireTouchId === null) {
                    fireTouchId = e.changedTouches[0].identifier;
                    keys.space = true;
                    fireBtn.classList.add('active');
                    triggerHaptic('medium');
                }
            }, { passive: false });

            fireBtn.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === fireTouchId) {
                        fireTouchId = null;
                        if (!autoFireEnabled) {
                            keys.space = false;
                        }
                        fireBtn.classList.remove('active');
                        break;
                    }
                }
            });

            fireBtn.addEventListener('touchcancel', () => {
                fireTouchId = null;
                if (!autoFireEnabled) {
                    keys.space = false;
                }
                fireBtn.classList.remove('active');
            });

            // Mouse support for fire button
            fireBtn.addEventListener('mousedown', () => {
                keys.space = true;
                fireBtn.classList.add('active');
            });
            fireBtn.addEventListener('mouseup', () => {
                if (!autoFireEnabled) keys.space = false;
                fireBtn.classList.remove('active');
            });
            fireBtn.addEventListener('mouseleave', () => {
                if (!autoFireEnabled) keys.space = false;
                fireBtn.classList.remove('active');
            });
        }

        // Auto-fire toggle
        if (autoFireBtn) {
            autoFireBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                autoFireEnabled = !autoFireEnabled;
                autoFireBtn.classList.toggle('active', autoFireEnabled);
                keys.space = autoFireEnabled;
                triggerHaptic(autoFireEnabled ? 'double' : 'light');
            }, { passive: false });

            autoFireBtn.addEventListener('click', () => {
                autoFireEnabled = !autoFireEnabled;
                autoFireBtn.classList.toggle('active', autoFireEnabled);
                keys.space = autoFireEnabled;
            });
        }

        // ==========================================
        // CANVAS TOUCH CONTROLS (Alternative control method)
        // ==========================================

        let canvasTouchId = null;
        let lastCanvasTouchX = null;

        canvas.addEventListener('touchstart', (e) => {
            // Only use canvas touch if not touching controls
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;

            // Check if touch is in the middle/upper part of canvas (not where controls are)
            if (touchY < rect.height * 0.7) {
                canvasTouchId = touch.identifier;
                lastCanvasTouchX = touchX;

                // Tap to shoot if not using fire button
                if (fireTouchId === null && !autoFireEnabled) {
                    keys.space = true;
                    setTimeout(() => {
                        if (!autoFireEnabled && fireTouchId === null) {
                            keys.space = false;
                        }
                    }, 100);
                }
            }
        }, { passive: true });

        canvas.addEventListener('touchmove', (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (touch.identifier === canvasTouchId) {
                    const rect = canvas.getBoundingClientRect();
                    const touchX = touch.clientX - rect.left;

                    if (lastCanvasTouchX !== null) {
                        const deltaX = touchX - lastCanvasTouchX;

                        // Swipe threshold
                        if (Math.abs(deltaX) > 5) {
                            keys.left = deltaX < -5;
                            keys.right = deltaX > 5;
                        }
                    }

                    lastCanvasTouchX = touchX;
                    break;
                }
            }
        }, { passive: true });

        canvas.addEventListener('touchend', (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === canvasTouchId) {
                    canvasTouchId = null;
                    lastCanvasTouchX = null;
                    // Don't reset keys here if joystick is active
                    if (!joystickActive) {
                        keys.left = false;
                        keys.right = false;
                    }
                    break;
                }
            }
        });

        // Prevent default touch behaviors on game container
        document.querySelector('.game-container').addEventListener('touchmove', (e) => {
            if (gameRunning) {
                e.preventDefault();
            }
        }, { passive: false });

        // Show/hide mobile controls based on game state
        function updateMobileControlsVisibility() {
            const mobileControls = document.getElementById('mobileControls');
            if (mobileControls && isTouchDevice) {
                // Hide mobile controls during AI demo mode and 2-player co-op mode
                const shouldShow = gameRunning && !gamePaused && !aiDemoMode && !twoPlayerMode;
                mobileControls.style.display = shouldShow ? 'flex' : 'none';
            }
        }

        // Reset touch state when game ends
        function resetTouchControls() {
            resetJoystick();
            fireTouchId = null;
            canvasTouchId = null;
            lastCanvasTouchX = null;
            if (!autoFireEnabled) {
                keys.space = false;
            }
            if (fireBtn) fireBtn.classList.remove('active');
        }

        // Initialize
        initStars();
        initAsteroids();
        initNebula();

        // Animation frame ID for cleanup
        let animationId = null;

        // Draw initial stars on start screen
        function drawStartScreen() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            updateStars();
            drawStars();
            if (!gameRunning) {
                animationId = requestAnimationFrame(drawStartScreen);
            }
        }
        drawStartScreen();

        // Fetch and show highscores on start screen
        async function initHighscores() {
            renderHighscores('startHighscores'); // Show loading state
            await fetchHighscores();
            renderHighscores('startHighscores'); // Show actual highscores
        }
        initHighscores();

        // Allow starting game with Enter key
        document.getElementById('playerName').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                startGame();
            }
        });

        // ==========================================
        // SPLASH SCREEN
        // ==========================================

        // Amiga-style Chiptune Music for Splash Screen
        let splashAudioCtx = null;
        let splashMusicPlaying = false;
        let splashMusicNodes = [];

        function createSplashMusic() {
            if (splashMusicPlaying) return;

            try {
                splashAudioCtx = new (window.AudioContext || window.webkitAudioContext)();

                // Resume if suspended (browser autoplay policy)
                if (splashAudioCtx.state === 'suspended') {
                    splashAudioCtx.resume();
                }

            // Classic Amiga-style arpeggio melody
            const melody = [
                { note: 'C4', duration: 0.2 },
                { note: 'E4', duration: 0.2 },
                { note: 'G4', duration: 0.2 },
                { note: 'C5', duration: 0.4 },
                { note: 'G4', duration: 0.2 },
                { note: 'E4', duration: 0.2 },
                { note: 'C4', duration: 0.2 },
                { note: 'D4', duration: 0.2 },
                { note: 'F4', duration: 0.2 },
                { note: 'A4', duration: 0.2 },
                { note: 'D5', duration: 0.4 },
                { note: 'A4', duration: 0.2 },
                { note: 'F4', duration: 0.2 },
                { note: 'D4', duration: 0.2 },
                { note: 'E4', duration: 0.2 },
                { note: 'G4', duration: 0.2 },
                { note: 'B4', duration: 0.2 },
                { note: 'E5', duration: 0.4 },
                { note: 'B4', duration: 0.2 },
                { note: 'G4', duration: 0.2 },
                { note: 'E4', duration: 0.2 },
                { note: 'G4', duration: 0.3 },
                { note: 'C5', duration: 0.3 },
                { note: 'E5', duration: 0.6 },
            ];

            // Bass line
            const bassLine = [
                { note: 'C2', duration: 0.8 },
                { note: 'C2', duration: 0.4 },
                { note: 'G2', duration: 0.4 },
                { note: 'D2', duration: 0.8 },
                { note: 'D2', duration: 0.4 },
                { note: 'A2', duration: 0.4 },
                { note: 'E2', duration: 0.8 },
                { note: 'E2', duration: 0.4 },
                { note: 'B2', duration: 0.4 },
                { note: 'G2', duration: 0.6 },
                { note: 'C3', duration: 0.6 },
            ];

            const noteFreqs = {
                'C2': 65.41, 'D2': 73.42, 'E2': 82.41, 'F2': 87.31, 'G2': 98.00, 'A2': 110.00, 'B2': 123.47,
                'C3': 130.81, 'D3': 146.83, 'E3': 164.81, 'F3': 174.61, 'G3': 196.00, 'A3': 220.00, 'B3': 246.94,
                'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
                'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46, 'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
            };

            function playNote(freq, startTime, duration, type = 'square', volume = 0.15) {
                const osc = splashAudioCtx.createOscillator();
                const gain = splashAudioCtx.createGain();

                osc.type = type;
                osc.frequency.setValueAtTime(freq, startTime);

                // Envelope
                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(volume, startTime + 0.01);
                gain.gain.setValueAtTime(volume * 0.8, startTime + duration * 0.3);
                gain.gain.linearRampToValueAtTime(0, startTime + duration);

                osc.connect(gain);
                gain.connect(splashAudioCtx.destination);

                osc.start(startTime);
                osc.stop(startTime + duration);

                splashMusicNodes.push({ osc, gain });
            }

            function playMelody(startOffset = 0) {
                if (!splashMusicPlaying) return;

                let time = splashAudioCtx.currentTime + startOffset;
                const loopDuration = melody.reduce((sum, n) => sum + n.duration, 0);

                // Lead melody with arpeggio
                melody.forEach(({ note, duration }) => {
                    playNote(noteFreqs[note], time, duration * 0.9, 'square', 0.12);
                    // Add slight detune for chorus effect
                    playNote(noteFreqs[note] * 1.005, time, duration * 0.9, 'square', 0.06);
                    time += duration;
                });

                // Bass line
                let bassTime = splashAudioCtx.currentTime + startOffset;
                bassLine.forEach(({ note, duration }) => {
                    playNote(noteFreqs[note], bassTime, duration * 0.8, 'triangle', 0.2);
                    bassTime += duration;
                });

                // Schedule next loop
                if (splashMusicPlaying) {
                    setTimeout(() => playMelody(0.1), loopDuration * 1000);
                }
            }

            splashMusicPlaying = true;
            playMelody(0);
            } catch (e) {
                // Splash music failed to start
            }
        }

        function stopSplashMusic() {
            splashMusicPlaying = false;
            splashMusicNodes.forEach(node => {
                try {
                    node.osc.stop();
                    node.gain.disconnect();
                } catch (e) {}
            });
            splashMusicNodes = [];
            if (splashAudioCtx) {
                splashAudioCtx.close();
                splashAudioCtx = null;
            }
        }

        // ==========================================
        // MUSIC CONTROL - Single source of truth
        // ==========================================
        let isMusicEnabled = true;

        function initMusic() {
            // Load saved preference from localStorage
            const saved = localStorage.getItem('musicEnabled');
            if (saved !== null) {
                isMusicEnabled = saved === 'true';
            } else {
                isMusicEnabled = true; // Default to enabled
            }
            updateMusicButton();
        }

        function toggleMusic() {
            isMusicEnabled = !isMusicEnabled;

            // Save preference
            localStorage.setItem('musicEnabled', isMusicEnabled.toString());

            // Update audio state
            if (isMusicEnabled) {
                try {
                    createSplashMusic();
                } catch (e) {
                    // Music failed to start
                }
            } else {
                stopSplashMusic();
            }

            updateMusicButton();
            playSelectSound();
        }

        function updateMusicButton() {
            const btn = document.getElementById('menuMusicBtn');
            if (!btn) return;

            if (isMusicEnabled) {
                // Music is ON - button shows option to turn OFF
                btn.textContent = ' Music Off';
                btn.classList.remove('muted');
            } else {
                // Music is OFF - button shows option to turn ON
                btn.textContent = ' Music On';
                btn.classList.add('muted');
            }
        }

        // Legacy compatibility wrapper
        function toggleMenuMusic() {
            toggleMusic();
        }

        function loadMenuMusicSetting() {
            initMusic();
        }

        // Amiga-style Sine Wave Scroller
        const scrollerCanvas = document.getElementById('scrollerCanvas');
        let scrollerCtx = null;
        let scrollerAnimationId = null;
        let scrollX = 0;
        const scrollText = "     WELCOME TO COSMIC BLASTERZ! ....... THE ULTIMATE RETRO SPACE SHOOTER EXPERIENCE ....... DODGE, SHOOT AND SURVIVE THE ALIEN INVASION ....... COLLECT POWER-UPS AND DEFEAT EPIC BOSSES ....... GREETINGS TO ALL RETRO GAMING FANS OUT THERE! ....... PRESS FIRE TO START YOUR MISSION ....... ";

        function initScrollerCanvas() {
            if (!scrollerCanvas) return;
            const container = scrollerCanvas.parentElement;
            scrollerCanvas.width = container.offsetWidth || window.innerWidth;
            scrollerCanvas.height = container.offsetHeight || 80;
            scrollerCtx = scrollerCanvas.getContext('2d');
        }

        function drawAmigaScroller() {
            if (!scrollerCtx || !scrollerCanvas) return;

            const width = scrollerCanvas.width;
            const height = scrollerCanvas.height;

            // Clear canvas
            scrollerCtx.clearRect(0, 0, width, height);

            // Font settings - clean readable style
            const fontSize = Math.min(28, height * 0.45);
            scrollerCtx.font = `500 ${fontSize}px "Share Tech Mono", "Courier New", monospace`;
            scrollerCtx.textBaseline = 'middle';

            // Calculate text width for looping (wider for letter-spacing effect)
            const charWidth = fontSize * 0.72;
            const totalWidth = scrollText.length * charWidth;

            // Draw each character with sine wave offset
            const time = Date.now() * 0.003;

            for (let i = 0; i < scrollText.length; i++) {
                const char = scrollText[i];
                const x = i * charWidth - scrollX;

                // Skip if off screen
                if (x < -charWidth || x > width + charWidth) continue;

                // Sine wave for Y position (bouncing effect)
                const waveOffset = Math.sin(time + i * 0.3) * 15;
                const y = height / 2 + waveOffset;

                // Color gradient cycling (Amiga copper bar style)
                const hue = (time * 50 + i * 8) % 360;
                const saturation = 100;
                const lightness = 50 + Math.sin(time + i * 0.2) * 15;

                // Draw shadow
                scrollerCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                scrollerCtx.fillText(char, x + 3, y + 3);

                // Draw subtle arcade glow
                scrollerCtx.shadowColor = `hsl(${hue}, 100%, 60%)`;
                scrollerCtx.shadowBlur = 12;

                // Draw main character with gradient
                const gradient = scrollerCtx.createLinearGradient(x, y - fontSize/2, x, y + fontSize/2);
                gradient.addColorStop(0, `hsl(${hue}, ${saturation}%, ${lightness + 20}%)`);
                gradient.addColorStop(0.5, `hsl(${hue}, ${saturation}%, ${lightness}%)`);
                gradient.addColorStop(1, `hsl(${hue + 30}, ${saturation}%, ${lightness - 10}%)`);

                scrollerCtx.fillStyle = gradient;
                scrollerCtx.fillText(char, x, y);

                // Reset shadow for highlight
                scrollerCtx.shadowBlur = 0;

                // Chrome/metallic highlight
                scrollerCtx.fillStyle = `rgba(255, 255, 255, ${0.3 + Math.sin(time * 2 + i * 0.5) * 0.2})`;
                scrollerCtx.fillText(char, x, y - 2);
            }

            // Move scroll position
            scrollX += 3;
            if (scrollX > totalWidth) {
                scrollX = 0;
            }

            // Continue animation if splash screen is visible
            const splash = document.getElementById('splashScreen');
            if (splash && !splash.classList.contains('hidden')) {
                scrollerAnimationId = requestAnimationFrame(drawAmigaScroller);
            }
        }

        function startScroller() {
            initScrollerCanvas();
            if (scrollerCtx) {
                drawAmigaScroller();
            }
        }

        // Handle resize for scroller
        window.addEventListener('resize', () => {
            const splash = document.getElementById('splashScreen');
            if (splash && !splash.classList.contains('hidden')) {
                initScrollerCanvas();
            }
        });

        // ========================================
        // Loading Screen System
        // ========================================
        const loadingTips = [
            'Use arrow keys to move and SPACE to shoot',
            'Collect power-ups for special abilities',
            'Defeat the boss at the end of each level',
            'Combos multiply your score',
            'Visit the shop to upgrade your ship',
            'Try different game modes for variety',
            'Triple Shot and Laser are powerful upgrades',
            'Shields can save your life in tough spots',
            'Boss attacks have patterns - learn them!',
            'The garage lets you customize your ship'
        ];

        function initLoadingStars() {
            const container = document.getElementById('loadingStars');
            if (!container) return;

            for (let i = 0; i < 50; i++) {
                const star = document.createElement('div');
                star.className = 'loading-star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 1.5 + 's';
                const size = Math.random() * 2 + 1;
                star.style.width = size + 'px';
                star.style.height = size + 'px';
                container.appendChild(star);
            }
        }

        function updateLoadingProgress(percent, text) {
            const bar = document.getElementById('loadingBar');
            const percentText = document.getElementById('loadingPercent');
            const loadingText = document.getElementById('loadingText');

            if (bar) bar.style.width = percent + '%';
            if (percentText) percentText.textContent = Math.round(percent) + '%';
            if (loadingText && text) loadingText.textContent = text;
        }

        function cycleTips() {
            const tipsEl = document.getElementById('loadingTips');
            if (!tipsEl) return;

            let tipIndex = 0;
            tipsEl.textContent = loadingTips[tipIndex];

            return setInterval(() => {
                tipIndex = (tipIndex + 1) % loadingTips.length;
                tipsEl.style.opacity = '0';
                setTimeout(() => {
                    tipsEl.textContent = loadingTips[tipIndex];
                    tipsEl.style.opacity = '1';
                }, 300);
            }, 3000);
        }

        function runLoadingSequence() {
            return new Promise((resolve) => {
                initLoadingStars();
                const tipInterval = cycleTips();

                const stages = [
                    { percent: 10, text: 'Loading assets...', delay: 200 },
                    { percent: 25, text: 'Initializing audio...', delay: 300 },
                    { percent: 40, text: 'Setting up graphics...', delay: 250 },
                    { percent: 55, text: 'Loading enemies...', delay: 300 },
                    { percent: 70, text: 'Preparing weapons...', delay: 250 },
                    { percent: 85, text: 'Calibrating shields...', delay: 200 },
                    { percent: 95, text: 'Almost ready...', delay: 300 },
                    { percent: 100, text: 'Launch ready!', delay: 400 }
                ];

                let stageIndex = 0;

                function nextStage() {
                    if (stageIndex < stages.length) {
                        const stage = stages[stageIndex];
                        updateLoadingProgress(stage.percent, stage.text);
                        stageIndex++;
                        setTimeout(nextStage, stage.delay);
                    } else {
                        clearInterval(tipInterval);
                        setTimeout(() => {
                            const loadingScreen = document.getElementById('loadingScreen');
                            const splashScreen = document.getElementById('splashScreen');

                            if (loadingScreen) {
                                loadingScreen.classList.add('hidden');
                            }
                            if (splashScreen) {
                                splashScreen.classList.remove('hidden');
                            }
                            resolve();
                        }, 500);
                    }
                }

                setTimeout(nextStage, 300);
            });
        }

        // Start loading sequence immediately
        (function() {
            try {
                runLoadingSequence().then(() => {
                    setTimeout(() => {
                        try {
                            initSplashStars();
                            startScroller();
                            // Music starts on user interaction (click/tap/key)
                        } catch (e) {
                            // Splash init error - continue
                        }
                    }, 100);
                }).catch(err => {
                    // Fallback: skip loading screen
                    document.getElementById('loadingScreen')?.classList.add('hidden');
                    document.getElementById('splashScreen')?.classList.remove('hidden');
                });
            } catch (e) {
                // Fallback: skip loading screen
                document.getElementById('loadingScreen')?.classList.add('hidden');
                document.getElementById('splashScreen')?.classList.remove('hidden');
            }
        })();

        // ========================================
        // UI Particles System
        // ========================================
        function createCosmicDust(container, count = 30) {
            if (!container) return;

            // Clear existing dust
            container.querySelectorAll('.dust-particle').forEach(p => p.remove());

            for (let i = 0; i < count; i++) {
                const dust = document.createElement('div');
                dust.className = 'dust-particle';
                dust.style.left = Math.random() * 100 + '%';
                dust.style.animationDelay = Math.random() * 10 + 's';
                dust.style.animationDuration = (8 + Math.random() * 6) + 's';
                dust.style.opacity = Math.random() * 0.5 + 0.2;
                const size = Math.random() * 2 + 1;
                dust.style.width = size + 'px';
                dust.style.height = size + 'px';
                container.appendChild(dust);
            }
        }

        function createFloatingDots(container, count = 15) {
            if (!container) return;

            for (let i = 0; i < count; i++) {
                const dot = document.createElement('div');
                dot.className = 'floating-dot';
                dot.style.left = Math.random() * 100 + '%';
                dot.style.top = Math.random() * 100 + '%';
                dot.style.animationDelay = Math.random() * 8 + 's';

                // Random colors
                const colors = ['rgba(0, 255, 255, 0.3)', 'rgba(255, 0, 255, 0.3)', 'rgba(255, 255, 0, 0.3)'];
                dot.style.background = colors[Math.floor(Math.random() * colors.length)];
                dot.style.boxShadow = `0 0 10px ${dot.style.background}`;

                const size = Math.random() * 3 + 2;
                dot.style.width = size + 'px';
                dot.style.height = size + 'px';

                dot.style.animation = `floatParticle ${6 + Math.random() * 4}s ease-in-out infinite`;

                container.appendChild(dot);
            }
        }

        function spawnAchievementParticles(x, y, icon = '') {
            const particles = ['', '', '', '', icon];

            for (let i = 0; i < 12; i++) {
                const particle = document.createElement('div');
                particle.className = 'achievement-particle';
                particle.textContent = particles[Math.floor(Math.random() * particles.length)];
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';

                // Random direction
                const angle = (Math.PI * 2 * i) / 12 + (Math.random() - 0.5) * 0.5;
                const distance = 80 + Math.random() * 60;
                const tx = Math.cos(angle) * distance;
                const ty = Math.sin(angle) * distance;

                particle.style.setProperty('--tx', tx + 'px');
                particle.style.setProperty('--ty', ty + 'px');

                document.body.appendChild(particle);

                setTimeout(() => {
                    particle.remove();
                }, 1000);
            }
        }

        // Initialize particles on start screen
        function initUIParticles() {
            const startScreen = document.getElementById('startScreen');
            if (startScreen) {
                // Add cosmic dust container
                let dustContainer = startScreen.querySelector('.cosmic-dust');
                if (!dustContainer) {
                    dustContainer = document.createElement('div');
                    dustContainer.className = 'cosmic-dust';
                    startScreen.insertBefore(dustContainer, startScreen.firstChild);
                }
                createCosmicDust(dustContainer, 25);

                // Add floating dots
                let dotsContainer = startScreen.querySelector('.floating-dots');
                if (!dotsContainer) {
                    dotsContainer = document.createElement('div');
                    dotsContainer.className = 'floating-dots';
                    startScreen.insertBefore(dotsContainer, startScreen.firstChild);
                }
                createFloatingDots(dotsContainer, 12);
            }

            // Add sparkle effect to mode cards
            document.querySelectorAll('.mode-card').forEach(card => {
                card.classList.add('sparkle-btn');
            });

            // Add glow border to important buttons
            document.querySelectorAll('.pause-btn.primary, .shop-buy-btn').forEach(btn => {
                btn.classList.add('glow-border');
            });
        }

        // Run particles init after a short delay
        setTimeout(initUIParticles, 500);

        // ========================================
        // Lifetime Statistics System
        // ========================================
        let lifetimeStats = {
            gamesPlayed: 0,
            highScore: 0,
            highLevel: 0,
            totalKills: 0,
            bossKills: 0,
            bestCombo: 0,
            powerUpsCollected: 0,
            totalCoinsEarned: 0,
            challengesCompleted: 0,
            totalPlayTime: 0 // in seconds
        };

        function loadLifetimeStats() {
            const stored = localStorage.getItem('lifetimeStats');
            if (stored) {
                lifetimeStats = { ...lifetimeStats, ...JSON.parse(stored) };

                // Migration: Fix corrupted totalPlayTime (bug caused values like 491298 hours)
                // If totalPlayTime is greater than 1 year in seconds, it's corrupted - reset it
                const oneYearInSeconds = 365 * 24 * 60 * 60; // 31,536,000 seconds
                if (lifetimeStats.totalPlayTime > oneYearInSeconds) {
                    console.log('Fixing corrupted totalPlayTime:', lifetimeStats.totalPlayTime);
                    lifetimeStats.totalPlayTime = 0;
                    saveLifetimeStats();
                }
            }
        }

        function saveLifetimeStats() {
            localStorage.setItem('lifetimeStats', JSON.stringify(lifetimeStats));
        }

        function updateLifetimeStat(stat, value, mode = 'add') {
            if (mode === 'add') {
                lifetimeStats[stat] = (lifetimeStats[stat] || 0) + value;
            } else if (mode === 'max') {
                lifetimeStats[stat] = Math.max(lifetimeStats[stat] || 0, value);
            } else if (mode === 'set') {
                lifetimeStats[stat] = value;
            }
            saveLifetimeStats();
        }

        function formatPlayTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            if (hours > 0) {
                return `${hours}h ${mins}m`;
            }
            return `${mins}m`;
        }

        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            }
            if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toString();
        }

        function updateStatsUI() {
            document.getElementById('statHighScore').textContent = formatNumber(lifetimeStats.highScore);
            document.getElementById('statGamesPlayed').textContent = formatNumber(lifetimeStats.gamesPlayed);
            document.getElementById('statHighLevel').textContent = lifetimeStats.highLevel;
            document.getElementById('statTotalTime').textContent = formatPlayTime(lifetimeStats.totalPlayTime);
            document.getElementById('statTotalKills').textContent = formatNumber(lifetimeStats.totalKills);
            document.getElementById('statBossKills').textContent = lifetimeStats.bossKills;
            document.getElementById('statBestCombo').textContent = lifetimeStats.bestCombo + 'x';
            document.getElementById('statPowerUps').textContent = formatNumber(lifetimeStats.powerUpsCollected);
            document.getElementById('statTotalCoins').textContent = formatNumber(lifetimeStats.totalCoinsEarned);
            document.getElementById('statChallenges').textContent = lifetimeStats.challengesCompleted;
        }

        function openStats() {
            updateStatsUI();
            document.getElementById('statsScreen').classList.remove('hidden');
            playSelectSound();
        }

        function closeStats() {
            document.getElementById('statsScreen').classList.add('hidden');
            playSelectSound();
        }

        function openFeedback() {
            playSelectSound();
            window.open('https://forms.gle/RsnfSqPeikNJnLyMA', '_blank');
        }

        // Custom confirm modal system
        let confirmCallback = null;

        function showConfirmModal(title, message, onConfirm) {
            document.getElementById('confirmTitle').textContent = title;
            document.getElementById('confirmMessage').textContent = message;
            confirmCallback = onConfirm;
            document.getElementById('confirmModal').classList.add('active');
            playSelectSound();
        }

        function hideConfirmModal() {
            document.getElementById('confirmModal').classList.remove('active');
            confirmCallback = null;
            playSelectSound();
        }

        function executeConfirmAction() {
            if (confirmCallback) {
                confirmCallback();
            }
            hideConfirmModal();
        }

        function confirmResetStats() {
            showConfirmModal(
                'Reset Statistics',
                'Are you sure you want to reset all statistics? This cannot be undone!',
                () => {
                    lifetimeStats = {
                        gamesPlayed: 0,
                        highScore: 0,
                        highLevel: 0,
                        totalKills: 0,
                        bossKills: 0,
                        bestCombo: 0,
                        powerUpsCollected: 0,
                        totalCoinsEarned: 0,
                        challengesCompleted: 0,
                        totalPlayTime: 0
                    };
                    saveLifetimeStats();
                    updateStatsUI();
                    showShareToast('Statistics have been reset');
                }
            );
        }

        // Load stats on startup
        loadLifetimeStats();

        // Update Pilot Profile on start screen
        function getPilotRank(gamesPlayed, highScore) {
            if (highScore >= 100000) return { badge: 'LEGENDARY', text: 'Master of the cosmos', avatar: '' };
            if (highScore >= 50000) return { badge: 'ACE', text: 'Elite pilot', avatar: '' };
            if (gamesPlayed >= 100) return { badge: 'VETERAN', text: 'Battle-hardened', avatar: '' };
            if (gamesPlayed >= 50) return { badge: 'CAPTAIN', text: 'Experienced commander', avatar: '' };
            if (gamesPlayed >= 25) return { badge: 'LIEUTENANT', text: 'Rising star', avatar: '' };
            if (gamesPlayed >= 10) return { badge: 'PILOT', text: 'Licensed and ready', avatar: '' };
            if (gamesPlayed >= 5) return { badge: 'CADET', text: 'Learning the ropes', avatar: '' };
            return { badge: 'ROOKIE', text: 'Ready for action', avatar: '' };
        }

        function updatePilotProfile() {
            const rank = getPilotRank(lifetimeStats.gamesPlayed, lifetimeStats.highScore);

            const rankBadge = document.querySelector('.pilot-rank-badge');
            const rankText = document.getElementById('pilotRankText');
            const avatar = document.querySelector('.pilot-avatar');
            const pilotGames = document.getElementById('pilotGames');
            const pilotBest = document.getElementById('pilotBest');
            const pilotKills = document.getElementById('pilotKills');

            if (rankBadge) rankBadge.textContent = rank.badge;
            if (rankText) rankText.textContent = rank.text;
            if (avatar) avatar.textContent = rank.avatar;
            if (pilotGames) pilotGames.textContent = formatNumber(lifetimeStats.gamesPlayed);
            if (pilotBest) pilotBest.textContent = formatNumber(lifetimeStats.highScore);
            if (pilotKills) pilotKills.textContent = formatNumber(lifetimeStats.totalKills);
        }

        // Initialize pilot profile
        updatePilotProfile();

        // Load menu music setting
        loadMenuMusicSetting();

        // ========================================
        // Screen Transition System
        // ========================================
        const transitionMessages = {
            game: { icon: '', text: 'Launching...' },
            menu: { icon: '', text: 'Returning...' },
            shop: { icon: '', text: 'Opening Shop...' },
            garage: { icon: '', text: 'Entering Garage...' },
            gameOver: { icon: '', text: 'Game Over...' },
            victory: { icon: '', text: 'Victory!' },
            restart: { icon: '', text: 'Restarting...' }
        };

        function showScreenTransition(type = 'game', callback = null, duration = 400) {
            const overlay = document.getElementById('screenTransition');
            const icon = document.getElementById('transitionIcon');
            const text = document.getElementById('transitionText');

            if (!overlay) {
                if (callback) {
                    try { callback(); } catch(e) { console.error('Transition callback error:', e); }
                }
                return;
            }

            const message = transitionMessages[type] || transitionMessages.game;
            if (icon) icon.textContent = message.icon;
            if (text) text.textContent = message.text;

            // Show overlay
            overlay.classList.add('active');

            // Execute callback at midpoint
            setTimeout(() => {
                try {
                    if (callback) callback();
                } catch(e) {
                    console.error('Transition callback error:', e);
                }

                // Hide overlay (always, even if callback fails)
                setTimeout(() => {
                    overlay.classList.remove('active');
                }, duration / 2);
            }, duration / 2);
        }

        function fadeOutElement(element, callback = null) {
            if (!element) {
                if (callback) callback();
                return;
            }

            element.classList.add('fade-transition');
            element.classList.add('fade-out');

            setTimeout(() => {
                element.classList.add('hidden');
                element.classList.remove('fade-out');
                element.classList.remove('fade-transition');
                if (callback) callback();
            }, 300);
        }

        function fadeInElement(element, callback = null) {
            if (!element) {
                if (callback) callback();
                return;
            }

            element.classList.remove('hidden');
            element.classList.add('fade-transition');
            element.classList.add('fade-out');

            // Force reflow
            void element.offsetWidth;

            element.classList.remove('fade-out');
            element.classList.add('fade-in');

            setTimeout(() => {
                element.classList.remove('fade-transition');
                element.classList.remove('fade-in');
                if (callback) callback();
            }, 300);
        }

        function slideUpElement(element) {
            if (!element) return;
            element.classList.remove('hidden');
            element.classList.add('slide-up');
            setTimeout(() => {
                element.classList.remove('slide-up');
            }, 400);
        }

        // ========================================
        // Splash Screen System
        // ========================================

        // Create stars for splash screen
        function initSplashStars() {
            const container = document.getElementById('splashStars');
            if (!container) return;

            for (let i = 0; i < 100; i++) {
                const star = document.createElement('div');
                star.className = 'splash-star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 2 + 's';
                star.style.animationDuration = (1.5 + Math.random() * 1.5) + 's';
                const size = Math.random() * 2 + 1;
                star.style.width = size + 'px';
                star.style.height = size + 'px';
                container.appendChild(star);
            }
        }

        // Start music on first interaction (browser autoplay policy)
        let splashMusicStarted = false;
        function startSplashMusicOnce() {
            if (!splashMusicStarted && isMusicEnabled) {
                splashMusicStarted = true;
                try {
                    createSplashMusic();
                } catch (e) {
                    // Music failed to start
                }
            }
        }

        // Hide splash screen on click/tap
        function hideSplashScreen() {
            const splash = document.getElementById('splashScreen');
            if (splash) {
                splash.classList.add('hidden');
                // Stop scroller animation
                if (scrollerAnimationId) {
                    cancelAnimationFrame(scrollerAnimationId);
                    scrollerAnimationId = null;
                }
                // Set UI state to menu
                setUIState('menu');
                // Keep menu music playing - it will stop when game starts
                // Play a sound effect when entering
                if (typeof initAudio === 'function') {
                    initAudio();
                }
            }
        }

        // Initialize splash screen (after loading screen completes)
        const splashScreen = document.getElementById('splashScreen');
        if (splashScreen) {
            // Track if music has started (for two-step interaction)
            let musicStartedByUser = false;

            // Handle splash interaction: single click/tap/key to proceed
            function handleSplashInteraction(e) {
                if (e && e.preventDefault) e.preventDefault();

                // Try to start music (may fail due to autoplay policy, that's ok)
                try {
                    startSplashMusicOnce();
                } catch (err) {
                    // Ignore music errors
                }

                // Always proceed to game
                hideSplashScreen();
            }

            // Click anywhere to continue
            splashScreen.addEventListener('click', handleSplashInteraction);

            // Touch to continue (mobile)
            splashScreen.addEventListener('touchend', handleSplashInteraction);

            // Any key to continue
            document.addEventListener('keydown', function splashKeyHandler(e) {
                if (!splashScreen.classList.contains('hidden')) {
                    handleSplashInteraction(e);
                }
            });
        }

        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then((registration) => {
                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    showShareToast('New version available! Refresh to update.');
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        // Service worker registration failed - continue without SW
                    });
            });
        }

        // PWA Install Prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            // Show install button
            const installBtn = document.getElementById('installPwaBtn');
            if (installBtn) installBtn.classList.remove('hidden');
        });

        async function installPwa() {
            if (!deferredPrompt) return;

            deferredPrompt.prompt();
            const { outcome } = await deferredPrompt.userChoice;

            if (outcome === 'accepted') {
                showShareToast('App installed successfully!');
            }
            deferredPrompt = null;

            const installBtn = document.getElementById('installPwaBtn');
            if (installBtn) installBtn.classList.add('hidden');
        }

        // Check if running as PWA
        function isPwaInstalled() {
            return window.matchMedia('(display-mode: standalone)').matches ||
                   window.navigator.standalone === true;
        }

        // Fullscreen toggle
        function updateFullscreenBtn(isFullscreen) {
            const btn = document.getElementById('fullscreenBtn');
            if (btn) {
                const iconSpan = btn.querySelector('.btn-icon');
                const labelSpan = btn.querySelector('.btn-label');
                if (iconSpan) iconSpan.textContent = isFullscreen ? '' : '';
                if (labelSpan) labelSpan.textContent = isFullscreen ? 'Exit' : 'Fullscreen';
            }
        }

        function toggleFullscreen() {
            const elem = document.documentElement;

            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                // Enter fullscreen
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen(); // Safari
                }
                updateFullscreenBtn(true);
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen(); // Safari
                }
                updateFullscreenBtn(false);
            }
        }

        // Update button text on fullscreen change
        document.addEventListener('fullscreenchange', () => {
            updateFullscreenBtn(!!document.fullscreenElement);
        });

        document.addEventListener('webkitfullscreenchange', () => {
            updateFullscreenBtn(!!document.webkitFullscreenElement);
        });

        // F key for fullscreen during gameplay
        document.addEventListener('keydown', (e) => {
            if (e.key === 'f' || e.key === 'F') {
                if (gameRunning && !document.activeElement.matches('input')) {
                    toggleFullscreen();
                }
            }
        });

        // ==========================================
        // FIRST-TIME USER EXPERIENCE (FTUE) SYSTEM
        // ==========================================
        const FTUE_STORAGE_KEY = 'cosmicBlasterzFTUECompleted';
        let ftueActive = false;
        let ftueStep = 1;

        // Check if player is first-time
        function isFirstTimePlayer() {
            return localStorage.getItem(FTUE_STORAGE_KEY) !== 'true';
        }

        // Mark FTUE as completed
        function markFTUEComplete() {
            localStorage.setItem(FTUE_STORAGE_KEY, 'true');
        }

        // Show FTUE overlay
        function showFTUE() {
            if (!isFirstTimePlayer()) return;
            ftueActive = true;
            ftueStep = 1;
            const overlay = document.getElementById('ftueOverlay');
            if (overlay) {
                overlay.classList.add('active');
                // Reset steps
                document.querySelectorAll('.ftue-step').forEach((step, i) => {
                    step.classList.toggle('active', i === 0);
                });
            }
        }

        // Hide FTUE overlay
        function hideFTUE() {
            ftueActive = false;
            const overlay = document.getElementById('ftueOverlay');
            if (overlay) {
                overlay.classList.remove('active');
            }
        }

        // Go to next FTUE step
        function nextFTUEStep() {
            ftueStep++;
            document.querySelectorAll('.ftue-step').forEach((step, i) => {
                step.classList.toggle('active', i === ftueStep - 1);
            });
        }

        // Skip FTUE
        function skipFTUE() {
            markFTUEComplete();
            hideFTUE();
        }

        // Complete FTUE
        function completeFTUE() {
            markFTUEComplete();
            hideFTUE();
        }

        // Auto-complete FTUE on first kill (called from enemy death code)
        function onFirstKill() {
            if (ftueActive) {
                markFTUEComplete();
                hideFTUE();
            }
        }

        // ==========================================
        // VISUAL FEEDBACK: FLOATING TEXT
        // ==========================================
        function showFloatingText(x, y, text, type = 'default') {
            const container = document.querySelector('.game-container');
            if (!container) return;

            const floatingText = document.createElement('div');
            floatingText.className = `floating-text ${type}`;
            floatingText.textContent = text;

            // Convert canvas coordinates to screen coordinates
            const canvas = document.getElementById('gameCanvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = rect.width / canvas.width;
            const scaleY = rect.height / canvas.height;

            floatingText.style.left = (rect.left + x * scaleX) + 'px';
            floatingText.style.top = (rect.top + y * scaleY) + 'px';

            document.body.appendChild(floatingText);

            // Remove after animation
            setTimeout(() => {
                floatingText.remove();
            }, 1200);
        }

        // ==========================================
        // VISUAL FEEDBACK: ENEMY HIT EFFECT
        // ==========================================
        function createHitFlash(x, y, size = 40) {
            const container = document.querySelector('.game-container');
            if (!container) return;

            const flash = document.createElement('div');
            flash.className = 'hit-flash';

            // Convert canvas coordinates
            const canvas = document.getElementById('gameCanvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = rect.width / canvas.width;
            const scaleY = rect.height / canvas.height;

            flash.style.width = size + 'px';
            flash.style.height = size + 'px';
            flash.style.left = (rect.left + x * scaleX - size / 2) + 'px';
            flash.style.top = (rect.top + y * scaleY - size / 2) + 'px';

            document.body.appendChild(flash);

            // Remove after animation
            setTimeout(() => {
                flash.remove();
            }, 200);
        }

        // 3D Starfield Effect
        (function initStarfield() {
            const canvas = document.getElementById('starfieldCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const stars = [];
            const numStars = 200;
            let animationId;

            function resizeCanvas() {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            }

            function createStar() {
                return {
                    x: Math.random() * canvas.width - canvas.width / 2,
                    y: Math.random() * canvas.height - canvas.height / 2,
                    z: Math.random() * canvas.width,
                    color: Math.random() > 0.8 ?
                        `hsl(${180 + Math.random() * 60}, 100%, 70%)` :
                        `hsl(${Math.random() * 360}, 50%, ${70 + Math.random() * 30}%)`
                };
            }

            function initStars() {
                stars.length = 0;
                for (let i = 0; i < numStars; i++) {
                    stars.push(createStar());
                }
            }

            function drawStars() {
                ctx.fillStyle = 'rgba(0, 5, 15, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                for (let star of stars) {
                    star.z -= 2;

                    if (star.z <= 0) {
                        star.x = Math.random() * canvas.width - centerX;
                        star.y = Math.random() * canvas.height - centerY;
                        star.z = canvas.width;
                    }

                    const factor = 200 / star.z;
                    const x = star.x * factor + centerX;
                    const y = star.y * factor + centerY;
                    const size = Math.max(0.5, (1 - star.z / canvas.width) * 3);
                    const brightness = 1 - star.z / canvas.width;

                    if (x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height) {
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fillStyle = star.color;
                        ctx.globalAlpha = brightness;
                        ctx.fill();

                        // Add glow for closer stars
                        if (size > 1.5) {
                            ctx.beginPath();
                            ctx.arc(x, y, size * 2, 0, Math.PI * 2);
                            ctx.fillStyle = star.color;
                            ctx.globalAlpha = brightness * 0.3;
                            ctx.fill();
                        }
                    }
                }
                ctx.globalAlpha = 1;
            }

            function animate() {
                drawStars();
                animationId = requestAnimationFrame(animate);
            }

            resizeCanvas();
            initStars();
            animate();

            window.addEventListener('resize', () => {
                resizeCanvas();
                initStars();
            });
        })();

        // Auto-scroll highscore lists (menu and game over)
        (function initHighscoreScroll() {
            const scrollStates = {};

            function setupAutoScroll(containerId) {
                if (!scrollStates[containerId]) {
                    scrollStates[containerId] = {
                        interval: null,
                        isPaused: false,
                        direction: 1,
                        scroll: 0,
                        initialized: false
                    };
                }

                const state = scrollStates[containerId];
                const wrapper = document.querySelector(`#${containerId} .highscore-scroll-wrapper`);
                const entries = document.querySelector(`#${containerId} .highscore-entries`);

                if (!wrapper || !entries) {
                    setTimeout(() => setupAutoScroll(containerId), 1000);
                    return;
                }

                const maxScroll = Math.max(0, entries.scrollHeight - wrapper.clientHeight);

                if (maxScroll <= 0) {
                    setTimeout(() => setupAutoScroll(containerId), 2000);
                    return;
                }

                clearInterval(state.interval);
                state.interval = setInterval(() => {
                    if (state.isPaused) return;

                    state.scroll += state.direction * 0.5;

                    if (state.scroll >= maxScroll) {
                        state.scroll = maxScroll;
                        state.direction = -1;
                    } else if (state.scroll <= 0) {
                        state.scroll = 0;
                        state.direction = 1;
                    }

                    entries.style.transform = `translateY(-${state.scroll}px)`;
                }, 30);

                if (!state.initialized) {
                    wrapper.addEventListener('mouseenter', () => { state.isPaused = true; });
                    wrapper.addEventListener('mouseleave', () => { state.isPaused = false; });
                    state.initialized = true;
                }
            }

            function resetAndStart(containerId) {
                if (scrollStates[containerId]) {
                    scrollStates[containerId].scroll = 0;
                    scrollStates[containerId].direction = 1;
                }
                setTimeout(() => setupAutoScroll(containerId), 500);
            }

            // Setup observers for both containers
            ['startHighscores', 'gameOverHighscores'].forEach(containerId => {
                const container = document.getElementById(containerId);
                if (container) {
                    const observer = new MutationObserver(() => resetAndStart(containerId));
                    observer.observe(container, { childList: true, subtree: true });
                }
            });

            // Start menu highscores after load
            setTimeout(() => setupAutoScroll('startHighscores'), 2000);
        })();
    </script>

    <!-- Goat Counter Analytics (privacy-friendly, no cookies) -->
    <script data-goatcounter="https://mricebird.goatcounter.com/count"
            async src="//gc.zgo.at/count.js"></script>
</body>
</html>
